{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getArtifactFromContractOutput = exports.Artifacts = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst fs_extra_1 = __importDefault(require(\"fs-extra\"));\nconst os = __importStar(require(\"os\"));\nconst path = __importStar(require(\"path\"));\nconst promises_1 = __importDefault(require(\"fs/promises\"));\nconst contract_names_1 = require(\"../utils/contract-names\");\nconst source_names_1 = require(\"../utils/source-names\");\nconst constants_1 = require(\"./constants\");\nconst errors_1 = require(\"./core/errors\");\nconst errors_list_1 = require(\"./core/errors-list\");\nconst hash_1 = require(\"./util/hash\");\nconst fs_utils_1 = require(\"./util/fs-utils\");\nconst log = (0, debug_1.default)(\"hardhat:core:artifacts\");\nclass Artifacts {\n  constructor(_artifactsPath) {\n    this._artifactsPath = _artifactsPath;\n    // Undefined means that the cache is disabled.\n    this._cache = {\n      artifactNameToArtifactPathCache: new Map(),\n      artifactFQNToBuildInfoPathCache: new Map()\n    };\n    this._validArtifacts = [];\n  }\n  addValidArtifacts(validArtifacts) {\n    this._validArtifacts.push(...validArtifacts);\n  }\n  async readArtifact(name) {\n    const artifactPath = await this._getArtifactPath(name);\n    return fs_extra_1.default.readJson(artifactPath);\n  }\n  readArtifactSync(name) {\n    const artifactPath = this._getArtifactPathSync(name);\n    return fs_extra_1.default.readJsonSync(artifactPath);\n  }\n  async artifactExists(name) {\n    let artifactPath;\n    try {\n      artifactPath = await this._getArtifactPath(name);\n    } catch (e) {\n      if (errors_1.HardhatError.isHardhatError(e)) {\n        return false;\n      }\n      // eslint-disable-next-line @nomicfoundation/hardhat-internal-rules/only-hardhat-error\n      throw e;\n    }\n    return fs_extra_1.default.pathExists(artifactPath);\n  }\n  async getAllFullyQualifiedNames() {\n    const paths = await this.getArtifactPaths();\n    return paths.map(p => this._getFullyQualifiedNameFromPath(p)).sort();\n  }\n  async getBuildInfo(fullyQualifiedName) {\n    let buildInfoPath = this._cache?.artifactFQNToBuildInfoPathCache.get(fullyQualifiedName);\n    if (buildInfoPath === undefined) {\n      const artifactPath = this.formArtifactPathFromFullyQualifiedName(fullyQualifiedName);\n      const debugFilePath = this._getDebugFilePath(artifactPath);\n      buildInfoPath = await this._getBuildInfoFromDebugFile(debugFilePath);\n      if (buildInfoPath === undefined) {\n        return undefined;\n      }\n      this._cache?.artifactFQNToBuildInfoPathCache.set(fullyQualifiedName, buildInfoPath);\n    }\n    return fs_extra_1.default.readJSON(buildInfoPath);\n  }\n  getBuildInfoSync(fullyQualifiedName) {\n    let buildInfoPath = this._cache?.artifactFQNToBuildInfoPathCache.get(fullyQualifiedName);\n    if (buildInfoPath === undefined) {\n      const artifactPath = this.formArtifactPathFromFullyQualifiedName(fullyQualifiedName);\n      const debugFilePath = this._getDebugFilePath(artifactPath);\n      buildInfoPath = this._getBuildInfoFromDebugFileSync(debugFilePath);\n      if (buildInfoPath === undefined) {\n        return undefined;\n      }\n      this._cache?.artifactFQNToBuildInfoPathCache.set(fullyQualifiedName, buildInfoPath);\n    }\n    return fs_extra_1.default.readJSONSync(buildInfoPath);\n  }\n  async getArtifactPaths() {\n    const cached = this._cache?.artifactPaths;\n    if (cached !== undefined) {\n      return cached;\n    }\n    const buildInfosDir = path.join(this._artifactsPath, constants_1.BUILD_INFO_DIR_NAME);\n    const paths = await (0, fs_utils_1.getAllFilesMatching)(this._artifactsPath, f => f.endsWith(\".json\") && !f.startsWith(buildInfosDir) && !f.endsWith(\".dbg.json\"));\n    const result = paths.sort();\n    if (this._cache !== undefined) {\n      this._cache.artifactPaths = result;\n    }\n    return result;\n  }\n  async getBuildInfoPaths() {\n    const cached = this._cache?.buildInfoPaths;\n    if (cached !== undefined) {\n      return cached;\n    }\n    const paths = await (0, fs_utils_1.getAllFilesMatching)(path.join(this._artifactsPath, constants_1.BUILD_INFO_DIR_NAME), f => f.endsWith(\".json\"));\n    const result = paths.sort();\n    if (this._cache !== undefined) {\n      this._cache.buildInfoPaths = result;\n    }\n    return result;\n  }\n  async getDebugFilePaths() {\n    const cached = this._cache?.debugFilePaths;\n    if (cached !== undefined) {\n      return cached;\n    }\n    const paths = await (0, fs_utils_1.getAllFilesMatching)(path.join(this._artifactsPath), f => f.endsWith(\".dbg.json\"));\n    const result = paths.sort();\n    if (this._cache !== undefined) {\n      this._cache.debugFilePaths = result;\n    }\n    return result;\n  }\n  async saveArtifactAndDebugFile(artifact, pathToBuildInfo) {\n    try {\n      // artifact\n      const fullyQualifiedName = (0, contract_names_1.getFullyQualifiedName)(artifact.sourceName, artifact.contractName);\n      const artifactPath = this.formArtifactPathFromFullyQualifiedName(fullyQualifiedName);\n      await fs_extra_1.default.ensureDir(path.dirname(artifactPath));\n      await Promise.all([fs_extra_1.default.writeJSON(artifactPath, artifact, {\n        spaces: 2\n      }), (async () => {\n        if (pathToBuildInfo === undefined) {\n          return;\n        }\n        // save debug file\n        const debugFilePath = this._getDebugFilePath(artifactPath);\n        const debugFile = this._createDebugFile(artifactPath, pathToBuildInfo);\n        await fs_extra_1.default.writeJSON(debugFilePath, debugFile, {\n          spaces: 2\n        });\n      })()]);\n    } finally {\n      this.clearCache();\n    }\n  }\n  async saveBuildInfo(solcVersion, solcLongVersion, input, output) {\n    try {\n      const buildInfoDir = path.join(this._artifactsPath, constants_1.BUILD_INFO_DIR_NAME);\n      await fs_extra_1.default.ensureDir(buildInfoDir);\n      const buildInfoName = this._getBuildInfoName(solcVersion, solcLongVersion, input);\n      const buildInfo = this._createBuildInfo(buildInfoName, solcVersion, solcLongVersion, input, output);\n      const buildInfoPath = path.join(buildInfoDir, `${buildInfoName}.json`);\n      // JSON.stringify of the entire build info can be really slow\n      // in larger projects, so we stringify per part and incrementally create\n      // the JSON in the file.\n      //\n      // We split this code into different curly-brace-enclosed scopes so that\n      // partial JSON strings get out of scope sooner and hence can be reclaimed\n      // by the GC if needed.\n      const file = await promises_1.default.open(buildInfoPath, \"w\");\n      try {\n        {\n          const withoutOutput = JSON.stringify({\n            ...buildInfo,\n            output: undefined\n          });\n          // We write the JSON (without output) except the last }\n          await file.write(withoutOutput.slice(0, -1));\n        }\n        {\n          const outputWithoutSourcesAndContracts = JSON.stringify({\n            ...buildInfo.output,\n            sources: undefined,\n            contracts: undefined\n          });\n          // We start writing the output\n          await file.write(',\"output\":');\n          // Write the output object except for the last }\n          await file.write(outputWithoutSourcesAndContracts.slice(0, -1));\n          // If there were other field apart from sources and contracts we need\n          // a comma\n          if (outputWithoutSourcesAndContracts.length > 2) {\n            await file.write(\",\");\n          }\n        }\n        // Writing the sources\n        await file.write('\"sources\":{');\n        let isFirst = true;\n        for (const [name, value] of Object.entries(buildInfo.output.sources ?? {})) {\n          if (isFirst) {\n            isFirst = false;\n          } else {\n            await file.write(\",\");\n          }\n          await file.write(`${JSON.stringify(name)}:${JSON.stringify(value)}`);\n        }\n        // Close sources object\n        await file.write(\"}\");\n        // Writing the contracts\n        await file.write(',\"contracts\":{');\n        isFirst = true;\n        for (const [name, value] of Object.entries(buildInfo.output.contracts ?? {})) {\n          if (isFirst) {\n            isFirst = false;\n          } else {\n            await file.write(\",\");\n          }\n          await file.write(`${JSON.stringify(name)}:${JSON.stringify(value)}`);\n        }\n        // close contracts object\n        await file.write(\"}\");\n        // close output object\n        await file.write(\"}\");\n        // close build info object\n        await file.write(\"}\");\n      } finally {\n        await file.close();\n      }\n      return buildInfoPath;\n    } finally {\n      this.clearCache();\n    }\n  }\n  /**\n   * Remove all artifacts that don't correspond to the current solidity files\n   */\n  async removeObsoleteArtifacts() {\n    // We clear the cache here, as we want to be sure this runs correctly\n    this.clearCache();\n    try {\n      const validArtifactPaths = await Promise.all(this._validArtifacts.flatMap(({\n        sourceName,\n        artifacts\n      }) => artifacts.map(artifactName => this._getArtifactPath((0, contract_names_1.getFullyQualifiedName)(sourceName, artifactName)))));\n      const validArtifactsPathsSet = new Set(validArtifactPaths);\n      for (const {\n        sourceName,\n        artifacts\n      } of this._validArtifacts) {\n        for (const artifactName of artifacts) {\n          validArtifactsPathsSet.add(this.formArtifactPathFromFullyQualifiedName((0, contract_names_1.getFullyQualifiedName)(sourceName, artifactName)));\n        }\n      }\n      const existingArtifactsPaths = await this.getArtifactPaths();\n      await Promise.all(existingArtifactsPaths.filter(artifactPath => !validArtifactsPathsSet.has(artifactPath)).map(artifactPath => this._removeArtifactFiles(artifactPath)));\n      await this._removeObsoleteBuildInfos();\n    } finally {\n      // We clear the cache here, as this may have non-existent paths now\n      this.clearCache();\n    }\n  }\n  /**\n   * Returns the absolute path to the given artifact\n   * @throws {HardhatError} If the name is not fully qualified.\n   */\n  formArtifactPathFromFullyQualifiedName(fullyQualifiedName) {\n    const {\n      sourceName,\n      contractName\n    } = (0, contract_names_1.parseFullyQualifiedName)(fullyQualifiedName);\n    return path.join(this._artifactsPath, sourceName, `${contractName}.json`);\n  }\n  clearCache() {\n    // Avoid accidentally re-enabling the cache\n    if (this._cache === undefined) {\n      return;\n    }\n    this._cache = {\n      artifactFQNToBuildInfoPathCache: new Map(),\n      artifactNameToArtifactPathCache: new Map()\n    };\n  }\n  disableCache() {\n    this._cache = undefined;\n  }\n  /**\n   * Remove all build infos that aren't used by any debug file\n   */\n  async _removeObsoleteBuildInfos() {\n    const debugFiles = await this.getDebugFilePaths();\n    const buildInfos = await Promise.all(debugFiles.map(async debugFile => {\n      const buildInfoFile = await this._getBuildInfoFromDebugFile(debugFile);\n      if (buildInfoFile !== undefined) {\n        return path.resolve(path.dirname(debugFile), buildInfoFile);\n      }\n    }));\n    const filteredBuildInfos = buildInfos.filter(bf => typeof bf === \"string\");\n    const validBuildInfos = new Set(filteredBuildInfos);\n    const buildInfoFiles = await this.getBuildInfoPaths();\n    await Promise.all(buildInfoFiles.filter(buildInfoFile => !validBuildInfos.has(buildInfoFile)).map(async buildInfoFile => {\n      log(`Removing buildInfo '${buildInfoFile}'`);\n      await fs_extra_1.default.unlink(buildInfoFile);\n    }));\n  }\n  _getBuildInfoName(solcVersion, solcLongVersion, input) {\n    const json = JSON.stringify({\n      _format: constants_1.BUILD_INFO_FORMAT_VERSION,\n      solcVersion,\n      solcLongVersion,\n      input\n    });\n    return (0, hash_1.createNonCryptographicHashBasedIdentifier)(Buffer.from(json)).toString(\"hex\");\n  }\n  /**\n   * Returns the absolute path to the artifact that corresponds to the given\n   * name.\n   *\n   * If the name is fully qualified, the path is computed from it.  If not, an\n   * artifact that matches the given name is searched in the existing artifacts.\n   * If there is an ambiguity, an error is thrown.\n   *\n   * @throws {HardhatError} with descriptor:\n   * - {@link ERRORS.ARTIFACTS.WRONG_CASING} if the path case doesn't match the one in the filesystem.\n   * - {@link ERRORS.ARTIFACTS.MULTIPLE_FOUND} if there are multiple artifacts matching the given contract name.\n   * - {@link ERRORS.ARTIFACTS.NOT_FOUND} if the artifact is not found.\n   */\n  async _getArtifactPath(name) {\n    const cached = this._cache?.artifactNameToArtifactPathCache.get(name);\n    if (cached !== undefined) {\n      return cached;\n    }\n    let result;\n    if ((0, contract_names_1.isFullyQualifiedName)(name)) {\n      result = await this._getValidArtifactPathFromFullyQualifiedName(name);\n    } else {\n      const files = await this.getArtifactPaths();\n      result = this._getArtifactPathFromFiles(name, files);\n    }\n    this._cache?.artifactNameToArtifactPathCache.set(name, result);\n    return result;\n  }\n  _createBuildInfo(id, solcVersion, solcLongVersion, input, output) {\n    return {\n      id,\n      _format: constants_1.BUILD_INFO_FORMAT_VERSION,\n      solcVersion,\n      solcLongVersion,\n      input,\n      output\n    };\n  }\n  _createDebugFile(artifactPath, pathToBuildInfo) {\n    const relativePathToBuildInfo = path.relative(path.dirname(artifactPath), pathToBuildInfo);\n    const debugFile = {\n      _format: constants_1.DEBUG_FILE_FORMAT_VERSION,\n      buildInfo: relativePathToBuildInfo\n    };\n    return debugFile;\n  }\n  _getArtifactPathsSync() {\n    const cached = this._cache?.artifactPaths;\n    if (cached !== undefined) {\n      return cached;\n    }\n    const buildInfosDir = path.join(this._artifactsPath, constants_1.BUILD_INFO_DIR_NAME);\n    const paths = (0, fs_utils_1.getAllFilesMatchingSync)(this._artifactsPath, f => f.endsWith(\".json\") && !f.startsWith(buildInfosDir) && !f.endsWith(\".dbg.json\"));\n    const result = paths.sort();\n    if (this._cache !== undefined) {\n      this._cache.artifactPaths = result;\n    }\n    return result;\n  }\n  /**\n   * Sync version of _getArtifactPath\n   */\n  _getArtifactPathSync(name) {\n    const cached = this._cache?.artifactNameToArtifactPathCache.get(name);\n    if (cached !== undefined) {\n      return cached;\n    }\n    let result;\n    if ((0, contract_names_1.isFullyQualifiedName)(name)) {\n      result = this._getValidArtifactPathFromFullyQualifiedNameSync(name);\n    } else {\n      const files = this._getArtifactPathsSync();\n      result = this._getArtifactPathFromFiles(name, files);\n    }\n    this._cache?.artifactNameToArtifactPathCache.set(name, result);\n    return result;\n  }\n  /**\n   * DO NOT DELETE OR CHANGE\n   *\n   * use this.formArtifactPathFromFullyQualifiedName instead\n   * @deprecated until typechain migrates to public version\n   * @see https://github.com/dethcrypto/TypeChain/issues/544\n   */\n  _getArtifactPathFromFullyQualifiedName(fullyQualifiedName) {\n    const {\n      sourceName,\n      contractName\n    } = (0, contract_names_1.parseFullyQualifiedName)(fullyQualifiedName);\n    return path.join(this._artifactsPath, sourceName, `${contractName}.json`);\n  }\n  /**\n   * Returns the absolute path to the artifact that corresponds to the given\n   * fully qualified name.\n   * @param fullyQualifiedName The fully qualified name of the contract.\n   * @returns The absolute path to the artifact.\n   * @throws {HardhatError} with descriptor:\n   * - {@link ERRORS.CONTRACT_NAMES.INVALID_FULLY_QUALIFIED_NAME} If the name is not fully qualified.\n   * - {@link ERRORS.ARTIFACTS.WRONG_CASING} If the path case doesn't match the one in the filesystem.\n   * - {@link ERRORS.ARTIFACTS.NOT_FOUND} If the artifact is not found.\n   */\n  async _getValidArtifactPathFromFullyQualifiedName(fullyQualifiedName) {\n    const artifactPath = this.formArtifactPathFromFullyQualifiedName(fullyQualifiedName);\n    try {\n      const trueCasePath = path.join(this._artifactsPath, await (0, fs_utils_1.getFileTrueCase)(this._artifactsPath, path.relative(this._artifactsPath, artifactPath)));\n      if (artifactPath !== trueCasePath) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.ARTIFACTS.WRONG_CASING, {\n          correct: this._getFullyQualifiedNameFromPath(trueCasePath),\n          incorrect: fullyQualifiedName\n        });\n      }\n      return trueCasePath;\n    } catch (e) {\n      if (e instanceof fs_utils_1.FileNotFoundError) {\n        return this._handleWrongArtifactForFullyQualifiedName(fullyQualifiedName);\n      }\n      // eslint-disable-next-line @nomicfoundation/hardhat-internal-rules/only-hardhat-error\n      throw e;\n    }\n  }\n  _getAllContractNamesFromFiles(files) {\n    return files.map(file => {\n      const fqn = this._getFullyQualifiedNameFromPath(file);\n      return (0, contract_names_1.parseFullyQualifiedName)(fqn).contractName;\n    });\n  }\n  _getAllFullyQualifiedNamesSync() {\n    const paths = this._getArtifactPathsSync();\n    return paths.map(p => this._getFullyQualifiedNameFromPath(p)).sort();\n  }\n  _formatSuggestions(names, contractName) {\n    switch (names.length) {\n      case 0:\n        return \"\";\n      case 1:\n        return `Did you mean \"${names[0]}\"?`;\n      default:\n        return `We found some that were similar:\n\n${names.map(n => `  * ${n}`).join(os.EOL)}\n\nPlease replace \"${contractName}\" for the correct contract name wherever you are trying to read its artifact.\n`;\n    }\n  }\n  /**\n   * @throws {HardhatError} with a list of similar contract names.\n   */\n  _handleWrongArtifactForFullyQualifiedName(fullyQualifiedName) {\n    const names = this._getAllFullyQualifiedNamesSync();\n    const similarNames = this._getSimilarContractNames(fullyQualifiedName, names);\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.ARTIFACTS.NOT_FOUND, {\n      contractName: fullyQualifiedName,\n      suggestion: this._formatSuggestions(similarNames, fullyQualifiedName)\n    });\n  }\n  /**\n   * @throws {HardhatError} with a list of similar contract names.\n   */\n  _handleWrongArtifactForContractName(contractName, files) {\n    const names = this._getAllContractNamesFromFiles(files);\n    let similarNames = this._getSimilarContractNames(contractName, names);\n    if (similarNames.length > 1) {\n      similarNames = this._filterDuplicatesAsFullyQualifiedNames(files, similarNames);\n    }\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.ARTIFACTS.NOT_FOUND, {\n      contractName,\n      suggestion: this._formatSuggestions(similarNames, contractName)\n    });\n  }\n  /**\n   * If the project has these contracts:\n   *   - 'contracts/Greeter.sol:Greeter'\n   *   - 'contracts/Meeter.sol:Greeter'\n   *   - 'contracts/Greater.sol:Greater'\n   *  And the user tries to get an artifact with the name 'Greter', then\n   *  the suggestions will be 'Greeter', 'Greeter', and 'Greater'.\n   *\n   * We don't want to show duplicates here, so we use FQNs for those. The\n   * suggestions will then be:\n   *   - 'contracts/Greeter.sol:Greeter'\n   *   - 'contracts/Meeter.sol:Greeter'\n   *   - 'Greater'\n   */\n  _filterDuplicatesAsFullyQualifiedNames(files, similarNames) {\n    const outputNames = [];\n    const groups = similarNames.reduce((obj, cur) => {\n      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n      obj[cur] = obj[cur] ? obj[cur] + 1 : 1;\n      return obj;\n    }, {});\n    for (const [name, occurrences] of Object.entries(groups)) {\n      if (occurrences > 1) {\n        for (const file of files) {\n          if (path.basename(file) === `${name}.json`) {\n            outputNames.push(this._getFullyQualifiedNameFromPath(file));\n          }\n        }\n        continue;\n      }\n      outputNames.push(name);\n    }\n    return outputNames;\n  }\n  /**\n   *\n   * @param givenName can be FQN or contract name\n   * @param names MUST match type of givenName (i.e. array of FQN's if givenName is FQN)\n   * @returns\n   */\n  _getSimilarContractNames(givenName, names) {\n    let shortestDistance = constants_1.EDIT_DISTANCE_THRESHOLD;\n    let mostSimilarNames = [];\n    for (const name of names) {\n      const distance = (0, contract_names_1.findDistance)(givenName, name);\n      if (distance < shortestDistance) {\n        shortestDistance = distance;\n        mostSimilarNames = [name];\n        continue;\n      }\n      if (distance === shortestDistance) {\n        mostSimilarNames.push(name);\n        continue;\n      }\n    }\n    return mostSimilarNames;\n  }\n  _getValidArtifactPathFromFullyQualifiedNameSync(fullyQualifiedName) {\n    const artifactPath = this.formArtifactPathFromFullyQualifiedName(fullyQualifiedName);\n    try {\n      const trueCasePath = path.join(this._artifactsPath, (0, fs_utils_1.getFileTrueCaseSync)(this._artifactsPath, path.relative(this._artifactsPath, artifactPath)));\n      if (artifactPath !== trueCasePath) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.ARTIFACTS.WRONG_CASING, {\n          correct: this._getFullyQualifiedNameFromPath(trueCasePath),\n          incorrect: fullyQualifiedName\n        });\n      }\n      return trueCasePath;\n    } catch (e) {\n      if (e instanceof fs_utils_1.FileNotFoundError) {\n        return this._handleWrongArtifactForFullyQualifiedName(fullyQualifiedName);\n      }\n      // eslint-disable-next-line @nomicfoundation/hardhat-internal-rules/only-hardhat-error\n      throw e;\n    }\n  }\n  _getDebugFilePath(artifactPath) {\n    return artifactPath.replace(/\\.json$/, \".dbg.json\");\n  }\n  /**\n   * Gets the path to the artifact file for the given contract name.\n   * @throws {HardhatError} with descriptor:\n   * - {@link ERRORS.ARTIFACTS.NOT_FOUND} if there are no artifacts matching the given contract name.\n   * - {@link ERRORS.ARTIFACTS.MULTIPLE_FOUND} if there are multiple artifacts matching the given contract name.\n   */\n  _getArtifactPathFromFiles(contractName, files) {\n    const matchingFiles = files.filter(file => {\n      return path.basename(file) === `${contractName}.json`;\n    });\n    if (matchingFiles.length === 0) {\n      return this._handleWrongArtifactForContractName(contractName, files);\n    }\n    if (matchingFiles.length > 1) {\n      const candidates = matchingFiles.map(file => this._getFullyQualifiedNameFromPath(file));\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARTIFACTS.MULTIPLE_FOUND, {\n        contractName,\n        candidates: candidates.join(os.EOL)\n      });\n    }\n    return matchingFiles[0];\n  }\n  /**\n   * Returns the FQN of a contract giving the absolute path to its artifact.\n   *\n   * For example, given a path like\n   * `/path/to/project/artifacts/contracts/Foo.sol/Bar.json`, it'll return the\n   * FQN `contracts/Foo.sol:Bar`\n   */\n  _getFullyQualifiedNameFromPath(absolutePath) {\n    const sourceName = (0, source_names_1.replaceBackslashes)(path.relative(this._artifactsPath, path.dirname(absolutePath)));\n    const contractName = path.basename(absolutePath).replace(\".json\", \"\");\n    return (0, contract_names_1.getFullyQualifiedName)(sourceName, contractName);\n  }\n  /**\n   * Remove the artifact file and its debug file.\n   */\n  async _removeArtifactFiles(artifactPath) {\n    await fs_extra_1.default.remove(artifactPath);\n    const debugFilePath = this._getDebugFilePath(artifactPath);\n    await fs_extra_1.default.remove(debugFilePath);\n  }\n  /**\n   * Given the path to a debug file, returns the absolute path to its\n   * corresponding build info file if it exists, or undefined otherwise.\n   */\n  async _getBuildInfoFromDebugFile(debugFilePath) {\n    if (await fs_extra_1.default.pathExists(debugFilePath)) {\n      const {\n        buildInfo\n      } = await fs_extra_1.default.readJson(debugFilePath);\n      return path.resolve(path.dirname(debugFilePath), buildInfo);\n    }\n    return undefined;\n  }\n  /**\n   * Sync version of _getBuildInfoFromDebugFile\n   */\n  _getBuildInfoFromDebugFileSync(debugFilePath) {\n    if (fs_extra_1.default.pathExistsSync(debugFilePath)) {\n      const {\n        buildInfo\n      } = fs_extra_1.default.readJsonSync(debugFilePath);\n      return path.resolve(path.dirname(debugFilePath), buildInfo);\n    }\n    return undefined;\n  }\n}\nexports.Artifacts = Artifacts;\n/**\n * Retrieves an artifact for the given `contractName` from the compilation output.\n *\n * @param sourceName The contract's source name.\n * @param contractName the contract's name.\n * @param contractOutput the contract's compilation output as emitted by `solc`.\n */\nfunction getArtifactFromContractOutput(sourceName, contractName, contractOutput) {\n  const evmBytecode = contractOutput.evm?.bytecode;\n  let bytecode = evmBytecode?.object ?? \"\";\n  if (bytecode.slice(0, 2).toLowerCase() !== \"0x\") {\n    bytecode = `0x${bytecode}`;\n  }\n  const evmDeployedBytecode = contractOutput.evm?.deployedBytecode;\n  let deployedBytecode = evmDeployedBytecode?.object ?? \"\";\n  if (deployedBytecode.slice(0, 2).toLowerCase() !== \"0x\") {\n    deployedBytecode = `0x${deployedBytecode}`;\n  }\n  const linkReferences = evmBytecode?.linkReferences ?? {};\n  const deployedLinkReferences = evmDeployedBytecode?.linkReferences ?? {};\n  return {\n    _format: constants_1.ARTIFACT_FORMAT_VERSION,\n    contractName,\n    sourceName,\n    abi: contractOutput.abi,\n    bytecode,\n    deployedBytecode,\n    linkReferences,\n    deployedLinkReferences\n  };\n}\nexports.getArtifactFromContractOutput = getArtifactFromContractOutput;","map":{"version":3,"names":["debug_1","__importDefault","require","fs_extra_1","os","__importStar","path","promises_1","contract_names_1","source_names_1","constants_1","errors_1","errors_list_1","hash_1","fs_utils_1","log","default","Artifacts","constructor","_artifactsPath","_cache","artifactNameToArtifactPathCache","Map","artifactFQNToBuildInfoPathCache","_validArtifacts","addValidArtifacts","validArtifacts","push","readArtifact","name","artifactPath","_getArtifactPath","readJson","readArtifactSync","_getArtifactPathSync","readJsonSync","artifactExists","e","HardhatError","isHardhatError","pathExists","getAllFullyQualifiedNames","paths","getArtifactPaths","map","p","_getFullyQualifiedNameFromPath","sort","getBuildInfo","fullyQualifiedName","buildInfoPath","get","undefined","formArtifactPathFromFullyQualifiedName","debugFilePath","_getDebugFilePath","_getBuildInfoFromDebugFile","set","readJSON","getBuildInfoSync","_getBuildInfoFromDebugFileSync","readJSONSync","cached","artifactPaths","buildInfosDir","join","BUILD_INFO_DIR_NAME","getAllFilesMatching","f","endsWith","startsWith","result","getBuildInfoPaths","buildInfoPaths","getDebugFilePaths","debugFilePaths","saveArtifactAndDebugFile","artifact","pathToBuildInfo","getFullyQualifiedName","sourceName","contractName","ensureDir","dirname","Promise","all","writeJSON","spaces","debugFile","_createDebugFile","clearCache","saveBuildInfo","solcVersion","solcLongVersion","input","output","buildInfoDir","buildInfoName","_getBuildInfoName","buildInfo","_createBuildInfo","file","open","withoutOutput","JSON","stringify","write","slice","outputWithoutSourcesAndContracts","sources","contracts","length","isFirst","value","Object","entries","close","removeObsoleteArtifacts","validArtifactPaths","flatMap","artifacts","artifactName","validArtifactsPathsSet","Set","add","existingArtifactsPaths","filter","has","_removeArtifactFiles","_removeObsoleteBuildInfos","parseFullyQualifiedName","disableCache","debugFiles","buildInfos","buildInfoFile","resolve","filteredBuildInfos","bf","validBuildInfos","buildInfoFiles","unlink","json","_format","BUILD_INFO_FORMAT_VERSION","createNonCryptographicHashBasedIdentifier","Buffer","from","toString","isFullyQualifiedName","_getValidArtifactPathFromFullyQualifiedName","files","_getArtifactPathFromFiles","id","relativePathToBuildInfo","relative","DEBUG_FILE_FORMAT_VERSION","_getArtifactPathsSync","getAllFilesMatchingSync","_getValidArtifactPathFromFullyQualifiedNameSync","_getArtifactPathFromFullyQualifiedName","trueCasePath","getFileTrueCase","ERRORS","ARTIFACTS","WRONG_CASING","correct","incorrect","FileNotFoundError","_handleWrongArtifactForFullyQualifiedName","_getAllContractNamesFromFiles","fqn","_getAllFullyQualifiedNamesSync","_formatSuggestions","names","n","EOL","similarNames","_getSimilarContractNames","NOT_FOUND","suggestion","_handleWrongArtifactForContractName","_filterDuplicatesAsFullyQualifiedNames","outputNames","groups","reduce","obj","cur","occurrences","basename","givenName","shortestDistance","EDIT_DISTANCE_THRESHOLD","mostSimilarNames","distance","findDistance","getFileTrueCaseSync","replace","matchingFiles","candidates","MULTIPLE_FOUND","absolutePath","replaceBackslashes","remove","pathExistsSync","exports","getArtifactFromContractOutput","contractOutput","evmBytecode","evm","bytecode","object","toLowerCase","evmDeployedBytecode","deployedBytecode","linkReferences","deployedLinkReferences","ARTIFACT_FORMAT_VERSION","abi"],"sources":["/Users/mukuljindal/Local/projects/voting/node_modules/hardhat/src/internal/artifacts.ts"],"sourcesContent":["import debug from \"debug\";\nimport fsExtra from \"fs-extra\";\nimport * as os from \"os\";\nimport * as path from \"path\";\nimport fsPromises from \"fs/promises\";\n\nimport {\n  Artifact,\n  Artifacts as IArtifacts,\n  BuildInfo,\n  CompilerInput,\n  CompilerOutput,\n  DebugFile,\n} from \"../types\";\nimport {\n  getFullyQualifiedName,\n  isFullyQualifiedName,\n  parseFullyQualifiedName,\n  findDistance,\n} from \"../utils/contract-names\";\nimport { replaceBackslashes } from \"../utils/source-names\";\n\nimport {\n  ARTIFACT_FORMAT_VERSION,\n  BUILD_INFO_DIR_NAME,\n  BUILD_INFO_FORMAT_VERSION,\n  DEBUG_FILE_FORMAT_VERSION,\n  EDIT_DISTANCE_THRESHOLD,\n} from \"./constants\";\nimport { HardhatError } from \"./core/errors\";\nimport { ERRORS } from \"./core/errors-list\";\nimport { createNonCryptographicHashBasedIdentifier } from \"./util/hash\";\nimport {\n  FileNotFoundError,\n  getAllFilesMatching,\n  getAllFilesMatchingSync,\n  getFileTrueCase,\n  getFileTrueCaseSync,\n} from \"./util/fs-utils\";\n\nconst log = debug(\"hardhat:core:artifacts\");\n\ninterface Cache {\n  artifactPaths?: string[];\n  debugFilePaths?: string[];\n  buildInfoPaths?: string[];\n  artifactNameToArtifactPathCache: Map<string, string>;\n  artifactFQNToBuildInfoPathCache: Map<string, string>;\n}\n\nexport class Artifacts implements IArtifacts {\n  private _validArtifacts: Array<{ sourceName: string; artifacts: string[] }>;\n\n  // Undefined means that the cache is disabled.\n  private _cache?: Cache = {\n    artifactNameToArtifactPathCache: new Map(),\n    artifactFQNToBuildInfoPathCache: new Map(),\n  };\n\n  constructor(private _artifactsPath: string) {\n    this._validArtifacts = [];\n  }\n\n  public addValidArtifacts(\n    validArtifacts: Array<{ sourceName: string; artifacts: string[] }>\n  ) {\n    this._validArtifacts.push(...validArtifacts);\n  }\n\n  public async readArtifact(name: string): Promise<Artifact> {\n    const artifactPath = await this._getArtifactPath(name);\n    return fsExtra.readJson(artifactPath);\n  }\n\n  public readArtifactSync(name: string): Artifact {\n    const artifactPath = this._getArtifactPathSync(name);\n    return fsExtra.readJsonSync(artifactPath);\n  }\n\n  public async artifactExists(name: string): Promise<boolean> {\n    let artifactPath;\n    try {\n      artifactPath = await this._getArtifactPath(name);\n    } catch (e) {\n      if (HardhatError.isHardhatError(e)) {\n        return false;\n      }\n\n      // eslint-disable-next-line @nomicfoundation/hardhat-internal-rules/only-hardhat-error\n      throw e;\n    }\n\n    return fsExtra.pathExists(artifactPath);\n  }\n\n  public async getAllFullyQualifiedNames(): Promise<string[]> {\n    const paths = await this.getArtifactPaths();\n    return paths.map((p) => this._getFullyQualifiedNameFromPath(p)).sort();\n  }\n\n  public async getBuildInfo(\n    fullyQualifiedName: string\n  ): Promise<BuildInfo | undefined> {\n    let buildInfoPath =\n      this._cache?.artifactFQNToBuildInfoPathCache.get(fullyQualifiedName);\n\n    if (buildInfoPath === undefined) {\n      const artifactPath =\n        this.formArtifactPathFromFullyQualifiedName(fullyQualifiedName);\n\n      const debugFilePath = this._getDebugFilePath(artifactPath);\n      buildInfoPath = await this._getBuildInfoFromDebugFile(debugFilePath);\n\n      if (buildInfoPath === undefined) {\n        return undefined;\n      }\n\n      this._cache?.artifactFQNToBuildInfoPathCache.set(\n        fullyQualifiedName,\n        buildInfoPath\n      );\n    }\n\n    return fsExtra.readJSON(buildInfoPath);\n  }\n\n  public getBuildInfoSync(fullyQualifiedName: string): BuildInfo | undefined {\n    let buildInfoPath =\n      this._cache?.artifactFQNToBuildInfoPathCache.get(fullyQualifiedName);\n\n    if (buildInfoPath === undefined) {\n      const artifactPath =\n        this.formArtifactPathFromFullyQualifiedName(fullyQualifiedName);\n\n      const debugFilePath = this._getDebugFilePath(artifactPath);\n      buildInfoPath = this._getBuildInfoFromDebugFileSync(debugFilePath);\n\n      if (buildInfoPath === undefined) {\n        return undefined;\n      }\n\n      this._cache?.artifactFQNToBuildInfoPathCache.set(\n        fullyQualifiedName,\n        buildInfoPath\n      );\n    }\n\n    return fsExtra.readJSONSync(buildInfoPath);\n  }\n\n  public async getArtifactPaths(): Promise<string[]> {\n    const cached = this._cache?.artifactPaths;\n    if (cached !== undefined) {\n      return cached;\n    }\n\n    const buildInfosDir = path.join(this._artifactsPath, BUILD_INFO_DIR_NAME);\n\n    const paths = await getAllFilesMatching(\n      this._artifactsPath,\n      (f) =>\n        f.endsWith(\".json\") &&\n        !f.startsWith(buildInfosDir) &&\n        !f.endsWith(\".dbg.json\")\n    );\n\n    const result = paths.sort();\n\n    if (this._cache !== undefined) {\n      this._cache.artifactPaths = result;\n    }\n\n    return result;\n  }\n\n  public async getBuildInfoPaths(): Promise<string[]> {\n    const cached = this._cache?.buildInfoPaths;\n    if (cached !== undefined) {\n      return cached;\n    }\n\n    const paths = await getAllFilesMatching(\n      path.join(this._artifactsPath, BUILD_INFO_DIR_NAME),\n      (f) => f.endsWith(\".json\")\n    );\n\n    const result = paths.sort();\n\n    if (this._cache !== undefined) {\n      this._cache.buildInfoPaths = result;\n    }\n\n    return result;\n  }\n\n  public async getDebugFilePaths(): Promise<string[]> {\n    const cached = this._cache?.debugFilePaths;\n    if (cached !== undefined) {\n      return cached;\n    }\n\n    const paths = await getAllFilesMatching(\n      path.join(this._artifactsPath),\n      (f) => f.endsWith(\".dbg.json\")\n    );\n\n    const result = paths.sort();\n\n    if (this._cache !== undefined) {\n      this._cache.debugFilePaths = result;\n    }\n\n    return result;\n  }\n\n  public async saveArtifactAndDebugFile(\n    artifact: Artifact,\n    pathToBuildInfo?: string\n  ) {\n    try {\n      // artifact\n      const fullyQualifiedName = getFullyQualifiedName(\n        artifact.sourceName,\n        artifact.contractName\n      );\n\n      const artifactPath =\n        this.formArtifactPathFromFullyQualifiedName(fullyQualifiedName);\n\n      await fsExtra.ensureDir(path.dirname(artifactPath));\n\n      await Promise.all([\n        fsExtra.writeJSON(artifactPath, artifact, {\n          spaces: 2,\n        }),\n        (async () => {\n          if (pathToBuildInfo === undefined) {\n            return;\n          }\n\n          // save debug file\n          const debugFilePath = this._getDebugFilePath(artifactPath);\n          const debugFile = this._createDebugFile(\n            artifactPath,\n            pathToBuildInfo\n          );\n\n          await fsExtra.writeJSON(debugFilePath, debugFile, {\n            spaces: 2,\n          });\n        })(),\n      ]);\n    } finally {\n      this.clearCache();\n    }\n  }\n\n  public async saveBuildInfo(\n    solcVersion: string,\n    solcLongVersion: string,\n    input: CompilerInput,\n    output: CompilerOutput\n  ): Promise<string> {\n    try {\n      const buildInfoDir = path.join(this._artifactsPath, BUILD_INFO_DIR_NAME);\n      await fsExtra.ensureDir(buildInfoDir);\n\n      const buildInfoName = this._getBuildInfoName(\n        solcVersion,\n        solcLongVersion,\n        input\n      );\n\n      const buildInfo = this._createBuildInfo(\n        buildInfoName,\n        solcVersion,\n        solcLongVersion,\n        input,\n        output\n      );\n\n      const buildInfoPath = path.join(buildInfoDir, `${buildInfoName}.json`);\n\n      // JSON.stringify of the entire build info can be really slow\n      // in larger projects, so we stringify per part and incrementally create\n      // the JSON in the file.\n      //\n      // We split this code into different curly-brace-enclosed scopes so that\n      // partial JSON strings get out of scope sooner and hence can be reclaimed\n      // by the GC if needed.\n      const file = await fsPromises.open(buildInfoPath, \"w\");\n      try {\n        {\n          const withoutOutput = JSON.stringify({\n            ...buildInfo,\n            output: undefined,\n          });\n\n          // We write the JSON (without output) except the last }\n          await file.write(withoutOutput.slice(0, -1));\n        }\n\n        {\n          const outputWithoutSourcesAndContracts = JSON.stringify({\n            ...buildInfo.output,\n            sources: undefined,\n            contracts: undefined,\n          });\n\n          // We start writing the output\n          await file.write(',\"output\":');\n\n          // Write the output object except for the last }\n          await file.write(outputWithoutSourcesAndContracts.slice(0, -1));\n\n          // If there were other field apart from sources and contracts we need\n          // a comma\n          if (outputWithoutSourcesAndContracts.length > 2) {\n            await file.write(\",\");\n          }\n        }\n\n        // Writing the sources\n        await file.write('\"sources\":{');\n\n        let isFirst = true;\n        for (const [name, value] of Object.entries(\n          buildInfo.output.sources ?? {}\n        )) {\n          if (isFirst) {\n            isFirst = false;\n          } else {\n            await file.write(\",\");\n          }\n\n          await file.write(`${JSON.stringify(name)}:${JSON.stringify(value)}`);\n        }\n\n        // Close sources object\n        await file.write(\"}\");\n\n        // Writing the contracts\n        await file.write(',\"contracts\":{');\n\n        isFirst = true;\n        for (const [name, value] of Object.entries(\n          buildInfo.output.contracts ?? {}\n        )) {\n          if (isFirst) {\n            isFirst = false;\n          } else {\n            await file.write(\",\");\n          }\n\n          await file.write(`${JSON.stringify(name)}:${JSON.stringify(value)}`);\n        }\n\n        // close contracts object\n        await file.write(\"}\");\n        // close output object\n        await file.write(\"}\");\n        // close build info object\n        await file.write(\"}\");\n      } finally {\n        await file.close();\n      }\n\n      return buildInfoPath;\n    } finally {\n      this.clearCache();\n    }\n  }\n\n  /**\n   * Remove all artifacts that don't correspond to the current solidity files\n   */\n  public async removeObsoleteArtifacts() {\n    // We clear the cache here, as we want to be sure this runs correctly\n    this.clearCache();\n\n    try {\n      const validArtifactPaths = await Promise.all(\n        this._validArtifacts.flatMap(({ sourceName, artifacts }) =>\n          artifacts.map((artifactName) =>\n            this._getArtifactPath(\n              getFullyQualifiedName(sourceName, artifactName)\n            )\n          )\n        )\n      );\n\n      const validArtifactsPathsSet = new Set<string>(validArtifactPaths);\n\n      for (const { sourceName, artifacts } of this._validArtifacts) {\n        for (const artifactName of artifacts) {\n          validArtifactsPathsSet.add(\n            this.formArtifactPathFromFullyQualifiedName(\n              getFullyQualifiedName(sourceName, artifactName)\n            )\n          );\n        }\n      }\n\n      const existingArtifactsPaths = await this.getArtifactPaths();\n\n      await Promise.all(\n        existingArtifactsPaths\n          .filter((artifactPath) => !validArtifactsPathsSet.has(artifactPath))\n          .map((artifactPath) => this._removeArtifactFiles(artifactPath))\n      );\n\n      await this._removeObsoleteBuildInfos();\n    } finally {\n      // We clear the cache here, as this may have non-existent paths now\n      this.clearCache();\n    }\n  }\n\n  /**\n   * Returns the absolute path to the given artifact\n   * @throws {HardhatError} If the name is not fully qualified.\n   */\n  public formArtifactPathFromFullyQualifiedName(\n    fullyQualifiedName: string\n  ): string {\n    const { sourceName, contractName } =\n      parseFullyQualifiedName(fullyQualifiedName);\n\n    return path.join(this._artifactsPath, sourceName, `${contractName}.json`);\n  }\n\n  public clearCache() {\n    // Avoid accidentally re-enabling the cache\n    if (this._cache === undefined) {\n      return;\n    }\n\n    this._cache = {\n      artifactFQNToBuildInfoPathCache: new Map(),\n      artifactNameToArtifactPathCache: new Map(),\n    };\n  }\n\n  public disableCache() {\n    this._cache = undefined;\n  }\n\n  /**\n   * Remove all build infos that aren't used by any debug file\n   */\n  private async _removeObsoleteBuildInfos() {\n    const debugFiles = await this.getDebugFilePaths();\n\n    const buildInfos = await Promise.all(\n      debugFiles.map(async (debugFile) => {\n        const buildInfoFile = await this._getBuildInfoFromDebugFile(debugFile);\n        if (buildInfoFile !== undefined) {\n          return path.resolve(path.dirname(debugFile), buildInfoFile);\n        }\n      })\n    );\n\n    const filteredBuildInfos: string[] = buildInfos.filter(\n      (bf): bf is string => typeof bf === \"string\"\n    );\n\n    const validBuildInfos = new Set<string>(filteredBuildInfos);\n\n    const buildInfoFiles = await this.getBuildInfoPaths();\n\n    await Promise.all(\n      buildInfoFiles\n        .filter((buildInfoFile) => !validBuildInfos.has(buildInfoFile))\n        .map(async (buildInfoFile) => {\n          log(`Removing buildInfo '${buildInfoFile}'`);\n          await fsExtra.unlink(buildInfoFile);\n        })\n    );\n  }\n\n  private _getBuildInfoName(\n    solcVersion: string,\n    solcLongVersion: string,\n    input: CompilerInput\n  ): string {\n    const json = JSON.stringify({\n      _format: BUILD_INFO_FORMAT_VERSION,\n      solcVersion,\n      solcLongVersion,\n      input,\n    });\n\n    return createNonCryptographicHashBasedIdentifier(\n      Buffer.from(json)\n    ).toString(\"hex\");\n  }\n\n  /**\n   * Returns the absolute path to the artifact that corresponds to the given\n   * name.\n   *\n   * If the name is fully qualified, the path is computed from it.  If not, an\n   * artifact that matches the given name is searched in the existing artifacts.\n   * If there is an ambiguity, an error is thrown.\n   *\n   * @throws {HardhatError} with descriptor:\n   * - {@link ERRORS.ARTIFACTS.WRONG_CASING} if the path case doesn't match the one in the filesystem.\n   * - {@link ERRORS.ARTIFACTS.MULTIPLE_FOUND} if there are multiple artifacts matching the given contract name.\n   * - {@link ERRORS.ARTIFACTS.NOT_FOUND} if the artifact is not found.\n   */\n  private async _getArtifactPath(name: string): Promise<string> {\n    const cached = this._cache?.artifactNameToArtifactPathCache.get(name);\n    if (cached !== undefined) {\n      return cached;\n    }\n\n    let result: string;\n    if (isFullyQualifiedName(name)) {\n      result = await this._getValidArtifactPathFromFullyQualifiedName(name);\n    } else {\n      const files = await this.getArtifactPaths();\n      result = this._getArtifactPathFromFiles(name, files);\n    }\n\n    this._cache?.artifactNameToArtifactPathCache.set(name, result);\n    return result;\n  }\n\n  private _createBuildInfo(\n    id: string,\n    solcVersion: string,\n    solcLongVersion: string,\n    input: CompilerInput,\n    output: CompilerOutput\n  ): BuildInfo {\n    return {\n      id,\n      _format: BUILD_INFO_FORMAT_VERSION,\n      solcVersion,\n      solcLongVersion,\n      input,\n      output,\n    };\n  }\n\n  private _createDebugFile(artifactPath: string, pathToBuildInfo: string) {\n    const relativePathToBuildInfo = path.relative(\n      path.dirname(artifactPath),\n      pathToBuildInfo\n    );\n\n    const debugFile: DebugFile = {\n      _format: DEBUG_FILE_FORMAT_VERSION,\n      buildInfo: relativePathToBuildInfo,\n    };\n\n    return debugFile;\n  }\n\n  private _getArtifactPathsSync(): string[] {\n    const cached = this._cache?.artifactPaths;\n    if (cached !== undefined) {\n      return cached;\n    }\n\n    const buildInfosDir = path.join(this._artifactsPath, BUILD_INFO_DIR_NAME);\n\n    const paths = getAllFilesMatchingSync(\n      this._artifactsPath,\n      (f) =>\n        f.endsWith(\".json\") &&\n        !f.startsWith(buildInfosDir) &&\n        !f.endsWith(\".dbg.json\")\n    );\n\n    const result = paths.sort();\n\n    if (this._cache !== undefined) {\n      this._cache.artifactPaths = result;\n    }\n\n    return result;\n  }\n\n  /**\n   * Sync version of _getArtifactPath\n   */\n  private _getArtifactPathSync(name: string): string {\n    const cached = this._cache?.artifactNameToArtifactPathCache.get(name);\n    if (cached !== undefined) {\n      return cached;\n    }\n\n    let result: string;\n\n    if (isFullyQualifiedName(name)) {\n      result = this._getValidArtifactPathFromFullyQualifiedNameSync(name);\n    } else {\n      const files = this._getArtifactPathsSync();\n      result = this._getArtifactPathFromFiles(name, files);\n    }\n\n    this._cache?.artifactNameToArtifactPathCache.set(name, result);\n    return result;\n  }\n\n  /**\n   * DO NOT DELETE OR CHANGE\n   *\n   * use this.formArtifactPathFromFullyQualifiedName instead\n   * @deprecated until typechain migrates to public version\n   * @see https://github.com/dethcrypto/TypeChain/issues/544\n   */\n  private _getArtifactPathFromFullyQualifiedName(\n    fullyQualifiedName: string\n  ): string {\n    const { sourceName, contractName } =\n      parseFullyQualifiedName(fullyQualifiedName);\n\n    return path.join(this._artifactsPath, sourceName, `${contractName}.json`);\n  }\n\n  /**\n   * Returns the absolute path to the artifact that corresponds to the given\n   * fully qualified name.\n   * @param fullyQualifiedName The fully qualified name of the contract.\n   * @returns The absolute path to the artifact.\n   * @throws {HardhatError} with descriptor:\n   * - {@link ERRORS.CONTRACT_NAMES.INVALID_FULLY_QUALIFIED_NAME} If the name is not fully qualified.\n   * - {@link ERRORS.ARTIFACTS.WRONG_CASING} If the path case doesn't match the one in the filesystem.\n   * - {@link ERRORS.ARTIFACTS.NOT_FOUND} If the artifact is not found.\n   */\n  private async _getValidArtifactPathFromFullyQualifiedName(\n    fullyQualifiedName: string\n  ): Promise<string> {\n    const artifactPath =\n      this.formArtifactPathFromFullyQualifiedName(fullyQualifiedName);\n\n    try {\n      const trueCasePath = path.join(\n        this._artifactsPath,\n        await getFileTrueCase(\n          this._artifactsPath,\n          path.relative(this._artifactsPath, artifactPath)\n        )\n      );\n\n      if (artifactPath !== trueCasePath) {\n        throw new HardhatError(ERRORS.ARTIFACTS.WRONG_CASING, {\n          correct: this._getFullyQualifiedNameFromPath(trueCasePath),\n          incorrect: fullyQualifiedName,\n        });\n      }\n\n      return trueCasePath;\n    } catch (e) {\n      if (e instanceof FileNotFoundError) {\n        return this._handleWrongArtifactForFullyQualifiedName(\n          fullyQualifiedName\n        );\n      }\n\n      // eslint-disable-next-line @nomicfoundation/hardhat-internal-rules/only-hardhat-error\n      throw e;\n    }\n  }\n\n  private _getAllContractNamesFromFiles(files: string[]): string[] {\n    return files.map((file) => {\n      const fqn = this._getFullyQualifiedNameFromPath(file);\n      return parseFullyQualifiedName(fqn).contractName;\n    });\n  }\n\n  private _getAllFullyQualifiedNamesSync(): string[] {\n    const paths = this._getArtifactPathsSync();\n    return paths.map((p) => this._getFullyQualifiedNameFromPath(p)).sort();\n  }\n\n  private _formatSuggestions(names: string[], contractName: string): string {\n    switch (names.length) {\n      case 0:\n        return \"\";\n      case 1:\n        return `Did you mean \"${names[0]}\"?`;\n      default:\n        return `We found some that were similar:\n\n${names.map((n) => `  * ${n}`).join(os.EOL)}\n\nPlease replace \"${contractName}\" for the correct contract name wherever you are trying to read its artifact.\n`;\n    }\n  }\n\n  /**\n   * @throws {HardhatError} with a list of similar contract names.\n   */\n  private _handleWrongArtifactForFullyQualifiedName(\n    fullyQualifiedName: string\n  ): never {\n    const names = this._getAllFullyQualifiedNamesSync();\n\n    const similarNames = this._getSimilarContractNames(\n      fullyQualifiedName,\n      names\n    );\n\n    throw new HardhatError(ERRORS.ARTIFACTS.NOT_FOUND, {\n      contractName: fullyQualifiedName,\n      suggestion: this._formatSuggestions(similarNames, fullyQualifiedName),\n    });\n  }\n\n  /**\n   * @throws {HardhatError} with a list of similar contract names.\n   */\n  private _handleWrongArtifactForContractName(\n    contractName: string,\n    files: string[]\n  ): never {\n    const names = this._getAllContractNamesFromFiles(files);\n\n    let similarNames = this._getSimilarContractNames(contractName, names);\n\n    if (similarNames.length > 1) {\n      similarNames = this._filterDuplicatesAsFullyQualifiedNames(\n        files,\n        similarNames\n      );\n    }\n\n    throw new HardhatError(ERRORS.ARTIFACTS.NOT_FOUND, {\n      contractName,\n      suggestion: this._formatSuggestions(similarNames, contractName),\n    });\n  }\n\n  /**\n   * If the project has these contracts:\n   *   - 'contracts/Greeter.sol:Greeter'\n   *   - 'contracts/Meeter.sol:Greeter'\n   *   - 'contracts/Greater.sol:Greater'\n   *  And the user tries to get an artifact with the name 'Greter', then\n   *  the suggestions will be 'Greeter', 'Greeter', and 'Greater'.\n   *\n   * We don't want to show duplicates here, so we use FQNs for those. The\n   * suggestions will then be:\n   *   - 'contracts/Greeter.sol:Greeter'\n   *   - 'contracts/Meeter.sol:Greeter'\n   *   - 'Greater'\n   */\n  private _filterDuplicatesAsFullyQualifiedNames(\n    files: string[],\n    similarNames: string[]\n  ): string[] {\n    const outputNames = [];\n    const groups = similarNames.reduce((obj, cur) => {\n      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n      obj[cur] = obj[cur] ? obj[cur] + 1 : 1;\n      return obj;\n    }, {} as { [k: string]: number });\n\n    for (const [name, occurrences] of Object.entries(groups)) {\n      if (occurrences > 1) {\n        for (const file of files) {\n          if (path.basename(file) === `${name}.json`) {\n            outputNames.push(this._getFullyQualifiedNameFromPath(file));\n          }\n        }\n        continue;\n      }\n\n      outputNames.push(name);\n    }\n\n    return outputNames;\n  }\n\n  /**\n   *\n   * @param givenName can be FQN or contract name\n   * @param names MUST match type of givenName (i.e. array of FQN's if givenName is FQN)\n   * @returns\n   */\n  private _getSimilarContractNames(\n    givenName: string,\n    names: string[]\n  ): string[] {\n    let shortestDistance = EDIT_DISTANCE_THRESHOLD;\n    let mostSimilarNames: string[] = [];\n    for (const name of names) {\n      const distance = findDistance(givenName, name);\n\n      if (distance < shortestDistance) {\n        shortestDistance = distance;\n        mostSimilarNames = [name];\n        continue;\n      }\n\n      if (distance === shortestDistance) {\n        mostSimilarNames.push(name);\n        continue;\n      }\n    }\n\n    return mostSimilarNames;\n  }\n\n  private _getValidArtifactPathFromFullyQualifiedNameSync(\n    fullyQualifiedName: string\n  ): string {\n    const artifactPath =\n      this.formArtifactPathFromFullyQualifiedName(fullyQualifiedName);\n\n    try {\n      const trueCasePath = path.join(\n        this._artifactsPath,\n        getFileTrueCaseSync(\n          this._artifactsPath,\n          path.relative(this._artifactsPath, artifactPath)\n        )\n      );\n\n      if (artifactPath !== trueCasePath) {\n        throw new HardhatError(ERRORS.ARTIFACTS.WRONG_CASING, {\n          correct: this._getFullyQualifiedNameFromPath(trueCasePath),\n          incorrect: fullyQualifiedName,\n        });\n      }\n\n      return trueCasePath;\n    } catch (e) {\n      if (e instanceof FileNotFoundError) {\n        return this._handleWrongArtifactForFullyQualifiedName(\n          fullyQualifiedName\n        );\n      }\n\n      // eslint-disable-next-line @nomicfoundation/hardhat-internal-rules/only-hardhat-error\n      throw e;\n    }\n  }\n\n  private _getDebugFilePath(artifactPath: string): string {\n    return artifactPath.replace(/\\.json$/, \".dbg.json\");\n  }\n\n  /**\n   * Gets the path to the artifact file for the given contract name.\n   * @throws {HardhatError} with descriptor:\n   * - {@link ERRORS.ARTIFACTS.NOT_FOUND} if there are no artifacts matching the given contract name.\n   * - {@link ERRORS.ARTIFACTS.MULTIPLE_FOUND} if there are multiple artifacts matching the given contract name.\n   */\n  private _getArtifactPathFromFiles(\n    contractName: string,\n    files: string[]\n  ): string {\n    const matchingFiles = files.filter((file) => {\n      return path.basename(file) === `${contractName}.json`;\n    });\n\n    if (matchingFiles.length === 0) {\n      return this._handleWrongArtifactForContractName(contractName, files);\n    }\n\n    if (matchingFiles.length > 1) {\n      const candidates = matchingFiles.map((file) =>\n        this._getFullyQualifiedNameFromPath(file)\n      );\n\n      throw new HardhatError(ERRORS.ARTIFACTS.MULTIPLE_FOUND, {\n        contractName,\n        candidates: candidates.join(os.EOL),\n      });\n    }\n\n    return matchingFiles[0];\n  }\n\n  /**\n   * Returns the FQN of a contract giving the absolute path to its artifact.\n   *\n   * For example, given a path like\n   * `/path/to/project/artifacts/contracts/Foo.sol/Bar.json`, it'll return the\n   * FQN `contracts/Foo.sol:Bar`\n   */\n  private _getFullyQualifiedNameFromPath(absolutePath: string): string {\n    const sourceName = replaceBackslashes(\n      path.relative(this._artifactsPath, path.dirname(absolutePath))\n    );\n\n    const contractName = path.basename(absolutePath).replace(\".json\", \"\");\n\n    return getFullyQualifiedName(sourceName, contractName);\n  }\n\n  /**\n   * Remove the artifact file and its debug file.\n   */\n  private async _removeArtifactFiles(artifactPath: string) {\n    await fsExtra.remove(artifactPath);\n\n    const debugFilePath = this._getDebugFilePath(artifactPath);\n\n    await fsExtra.remove(debugFilePath);\n  }\n\n  /**\n   * Given the path to a debug file, returns the absolute path to its\n   * corresponding build info file if it exists, or undefined otherwise.\n   */\n  private async _getBuildInfoFromDebugFile(\n    debugFilePath: string\n  ): Promise<string | undefined> {\n    if (await fsExtra.pathExists(debugFilePath)) {\n      const { buildInfo } = await fsExtra.readJson(debugFilePath);\n      return path.resolve(path.dirname(debugFilePath), buildInfo);\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Sync version of _getBuildInfoFromDebugFile\n   */\n  private _getBuildInfoFromDebugFileSync(\n    debugFilePath: string\n  ): string | undefined {\n    if (fsExtra.pathExistsSync(debugFilePath)) {\n      const { buildInfo } = fsExtra.readJsonSync(debugFilePath);\n      return path.resolve(path.dirname(debugFilePath), buildInfo);\n    }\n\n    return undefined;\n  }\n}\n\n/**\n * Retrieves an artifact for the given `contractName` from the compilation output.\n *\n * @param sourceName The contract's source name.\n * @param contractName the contract's name.\n * @param contractOutput the contract's compilation output as emitted by `solc`.\n */\nexport function getArtifactFromContractOutput(\n  sourceName: string,\n  contractName: string,\n  contractOutput: any\n): Artifact {\n  const evmBytecode = contractOutput.evm?.bytecode;\n  let bytecode: string = evmBytecode?.object ?? \"\";\n\n  if (bytecode.slice(0, 2).toLowerCase() !== \"0x\") {\n    bytecode = `0x${bytecode}`;\n  }\n\n  const evmDeployedBytecode = contractOutput.evm?.deployedBytecode;\n  let deployedBytecode: string = evmDeployedBytecode?.object ?? \"\";\n\n  if (deployedBytecode.slice(0, 2).toLowerCase() !== \"0x\") {\n    deployedBytecode = `0x${deployedBytecode}`;\n  }\n\n  const linkReferences = evmBytecode?.linkReferences ?? {};\n  const deployedLinkReferences = evmDeployedBytecode?.linkReferences ?? {};\n\n  return {\n    _format: ARTIFACT_FORMAT_VERSION,\n    contractName,\n    sourceName,\n    abi: contractOutput.abi,\n    bytecode,\n    deployedBytecode,\n    linkReferences,\n    deployedLinkReferences,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}