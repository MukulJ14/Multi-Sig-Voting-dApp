{"ast":null,"code":"'use strict';\n\nconst {\n  Headers,\n  HeadersList,\n  fill\n} = require('./headers');\nconst {\n  extractBody,\n  cloneBody,\n  mixinBody\n} = require('./body');\nconst util = require('../core/util');\nconst {\n  kEnumerableProperty\n} = util;\nconst {\n  isValidReasonPhrase,\n  isCancelled,\n  isAborted,\n  isBlobLike,\n  serializeJavascriptValueToJSONString,\n  isErrorLike,\n  isomorphicEncode\n} = require('./util');\nconst {\n  redirectStatusSet,\n  nullBodyStatus,\n  DOMException\n} = require('./constants');\nconst {\n  kState,\n  kHeaders,\n  kGuard,\n  kRealm\n} = require('./symbols');\nconst {\n  webidl\n} = require('./webidl');\nconst {\n  FormData\n} = require('./formdata');\nconst {\n  getGlobalOrigin\n} = require('./global');\nconst {\n  URLSerializer\n} = require('./dataURL');\nconst {\n  kHeadersList\n} = require('../core/symbols');\nconst assert = require('assert');\nconst {\n  types\n} = require('util');\nconst ReadableStream = globalThis.ReadableStream || require('stream/web').ReadableStream;\nconst textEncoder = new TextEncoder('utf-8');\n\n// https://fetch.spec.whatwg.org/#response-class\nclass Response {\n  // Creates network error Response.\n  static error() {\n    // TODO\n    const relevantRealm = {\n      settingsObject: {}\n    };\n\n    // The static error() method steps are to return the result of creating a\n    // Response object, given a new network error, \"immutable\", and this’s\n    // relevant Realm.\n    const responseObject = new Response();\n    responseObject[kState] = makeNetworkError();\n    responseObject[kRealm] = relevantRealm;\n    responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList;\n    responseObject[kHeaders][kGuard] = 'immutable';\n    responseObject[kHeaders][kRealm] = relevantRealm;\n    return responseObject;\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-response-json\n  static json(data, init = {}) {\n    webidl.argumentLengthCheck(arguments, 1, {\n      header: 'Response.json'\n    });\n    if (init !== null) {\n      init = webidl.converters.ResponseInit(init);\n    }\n\n    // 1. Let bytes the result of running serialize a JavaScript value to JSON bytes on data.\n    const bytes = textEncoder.encode(serializeJavascriptValueToJSONString(data));\n\n    // 2. Let body be the result of extracting bytes.\n    const body = extractBody(bytes);\n\n    // 3. Let responseObject be the result of creating a Response object, given a new response,\n    //    \"response\", and this’s relevant Realm.\n    const relevantRealm = {\n      settingsObject: {}\n    };\n    const responseObject = new Response();\n    responseObject[kRealm] = relevantRealm;\n    responseObject[kHeaders][kGuard] = 'response';\n    responseObject[kHeaders][kRealm] = relevantRealm;\n\n    // 4. Perform initialize a response given responseObject, init, and (body, \"application/json\").\n    initializeResponse(responseObject, init, {\n      body: body[0],\n      type: 'application/json'\n    });\n\n    // 5. Return responseObject.\n    return responseObject;\n  }\n\n  // Creates a redirect Response that redirects to url with status status.\n  static redirect(url, status = 302) {\n    const relevantRealm = {\n      settingsObject: {}\n    };\n    webidl.argumentLengthCheck(arguments, 1, {\n      header: 'Response.redirect'\n    });\n    url = webidl.converters.USVString(url);\n    status = webidl.converters['unsigned short'](status);\n\n    // 1. Let parsedURL be the result of parsing url with current settings\n    // object’s API base URL.\n    // 2. If parsedURL is failure, then throw a TypeError.\n    // TODO: base-URL?\n    let parsedURL;\n    try {\n      parsedURL = new URL(url, getGlobalOrigin());\n    } catch (err) {\n      throw Object.assign(new TypeError('Failed to parse URL from ' + url), {\n        cause: err\n      });\n    }\n\n    // 3. If status is not a redirect status, then throw a RangeError.\n    if (!redirectStatusSet.has(status)) {\n      throw new RangeError('Invalid status code ' + status);\n    }\n\n    // 4. Let responseObject be the result of creating a Response object,\n    // given a new response, \"immutable\", and this’s relevant Realm.\n    const responseObject = new Response();\n    responseObject[kRealm] = relevantRealm;\n    responseObject[kHeaders][kGuard] = 'immutable';\n    responseObject[kHeaders][kRealm] = relevantRealm;\n\n    // 5. Set responseObject’s response’s status to status.\n    responseObject[kState].status = status;\n\n    // 6. Let value be parsedURL, serialized and isomorphic encoded.\n    const value = isomorphicEncode(URLSerializer(parsedURL));\n\n    // 7. Append `Location`/value to responseObject’s response’s header list.\n    responseObject[kState].headersList.append('location', value);\n\n    // 8. Return responseObject.\n    return responseObject;\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-response\n  constructor(body = null, init = {}) {\n    if (body !== null) {\n      body = webidl.converters.BodyInit(body);\n    }\n    init = webidl.converters.ResponseInit(init);\n\n    // TODO\n    this[kRealm] = {\n      settingsObject: {}\n    };\n\n    // 1. Set this’s response to a new response.\n    this[kState] = makeResponse({});\n\n    // 2. Set this’s headers to a new Headers object with this’s relevant\n    // Realm, whose header list is this’s response’s header list and guard\n    // is \"response\".\n    this[kHeaders] = new Headers();\n    this[kHeaders][kGuard] = 'response';\n    this[kHeaders][kHeadersList] = this[kState].headersList;\n    this[kHeaders][kRealm] = this[kRealm];\n\n    // 3. Let bodyWithType be null.\n    let bodyWithType = null;\n\n    // 4. If body is non-null, then set bodyWithType to the result of extracting body.\n    if (body != null) {\n      const [extractedBody, type] = extractBody(body);\n      bodyWithType = {\n        body: extractedBody,\n        type\n      };\n    }\n\n    // 5. Perform initialize a response given this, init, and bodyWithType.\n    initializeResponse(this, init, bodyWithType);\n  }\n\n  // Returns response’s type, e.g., \"cors\".\n  get type() {\n    webidl.brandCheck(this, Response);\n\n    // The type getter steps are to return this’s response’s type.\n    return this[kState].type;\n  }\n\n  // Returns response’s URL, if it has one; otherwise the empty string.\n  get url() {\n    webidl.brandCheck(this, Response);\n    const urlList = this[kState].urlList;\n\n    // The url getter steps are to return the empty string if this’s\n    // response’s URL is null; otherwise this’s response’s URL,\n    // serialized with exclude fragment set to true.\n    const url = urlList[urlList.length - 1] ?? null;\n    if (url === null) {\n      return '';\n    }\n    return URLSerializer(url, true);\n  }\n\n  // Returns whether response was obtained through a redirect.\n  get redirected() {\n    webidl.brandCheck(this, Response);\n\n    // The redirected getter steps are to return true if this’s response’s URL\n    // list has more than one item; otherwise false.\n    return this[kState].urlList.length > 1;\n  }\n\n  // Returns response’s status.\n  get status() {\n    webidl.brandCheck(this, Response);\n\n    // The status getter steps are to return this’s response’s status.\n    return this[kState].status;\n  }\n\n  // Returns whether response’s status is an ok status.\n  get ok() {\n    webidl.brandCheck(this, Response);\n\n    // The ok getter steps are to return true if this’s response’s status is an\n    // ok status; otherwise false.\n    return this[kState].status >= 200 && this[kState].status <= 299;\n  }\n\n  // Returns response’s status message.\n  get statusText() {\n    webidl.brandCheck(this, Response);\n\n    // The statusText getter steps are to return this’s response’s status\n    // message.\n    return this[kState].statusText;\n  }\n\n  // Returns response’s headers as Headers.\n  get headers() {\n    webidl.brandCheck(this, Response);\n\n    // The headers getter steps are to return this’s headers.\n    return this[kHeaders];\n  }\n  get body() {\n    webidl.brandCheck(this, Response);\n    return this[kState].body ? this[kState].body.stream : null;\n  }\n  get bodyUsed() {\n    webidl.brandCheck(this, Response);\n    return !!this[kState].body && util.isDisturbed(this[kState].body.stream);\n  }\n\n  // Returns a clone of response.\n  clone() {\n    webidl.brandCheck(this, Response);\n\n    // 1. If this is unusable, then throw a TypeError.\n    if (this.bodyUsed || this.body && this.body.locked) {\n      throw webidl.errors.exception({\n        header: 'Response.clone',\n        message: 'Body has already been consumed.'\n      });\n    }\n\n    // 2. Let clonedResponse be the result of cloning this’s response.\n    const clonedResponse = cloneResponse(this[kState]);\n\n    // 3. Return the result of creating a Response object, given\n    // clonedResponse, this’s headers’s guard, and this’s relevant Realm.\n    const clonedResponseObject = new Response();\n    clonedResponseObject[kState] = clonedResponse;\n    clonedResponseObject[kRealm] = this[kRealm];\n    clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList;\n    clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard];\n    clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm];\n    return clonedResponseObject;\n  }\n}\nmixinBody(Response);\nObject.defineProperties(Response.prototype, {\n  type: kEnumerableProperty,\n  url: kEnumerableProperty,\n  status: kEnumerableProperty,\n  ok: kEnumerableProperty,\n  redirected: kEnumerableProperty,\n  statusText: kEnumerableProperty,\n  headers: kEnumerableProperty,\n  clone: kEnumerableProperty,\n  body: kEnumerableProperty,\n  bodyUsed: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'Response',\n    configurable: true\n  }\n});\nObject.defineProperties(Response, {\n  json: kEnumerableProperty,\n  redirect: kEnumerableProperty,\n  error: kEnumerableProperty\n});\n\n// https://fetch.spec.whatwg.org/#concept-response-clone\nfunction cloneResponse(response) {\n  // To clone a response response, run these steps:\n\n  // 1. If response is a filtered response, then return a new identical\n  // filtered response whose internal response is a clone of response’s\n  // internal response.\n  if (response.internalResponse) {\n    return filterResponse(cloneResponse(response.internalResponse), response.type);\n  }\n\n  // 2. Let newResponse be a copy of response, except for its body.\n  const newResponse = makeResponse({\n    ...response,\n    body: null\n  });\n\n  // 3. If response’s body is non-null, then set newResponse’s body to the\n  // result of cloning response’s body.\n  if (response.body != null) {\n    newResponse.body = cloneBody(response.body);\n  }\n\n  // 4. Return newResponse.\n  return newResponse;\n}\nfunction makeResponse(init) {\n  return {\n    aborted: false,\n    rangeRequested: false,\n    timingAllowPassed: false,\n    requestIncludesCredentials: false,\n    type: 'default',\n    status: 200,\n    timingInfo: null,\n    cacheState: '',\n    statusText: '',\n    ...init,\n    headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList(),\n    urlList: init.urlList ? [...init.urlList] : []\n  };\n}\nfunction makeNetworkError(reason) {\n  const isError = isErrorLike(reason);\n  return makeResponse({\n    type: 'error',\n    status: 0,\n    error: isError ? reason : new Error(reason ? String(reason) : reason),\n    aborted: reason && reason.name === 'AbortError'\n  });\n}\nfunction makeFilteredResponse(response, state) {\n  state = {\n    internalResponse: response,\n    ...state\n  };\n  return new Proxy(response, {\n    get(target, p) {\n      return p in state ? state[p] : target[p];\n    },\n    set(target, p, value) {\n      assert(!(p in state));\n      target[p] = value;\n      return true;\n    }\n  });\n}\n\n// https://fetch.spec.whatwg.org/#concept-filtered-response\nfunction filterResponse(response, type) {\n  // Set response to the following filtered response with response as its\n  // internal response, depending on request’s response tainting:\n  if (type === 'basic') {\n    // A basic filtered response is a filtered response whose type is \"basic\"\n    // and header list excludes any headers in internal response’s header list\n    // whose name is a forbidden response-header name.\n\n    // Note: undici does not implement forbidden response-header names\n    return makeFilteredResponse(response, {\n      type: 'basic',\n      headersList: response.headersList\n    });\n  } else if (type === 'cors') {\n    // A CORS filtered response is a filtered response whose type is \"cors\"\n    // and header list excludes any headers in internal response’s header\n    // list whose name is not a CORS-safelisted response-header name, given\n    // internal response’s CORS-exposed header-name list.\n\n    // Note: undici does not implement CORS-safelisted response-header names\n    return makeFilteredResponse(response, {\n      type: 'cors',\n      headersList: response.headersList\n    });\n  } else if (type === 'opaque') {\n    // An opaque filtered response is a filtered response whose type is\n    // \"opaque\", URL list is the empty list, status is 0, status message\n    // is the empty byte sequence, header list is empty, and body is null.\n\n    return makeFilteredResponse(response, {\n      type: 'opaque',\n      urlList: Object.freeze([]),\n      status: 0,\n      statusText: '',\n      body: null\n    });\n  } else if (type === 'opaqueredirect') {\n    // An opaque-redirect filtered response is a filtered response whose type\n    // is \"opaqueredirect\", status is 0, status message is the empty byte\n    // sequence, header list is empty, and body is null.\n\n    return makeFilteredResponse(response, {\n      type: 'opaqueredirect',\n      status: 0,\n      statusText: '',\n      headersList: [],\n      body: null\n    });\n  } else {\n    assert(false);\n  }\n}\n\n// https://fetch.spec.whatwg.org/#appropriate-network-error\nfunction makeAppropriateNetworkError(fetchParams, err = null) {\n  // 1. Assert: fetchParams is canceled.\n  assert(isCancelled(fetchParams));\n\n  // 2. Return an aborted network error if fetchParams is aborted;\n  // otherwise return a network error.\n  return isAborted(fetchParams) ? makeNetworkError(Object.assign(new DOMException('The operation was aborted.', 'AbortError'), {\n    cause: err\n  })) : makeNetworkError(Object.assign(new DOMException('Request was cancelled.'), {\n    cause: err\n  }));\n}\n\n// https://whatpr.org/fetch/1392.html#initialize-a-response\nfunction initializeResponse(response, init, body) {\n  // 1. If init[\"status\"] is not in the range 200 to 599, inclusive, then\n  //    throw a RangeError.\n  if (init.status !== null && (init.status < 200 || init.status > 599)) {\n    throw new RangeError('init[\"status\"] must be in the range of 200 to 599, inclusive.');\n  }\n\n  // 2. If init[\"statusText\"] does not match the reason-phrase token production,\n  //    then throw a TypeError.\n  if ('statusText' in init && init.statusText != null) {\n    // See, https://datatracker.ietf.org/doc/html/rfc7230#section-3.1.2:\n    //   reason-phrase  = *( HTAB / SP / VCHAR / obs-text )\n    if (!isValidReasonPhrase(String(init.statusText))) {\n      throw new TypeError('Invalid statusText');\n    }\n  }\n\n  // 3. Set response’s response’s status to init[\"status\"].\n  if ('status' in init && init.status != null) {\n    response[kState].status = init.status;\n  }\n\n  // 4. Set response’s response’s status message to init[\"statusText\"].\n  if ('statusText' in init && init.statusText != null) {\n    response[kState].statusText = init.statusText;\n  }\n\n  // 5. If init[\"headers\"] exists, then fill response’s headers with init[\"headers\"].\n  if ('headers' in init && init.headers != null) {\n    fill(response[kHeaders], init.headers);\n  }\n\n  // 6. If body was given, then:\n  if (body) {\n    // 1. If response's status is a null body status, then throw a TypeError.\n    if (nullBodyStatus.includes(response.status)) {\n      throw webidl.errors.exception({\n        header: 'Response constructor',\n        message: 'Invalid response status code ' + response.status\n      });\n    }\n\n    // 2. Set response's body to body's body.\n    response[kState].body = body.body;\n\n    // 3. If body's type is non-null and response's header list does not contain\n    //    `Content-Type`, then append (`Content-Type`, body's type) to response's header list.\n    if (body.type != null && !response[kState].headersList.contains('Content-Type')) {\n      response[kState].headersList.append('content-type', body.type);\n    }\n  }\n}\nwebidl.converters.ReadableStream = webidl.interfaceConverter(ReadableStream);\nwebidl.converters.FormData = webidl.interfaceConverter(FormData);\nwebidl.converters.URLSearchParams = webidl.interfaceConverter(URLSearchParams);\n\n// https://fetch.spec.whatwg.org/#typedefdef-xmlhttprequestbodyinit\nwebidl.converters.XMLHttpRequestBodyInit = function (V) {\n  if (typeof V === 'string') {\n    return webidl.converters.USVString(V);\n  }\n  if (isBlobLike(V)) {\n    return webidl.converters.Blob(V, {\n      strict: false\n    });\n  }\n  if (types.isAnyArrayBuffer(V) || types.isTypedArray(V) || types.isDataView(V)) {\n    return webidl.converters.BufferSource(V);\n  }\n  if (util.isFormDataLike(V)) {\n    return webidl.converters.FormData(V, {\n      strict: false\n    });\n  }\n  if (V instanceof URLSearchParams) {\n    return webidl.converters.URLSearchParams(V);\n  }\n  return webidl.converters.DOMString(V);\n};\n\n// https://fetch.spec.whatwg.org/#bodyinit\nwebidl.converters.BodyInit = function (V) {\n  if (V instanceof ReadableStream) {\n    return webidl.converters.ReadableStream(V);\n  }\n\n  // Note: the spec doesn't include async iterables,\n  // this is an undici extension.\n  if (V?.[Symbol.asyncIterator]) {\n    return V;\n  }\n  return webidl.converters.XMLHttpRequestBodyInit(V);\n};\nwebidl.converters.ResponseInit = webidl.dictionaryConverter([{\n  key: 'status',\n  converter: webidl.converters['unsigned short'],\n  defaultValue: 200\n}, {\n  key: 'statusText',\n  converter: webidl.converters.ByteString,\n  defaultValue: ''\n}, {\n  key: 'headers',\n  converter: webidl.converters.HeadersInit\n}]);\nmodule.exports = {\n  makeNetworkError,\n  makeResponse,\n  makeAppropriateNetworkError,\n  filterResponse,\n  Response,\n  cloneResponse\n};","map":{"version":3,"names":["Headers","HeadersList","fill","require","extractBody","cloneBody","mixinBody","util","kEnumerableProperty","isValidReasonPhrase","isCancelled","isAborted","isBlobLike","serializeJavascriptValueToJSONString","isErrorLike","isomorphicEncode","redirectStatusSet","nullBodyStatus","DOMException","kState","kHeaders","kGuard","kRealm","webidl","FormData","getGlobalOrigin","URLSerializer","kHeadersList","assert","types","ReadableStream","globalThis","textEncoder","TextEncoder","Response","error","relevantRealm","settingsObject","responseObject","makeNetworkError","headersList","json","data","init","argumentLengthCheck","arguments","header","converters","ResponseInit","bytes","encode","body","initializeResponse","type","redirect","url","status","USVString","parsedURL","URL","err","Object","assign","TypeError","cause","has","RangeError","value","append","constructor","BodyInit","makeResponse","bodyWithType","extractedBody","brandCheck","urlList","length","redirected","ok","statusText","headers","stream","bodyUsed","isDisturbed","clone","locked","errors","exception","message","clonedResponse","cloneResponse","clonedResponseObject","defineProperties","prototype","Symbol","toStringTag","configurable","response","internalResponse","filterResponse","newResponse","aborted","rangeRequested","timingAllowPassed","requestIncludesCredentials","timingInfo","cacheState","reason","isError","Error","String","name","makeFilteredResponse","state","Proxy","get","target","p","set","freeze","makeAppropriateNetworkError","fetchParams","includes","contains","interfaceConverter","URLSearchParams","XMLHttpRequestBodyInit","V","Blob","strict","isAnyArrayBuffer","isTypedArray","isDataView","BufferSource","isFormDataLike","DOMString","asyncIterator","dictionaryConverter","key","converter","defaultValue","ByteString","HeadersInit","module","exports"],"sources":["/Users/mukuljindal/Local/projects/fuckingwork/node_modules/undici/lib/fetch/response.js"],"sourcesContent":["'use strict'\n\nconst { Headers, HeadersList, fill } = require('./headers')\nconst { extractBody, cloneBody, mixinBody } = require('./body')\nconst util = require('../core/util')\nconst { kEnumerableProperty } = util\nconst {\n  isValidReasonPhrase,\n  isCancelled,\n  isAborted,\n  isBlobLike,\n  serializeJavascriptValueToJSONString,\n  isErrorLike,\n  isomorphicEncode\n} = require('./util')\nconst {\n  redirectStatusSet,\n  nullBodyStatus,\n  DOMException\n} = require('./constants')\nconst { kState, kHeaders, kGuard, kRealm } = require('./symbols')\nconst { webidl } = require('./webidl')\nconst { FormData } = require('./formdata')\nconst { getGlobalOrigin } = require('./global')\nconst { URLSerializer } = require('./dataURL')\nconst { kHeadersList } = require('../core/symbols')\nconst assert = require('assert')\nconst { types } = require('util')\n\nconst ReadableStream = globalThis.ReadableStream || require('stream/web').ReadableStream\nconst textEncoder = new TextEncoder('utf-8')\n\n// https://fetch.spec.whatwg.org/#response-class\nclass Response {\n  // Creates network error Response.\n  static error () {\n    // TODO\n    const relevantRealm = { settingsObject: {} }\n\n    // The static error() method steps are to return the result of creating a\n    // Response object, given a new network error, \"immutable\", and this’s\n    // relevant Realm.\n    const responseObject = new Response()\n    responseObject[kState] = makeNetworkError()\n    responseObject[kRealm] = relevantRealm\n    responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList\n    responseObject[kHeaders][kGuard] = 'immutable'\n    responseObject[kHeaders][kRealm] = relevantRealm\n    return responseObject\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-response-json\n  static json (data, init = {}) {\n    webidl.argumentLengthCheck(arguments, 1, { header: 'Response.json' })\n\n    if (init !== null) {\n      init = webidl.converters.ResponseInit(init)\n    }\n\n    // 1. Let bytes the result of running serialize a JavaScript value to JSON bytes on data.\n    const bytes = textEncoder.encode(\n      serializeJavascriptValueToJSONString(data)\n    )\n\n    // 2. Let body be the result of extracting bytes.\n    const body = extractBody(bytes)\n\n    // 3. Let responseObject be the result of creating a Response object, given a new response,\n    //    \"response\", and this’s relevant Realm.\n    const relevantRealm = { settingsObject: {} }\n    const responseObject = new Response()\n    responseObject[kRealm] = relevantRealm\n    responseObject[kHeaders][kGuard] = 'response'\n    responseObject[kHeaders][kRealm] = relevantRealm\n\n    // 4. Perform initialize a response given responseObject, init, and (body, \"application/json\").\n    initializeResponse(responseObject, init, { body: body[0], type: 'application/json' })\n\n    // 5. Return responseObject.\n    return responseObject\n  }\n\n  // Creates a redirect Response that redirects to url with status status.\n  static redirect (url, status = 302) {\n    const relevantRealm = { settingsObject: {} }\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'Response.redirect' })\n\n    url = webidl.converters.USVString(url)\n    status = webidl.converters['unsigned short'](status)\n\n    // 1. Let parsedURL be the result of parsing url with current settings\n    // object’s API base URL.\n    // 2. If parsedURL is failure, then throw a TypeError.\n    // TODO: base-URL?\n    let parsedURL\n    try {\n      parsedURL = new URL(url, getGlobalOrigin())\n    } catch (err) {\n      throw Object.assign(new TypeError('Failed to parse URL from ' + url), {\n        cause: err\n      })\n    }\n\n    // 3. If status is not a redirect status, then throw a RangeError.\n    if (!redirectStatusSet.has(status)) {\n      throw new RangeError('Invalid status code ' + status)\n    }\n\n    // 4. Let responseObject be the result of creating a Response object,\n    // given a new response, \"immutable\", and this’s relevant Realm.\n    const responseObject = new Response()\n    responseObject[kRealm] = relevantRealm\n    responseObject[kHeaders][kGuard] = 'immutable'\n    responseObject[kHeaders][kRealm] = relevantRealm\n\n    // 5. Set responseObject’s response’s status to status.\n    responseObject[kState].status = status\n\n    // 6. Let value be parsedURL, serialized and isomorphic encoded.\n    const value = isomorphicEncode(URLSerializer(parsedURL))\n\n    // 7. Append `Location`/value to responseObject’s response’s header list.\n    responseObject[kState].headersList.append('location', value)\n\n    // 8. Return responseObject.\n    return responseObject\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-response\n  constructor (body = null, init = {}) {\n    if (body !== null) {\n      body = webidl.converters.BodyInit(body)\n    }\n\n    init = webidl.converters.ResponseInit(init)\n\n    // TODO\n    this[kRealm] = { settingsObject: {} }\n\n    // 1. Set this’s response to a new response.\n    this[kState] = makeResponse({})\n\n    // 2. Set this’s headers to a new Headers object with this’s relevant\n    // Realm, whose header list is this’s response’s header list and guard\n    // is \"response\".\n    this[kHeaders] = new Headers()\n    this[kHeaders][kGuard] = 'response'\n    this[kHeaders][kHeadersList] = this[kState].headersList\n    this[kHeaders][kRealm] = this[kRealm]\n\n    // 3. Let bodyWithType be null.\n    let bodyWithType = null\n\n    // 4. If body is non-null, then set bodyWithType to the result of extracting body.\n    if (body != null) {\n      const [extractedBody, type] = extractBody(body)\n      bodyWithType = { body: extractedBody, type }\n    }\n\n    // 5. Perform initialize a response given this, init, and bodyWithType.\n    initializeResponse(this, init, bodyWithType)\n  }\n\n  // Returns response’s type, e.g., \"cors\".\n  get type () {\n    webidl.brandCheck(this, Response)\n\n    // The type getter steps are to return this’s response’s type.\n    return this[kState].type\n  }\n\n  // Returns response’s URL, if it has one; otherwise the empty string.\n  get url () {\n    webidl.brandCheck(this, Response)\n\n    const urlList = this[kState].urlList\n\n    // The url getter steps are to return the empty string if this’s\n    // response’s URL is null; otherwise this’s response’s URL,\n    // serialized with exclude fragment set to true.\n    const url = urlList[urlList.length - 1] ?? null\n\n    if (url === null) {\n      return ''\n    }\n\n    return URLSerializer(url, true)\n  }\n\n  // Returns whether response was obtained through a redirect.\n  get redirected () {\n    webidl.brandCheck(this, Response)\n\n    // The redirected getter steps are to return true if this’s response’s URL\n    // list has more than one item; otherwise false.\n    return this[kState].urlList.length > 1\n  }\n\n  // Returns response’s status.\n  get status () {\n    webidl.brandCheck(this, Response)\n\n    // The status getter steps are to return this’s response’s status.\n    return this[kState].status\n  }\n\n  // Returns whether response’s status is an ok status.\n  get ok () {\n    webidl.brandCheck(this, Response)\n\n    // The ok getter steps are to return true if this’s response’s status is an\n    // ok status; otherwise false.\n    return this[kState].status >= 200 && this[kState].status <= 299\n  }\n\n  // Returns response’s status message.\n  get statusText () {\n    webidl.brandCheck(this, Response)\n\n    // The statusText getter steps are to return this’s response’s status\n    // message.\n    return this[kState].statusText\n  }\n\n  // Returns response’s headers as Headers.\n  get headers () {\n    webidl.brandCheck(this, Response)\n\n    // The headers getter steps are to return this’s headers.\n    return this[kHeaders]\n  }\n\n  get body () {\n    webidl.brandCheck(this, Response)\n\n    return this[kState].body ? this[kState].body.stream : null\n  }\n\n  get bodyUsed () {\n    webidl.brandCheck(this, Response)\n\n    return !!this[kState].body && util.isDisturbed(this[kState].body.stream)\n  }\n\n  // Returns a clone of response.\n  clone () {\n    webidl.brandCheck(this, Response)\n\n    // 1. If this is unusable, then throw a TypeError.\n    if (this.bodyUsed || (this.body && this.body.locked)) {\n      throw webidl.errors.exception({\n        header: 'Response.clone',\n        message: 'Body has already been consumed.'\n      })\n    }\n\n    // 2. Let clonedResponse be the result of cloning this’s response.\n    const clonedResponse = cloneResponse(this[kState])\n\n    // 3. Return the result of creating a Response object, given\n    // clonedResponse, this’s headers’s guard, and this’s relevant Realm.\n    const clonedResponseObject = new Response()\n    clonedResponseObject[kState] = clonedResponse\n    clonedResponseObject[kRealm] = this[kRealm]\n    clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList\n    clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard]\n    clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm]\n\n    return clonedResponseObject\n  }\n}\n\nmixinBody(Response)\n\nObject.defineProperties(Response.prototype, {\n  type: kEnumerableProperty,\n  url: kEnumerableProperty,\n  status: kEnumerableProperty,\n  ok: kEnumerableProperty,\n  redirected: kEnumerableProperty,\n  statusText: kEnumerableProperty,\n  headers: kEnumerableProperty,\n  clone: kEnumerableProperty,\n  body: kEnumerableProperty,\n  bodyUsed: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'Response',\n    configurable: true\n  }\n})\n\nObject.defineProperties(Response, {\n  json: kEnumerableProperty,\n  redirect: kEnumerableProperty,\n  error: kEnumerableProperty\n})\n\n// https://fetch.spec.whatwg.org/#concept-response-clone\nfunction cloneResponse (response) {\n  // To clone a response response, run these steps:\n\n  // 1. If response is a filtered response, then return a new identical\n  // filtered response whose internal response is a clone of response’s\n  // internal response.\n  if (response.internalResponse) {\n    return filterResponse(\n      cloneResponse(response.internalResponse),\n      response.type\n    )\n  }\n\n  // 2. Let newResponse be a copy of response, except for its body.\n  const newResponse = makeResponse({ ...response, body: null })\n\n  // 3. If response’s body is non-null, then set newResponse’s body to the\n  // result of cloning response’s body.\n  if (response.body != null) {\n    newResponse.body = cloneBody(response.body)\n  }\n\n  // 4. Return newResponse.\n  return newResponse\n}\n\nfunction makeResponse (init) {\n  return {\n    aborted: false,\n    rangeRequested: false,\n    timingAllowPassed: false,\n    requestIncludesCredentials: false,\n    type: 'default',\n    status: 200,\n    timingInfo: null,\n    cacheState: '',\n    statusText: '',\n    ...init,\n    headersList: init.headersList\n      ? new HeadersList(init.headersList)\n      : new HeadersList(),\n    urlList: init.urlList ? [...init.urlList] : []\n  }\n}\n\nfunction makeNetworkError (reason) {\n  const isError = isErrorLike(reason)\n  return makeResponse({\n    type: 'error',\n    status: 0,\n    error: isError\n      ? reason\n      : new Error(reason ? String(reason) : reason),\n    aborted: reason && reason.name === 'AbortError'\n  })\n}\n\nfunction makeFilteredResponse (response, state) {\n  state = {\n    internalResponse: response,\n    ...state\n  }\n\n  return new Proxy(response, {\n    get (target, p) {\n      return p in state ? state[p] : target[p]\n    },\n    set (target, p, value) {\n      assert(!(p in state))\n      target[p] = value\n      return true\n    }\n  })\n}\n\n// https://fetch.spec.whatwg.org/#concept-filtered-response\nfunction filterResponse (response, type) {\n  // Set response to the following filtered response with response as its\n  // internal response, depending on request’s response tainting:\n  if (type === 'basic') {\n    // A basic filtered response is a filtered response whose type is \"basic\"\n    // and header list excludes any headers in internal response’s header list\n    // whose name is a forbidden response-header name.\n\n    // Note: undici does not implement forbidden response-header names\n    return makeFilteredResponse(response, {\n      type: 'basic',\n      headersList: response.headersList\n    })\n  } else if (type === 'cors') {\n    // A CORS filtered response is a filtered response whose type is \"cors\"\n    // and header list excludes any headers in internal response’s header\n    // list whose name is not a CORS-safelisted response-header name, given\n    // internal response’s CORS-exposed header-name list.\n\n    // Note: undici does not implement CORS-safelisted response-header names\n    return makeFilteredResponse(response, {\n      type: 'cors',\n      headersList: response.headersList\n    })\n  } else if (type === 'opaque') {\n    // An opaque filtered response is a filtered response whose type is\n    // \"opaque\", URL list is the empty list, status is 0, status message\n    // is the empty byte sequence, header list is empty, and body is null.\n\n    return makeFilteredResponse(response, {\n      type: 'opaque',\n      urlList: Object.freeze([]),\n      status: 0,\n      statusText: '',\n      body: null\n    })\n  } else if (type === 'opaqueredirect') {\n    // An opaque-redirect filtered response is a filtered response whose type\n    // is \"opaqueredirect\", status is 0, status message is the empty byte\n    // sequence, header list is empty, and body is null.\n\n    return makeFilteredResponse(response, {\n      type: 'opaqueredirect',\n      status: 0,\n      statusText: '',\n      headersList: [],\n      body: null\n    })\n  } else {\n    assert(false)\n  }\n}\n\n// https://fetch.spec.whatwg.org/#appropriate-network-error\nfunction makeAppropriateNetworkError (fetchParams, err = null) {\n  // 1. Assert: fetchParams is canceled.\n  assert(isCancelled(fetchParams))\n\n  // 2. Return an aborted network error if fetchParams is aborted;\n  // otherwise return a network error.\n  return isAborted(fetchParams)\n    ? makeNetworkError(Object.assign(new DOMException('The operation was aborted.', 'AbortError'), { cause: err }))\n    : makeNetworkError(Object.assign(new DOMException('Request was cancelled.'), { cause: err }))\n}\n\n// https://whatpr.org/fetch/1392.html#initialize-a-response\nfunction initializeResponse (response, init, body) {\n  // 1. If init[\"status\"] is not in the range 200 to 599, inclusive, then\n  //    throw a RangeError.\n  if (init.status !== null && (init.status < 200 || init.status > 599)) {\n    throw new RangeError('init[\"status\"] must be in the range of 200 to 599, inclusive.')\n  }\n\n  // 2. If init[\"statusText\"] does not match the reason-phrase token production,\n  //    then throw a TypeError.\n  if ('statusText' in init && init.statusText != null) {\n    // See, https://datatracker.ietf.org/doc/html/rfc7230#section-3.1.2:\n    //   reason-phrase  = *( HTAB / SP / VCHAR / obs-text )\n    if (!isValidReasonPhrase(String(init.statusText))) {\n      throw new TypeError('Invalid statusText')\n    }\n  }\n\n  // 3. Set response’s response’s status to init[\"status\"].\n  if ('status' in init && init.status != null) {\n    response[kState].status = init.status\n  }\n\n  // 4. Set response’s response’s status message to init[\"statusText\"].\n  if ('statusText' in init && init.statusText != null) {\n    response[kState].statusText = init.statusText\n  }\n\n  // 5. If init[\"headers\"] exists, then fill response’s headers with init[\"headers\"].\n  if ('headers' in init && init.headers != null) {\n    fill(response[kHeaders], init.headers)\n  }\n\n  // 6. If body was given, then:\n  if (body) {\n    // 1. If response's status is a null body status, then throw a TypeError.\n    if (nullBodyStatus.includes(response.status)) {\n      throw webidl.errors.exception({\n        header: 'Response constructor',\n        message: 'Invalid response status code ' + response.status\n      })\n    }\n\n    // 2. Set response's body to body's body.\n    response[kState].body = body.body\n\n    // 3. If body's type is non-null and response's header list does not contain\n    //    `Content-Type`, then append (`Content-Type`, body's type) to response's header list.\n    if (body.type != null && !response[kState].headersList.contains('Content-Type')) {\n      response[kState].headersList.append('content-type', body.type)\n    }\n  }\n}\n\nwebidl.converters.ReadableStream = webidl.interfaceConverter(\n  ReadableStream\n)\n\nwebidl.converters.FormData = webidl.interfaceConverter(\n  FormData\n)\n\nwebidl.converters.URLSearchParams = webidl.interfaceConverter(\n  URLSearchParams\n)\n\n// https://fetch.spec.whatwg.org/#typedefdef-xmlhttprequestbodyinit\nwebidl.converters.XMLHttpRequestBodyInit = function (V) {\n  if (typeof V === 'string') {\n    return webidl.converters.USVString(V)\n  }\n\n  if (isBlobLike(V)) {\n    return webidl.converters.Blob(V, { strict: false })\n  }\n\n  if (\n    types.isAnyArrayBuffer(V) ||\n    types.isTypedArray(V) ||\n    types.isDataView(V)\n  ) {\n    return webidl.converters.BufferSource(V)\n  }\n\n  if (util.isFormDataLike(V)) {\n    return webidl.converters.FormData(V, { strict: false })\n  }\n\n  if (V instanceof URLSearchParams) {\n    return webidl.converters.URLSearchParams(V)\n  }\n\n  return webidl.converters.DOMString(V)\n}\n\n// https://fetch.spec.whatwg.org/#bodyinit\nwebidl.converters.BodyInit = function (V) {\n  if (V instanceof ReadableStream) {\n    return webidl.converters.ReadableStream(V)\n  }\n\n  // Note: the spec doesn't include async iterables,\n  // this is an undici extension.\n  if (V?.[Symbol.asyncIterator]) {\n    return V\n  }\n\n  return webidl.converters.XMLHttpRequestBodyInit(V)\n}\n\nwebidl.converters.ResponseInit = webidl.dictionaryConverter([\n  {\n    key: 'status',\n    converter: webidl.converters['unsigned short'],\n    defaultValue: 200\n  },\n  {\n    key: 'statusText',\n    converter: webidl.converters.ByteString,\n    defaultValue: ''\n  },\n  {\n    key: 'headers',\n    converter: webidl.converters.HeadersInit\n  }\n])\n\nmodule.exports = {\n  makeNetworkError,\n  makeResponse,\n  makeAppropriateNetworkError,\n  filterResponse,\n  Response,\n  cloneResponse\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}