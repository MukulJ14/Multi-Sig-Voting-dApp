{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setupContext = exports.createEvalAwarePartialHost = exports.EvalState = exports.createRepl = exports.REPL_NAME = exports.REPL_FILENAME = exports.STDIN_NAME = exports.STDIN_FILENAME = exports.EVAL_NAME = exports.EVAL_FILENAME = void 0;\nconst os_1 = require(\"os\");\nconst path_1 = require(\"path\");\nconst repl_1 = require(\"repl\");\nconst vm_1 = require(\"vm\");\nconst index_1 = require(\"./index\");\nconst fs_1 = require(\"fs\");\nconst console_1 = require(\"console\");\nconst assert = require(\"assert\");\nconst module_1 = require(\"module\");\n// Lazy-loaded.\nlet _processTopLevelAwait;\nfunction getProcessTopLevelAwait() {\n  if (_processTopLevelAwait === undefined) {\n    ({\n      processTopLevelAwait: _processTopLevelAwait\n    } = require('../dist-raw/node-internal-repl-await'));\n  }\n  return _processTopLevelAwait;\n}\nlet diff;\nfunction getDiffLines() {\n  if (diff === undefined) {\n    diff = require('diff');\n  }\n  return diff.diffLines;\n}\n/** @internal */\nexports.EVAL_FILENAME = `[eval].ts`;\n/** @internal */\nexports.EVAL_NAME = `[eval]`;\n/** @internal */\nexports.STDIN_FILENAME = `[stdin].ts`;\n/** @internal */\nexports.STDIN_NAME = `[stdin]`;\n/** @internal */\nexports.REPL_FILENAME = '<repl>.ts';\n/** @internal */\nexports.REPL_NAME = '<repl>';\n/**\n * Create a ts-node REPL instance.\n *\n * Pay close attention to the example below.  Today, the API requires a few lines\n * of boilerplate to correctly bind the `ReplService` to the ts-node `Service` and\n * vice-versa.\n *\n * Usage example:\n *\n *     const repl = tsNode.createRepl();\n *     const service = tsNode.create({...repl.evalAwarePartialHost});\n *     repl.setService(service);\n *     repl.start();\n *\n * @category REPL\n */\nfunction createRepl(options = {}) {\n  var _a, _b, _c, _d, _e;\n  const {\n    ignoreDiagnosticsThatAreAnnoyingInInteractiveRepl = true\n  } = options;\n  let service = options.service;\n  let nodeReplServer;\n  // If `useGlobal` is not true, then REPL creates a context when started.\n  // This stores a reference to it or to `global`, whichever is used, after REPL has started.\n  let context;\n  const state = (_a = options.state) !== null && _a !== void 0 ? _a : new EvalState((0, path_1.join)(process.cwd(), exports.REPL_FILENAME));\n  const evalAwarePartialHost = createEvalAwarePartialHost(state, options.composeWithEvalAwarePartialHost);\n  const stdin = (_b = options.stdin) !== null && _b !== void 0 ? _b : process.stdin;\n  const stdout = (_c = options.stdout) !== null && _c !== void 0 ? _c : process.stdout;\n  const stderr = (_d = options.stderr) !== null && _d !== void 0 ? _d : process.stderr;\n  const _console = stdout === process.stdout && stderr === process.stderr ? console : new console_1.Console(stdout, stderr);\n  const replService = {\n    state: (_e = options.state) !== null && _e !== void 0 ? _e : new EvalState((0, path_1.join)(process.cwd(), exports.EVAL_FILENAME)),\n    setService,\n    evalCode,\n    evalCodeInternal,\n    nodeEval,\n    evalAwarePartialHost,\n    start,\n    startInternal,\n    stdin,\n    stdout,\n    stderr,\n    console: _console\n  };\n  return replService;\n  function setService(_service) {\n    service = _service;\n    if (ignoreDiagnosticsThatAreAnnoyingInInteractiveRepl) {\n      service.addDiagnosticFilter({\n        appliesToAllFiles: false,\n        filenamesAbsolute: [state.path],\n        diagnosticsIgnored: [2393, 6133, 7027, ...(service.shouldReplAwait ? topLevelAwaitDiagnosticCodes : [])]\n      });\n    }\n  }\n  function evalCode(code) {\n    const result = appendCompileAndEvalInput({\n      service: service,\n      state,\n      input: code,\n      context,\n      overrideIsCompletion: false\n    });\n    assert(result.containsTopLevelAwait === false);\n    return result.value;\n  }\n  function evalCodeInternal(options) {\n    const {\n      code,\n      enableTopLevelAwait,\n      context\n    } = options;\n    return appendCompileAndEvalInput({\n      service: service,\n      state,\n      input: code,\n      enableTopLevelAwait,\n      context\n    });\n  }\n  function nodeEval(code, context, _filename, callback) {\n    // TODO: Figure out how to handle completion here.\n    if (code === '.scope') {\n      callback(null);\n      return;\n    }\n    try {\n      const evalResult = evalCodeInternal({\n        code,\n        enableTopLevelAwait: true,\n        context\n      });\n      if (evalResult.containsTopLevelAwait) {\n        (async () => {\n          try {\n            callback(null, await evalResult.valuePromise);\n          } catch (promiseError) {\n            handleError(promiseError);\n          }\n        })();\n      } else {\n        callback(null, evalResult.value);\n      }\n    } catch (error) {\n      handleError(error);\n    }\n    // Log TSErrors, check if they're recoverable, log helpful hints for certain\n    // well-known errors, and invoke `callback()`\n    // TODO should evalCode API get the same error-handling benefits?\n    function handleError(error) {\n      var _a, _b;\n      // Don't show TLA hint if the user explicitly disabled repl top level await\n      const canLogTopLevelAwaitHint = service.options.experimentalReplAwait !== false && !service.shouldReplAwait;\n      if (error instanceof index_1.TSError) {\n        // Support recoverable compilations using >= node 6.\n        if (repl_1.Recoverable && isRecoverable(error)) {\n          callback(new repl_1.Recoverable(error));\n          return;\n        } else {\n          _console.error(error);\n          if (canLogTopLevelAwaitHint && error.diagnosticCodes.some(dC => topLevelAwaitDiagnosticCodes.includes(dC))) {\n            _console.error(getTopLevelAwaitHint());\n          }\n          callback(null);\n        }\n      } else {\n        let _error = error;\n        if (canLogTopLevelAwaitHint && _error instanceof SyntaxError && ((_a = _error.message) === null || _a === void 0 ? void 0 : _a.includes('await is only valid'))) {\n          try {\n            // Only way I know to make our hint appear after the error\n            _error.message += `\\n\\n${getTopLevelAwaitHint()}`;\n            _error.stack = (_b = _error.stack) === null || _b === void 0 ? void 0 : _b.replace(/(SyntaxError:.*)/, (_, $1) => `${$1}\\n\\n${getTopLevelAwaitHint()}`);\n          } catch {}\n        }\n        callback(_error);\n      }\n    }\n    function getTopLevelAwaitHint() {\n      return `Hint: REPL top-level await requires TypeScript version 3.8 or higher and target ES2018 or higher. You are using TypeScript ${service.ts.version} and target ${service.ts.ScriptTarget[service.config.options.target]}.`;\n    }\n  }\n  // Note: `code` argument is deprecated\n  function start(code) {\n    startInternal({\n      code\n    });\n  }\n  // Note: `code` argument is deprecated\n  function startInternal(options) {\n    const {\n      code,\n      forceToBeModule = true,\n      ...optionsOverride\n    } = options !== null && options !== void 0 ? options : {};\n    // TODO assert that `service` is set; remove all `service!` non-null assertions\n    // Eval incoming code before the REPL starts.\n    // Note: deprecated\n    if (code) {\n      try {\n        evalCode(`${code}\\n`);\n      } catch (err) {\n        _console.error(err);\n        // Note: should not be killing the process here, but this codepath is deprecated anyway\n        process.exit(1);\n      }\n    }\n    // In case the typescript compiler hasn't compiled anything yet,\n    // make it run though compilation at least one time before\n    // the REPL starts for a snappier user experience on startup.\n    service === null || service === void 0 ? void 0 : service.compile('', state.path);\n    const repl = (0, repl_1.start)({\n      prompt: '> ',\n      input: replService.stdin,\n      output: replService.stdout,\n      // Mimicking node's REPL implementation: https://github.com/nodejs/node/blob/168b22ba073ee1cbf8d0bcb4ded7ff3099335d04/lib/internal/repl.js#L28-L30\n      terminal: stdout.isTTY && !parseInt(index_1.env.NODE_NO_READLINE, 10),\n      eval: nodeEval,\n      useGlobal: true,\n      ...optionsOverride\n    });\n    nodeReplServer = repl;\n    context = repl.context;\n    // Bookmark the point where we should reset the REPL state.\n    const resetEval = appendToEvalState(state, '');\n    function reset() {\n      resetEval();\n      // Hard fix for TypeScript forcing `Object.defineProperty(exports, ...)`.\n      runInContext('exports = module.exports', state.path, context);\n      if (forceToBeModule) {\n        state.input += 'export {};void 0;\\n';\n      }\n      // Declare node builtins.\n      // Skip the same builtins as `addBuiltinLibsToObject`:\n      //   those starting with _\n      //   those containing /\n      //   those that already exist as globals\n      // Intentionally suppress type errors in case @types/node does not declare any of them, and because\n      // `declare import` is technically invalid syntax.\n      // Avoid this when in transpileOnly, because third-party transpilers may not handle `declare import`.\n      if (!(service === null || service === void 0 ? void 0 : service.transpileOnly)) {\n        state.input += `// @ts-ignore\\n${module_1.builtinModules.filter(name => !name.startsWith('_') && !name.includes('/') && !['console', 'module', 'process'].includes(name)).map(name => `declare import ${name} = require('${name}')`).join(';')}\\n`;\n      }\n    }\n    reset();\n    repl.on('reset', reset);\n    repl.defineCommand('type', {\n      help: 'Check the type of a TypeScript identifier',\n      action: function (identifier) {\n        if (!identifier) {\n          repl.displayPrompt();\n          return;\n        }\n        const undo = appendToEvalState(state, identifier);\n        const {\n          name,\n          comment\n        } = service.getTypeInfo(state.input, state.path, state.input.length);\n        undo();\n        if (name) repl.outputStream.write(`${name}\\n`);\n        if (comment) repl.outputStream.write(`${comment}\\n`);\n        repl.displayPrompt();\n      }\n    });\n    // Set up REPL history when available natively via node.js >= 11.\n    if (repl.setupHistory) {\n      const historyPath = index_1.env.TS_NODE_HISTORY || (0, path_1.join)((0, os_1.homedir)(), '.ts_node_repl_history');\n      repl.setupHistory(historyPath, err => {\n        if (!err) return;\n        _console.error(err);\n        process.exit(1);\n      });\n    }\n    return repl;\n  }\n}\nexports.createRepl = createRepl;\n/**\n * Eval state management. Stores virtual `[eval].ts` file\n */\nclass EvalState {\n  constructor(path) {\n    this.path = path;\n    /** @internal */\n    this.input = '';\n    /** @internal */\n    this.output = '';\n    /** @internal */\n    this.version = 0;\n    /** @internal */\n    this.lines = 0;\n  }\n}\nexports.EvalState = EvalState;\nfunction createEvalAwarePartialHost(state, composeWith) {\n  function readFile(path) {\n    if (path === state.path) return state.input;\n    if (composeWith === null || composeWith === void 0 ? void 0 : composeWith.readFile) return composeWith.readFile(path);\n    try {\n      return (0, fs_1.readFileSync)(path, 'utf8');\n    } catch (err) {\n      /* Ignore. */\n    }\n  }\n  function fileExists(path) {\n    if (path === state.path) return true;\n    if (composeWith === null || composeWith === void 0 ? void 0 : composeWith.fileExists) return composeWith.fileExists(path);\n    try {\n      const stats = (0, fs_1.statSync)(path);\n      return stats.isFile() || stats.isFIFO();\n    } catch (err) {\n      return false;\n    }\n  }\n  return {\n    readFile,\n    fileExists\n  };\n}\nexports.createEvalAwarePartialHost = createEvalAwarePartialHost;\nconst sourcemapCommentRe = /\\/\\/# ?sourceMappingURL=\\S+[\\s\\r\\n]*$/;\n/**\n * Evaluate the code snippet.\n *\n * Append it to virtual .ts file, compile, handle compiler errors, compute a diff of the JS, and eval any code that\n * appears as \"added\" in the diff.\n */\nfunction appendCompileAndEvalInput(options) {\n  const {\n    service,\n    state,\n    wrappedErr,\n    enableTopLevelAwait = false,\n    context,\n    overrideIsCompletion\n  } = options;\n  let {\n    input\n  } = options;\n  // It's confusing for `{ a: 1 }` to be interpreted as a block statement\n  // rather than an object literal. So, we first try to wrap it in\n  // parentheses, so that it will be interpreted as an expression.\n  // Based on https://github.com/nodejs/node/blob/c2e6822153bad023ab7ebd30a6117dcc049e475c/lib/repl.js#L413-L422\n  let wrappedCmd = false;\n  if (!wrappedErr && /^\\s*{/.test(input) && !/;\\s*$/.test(input)) {\n    input = `(${input.trim()})\\n`;\n    wrappedCmd = true;\n  }\n  const lines = state.lines;\n  const isCompletion = overrideIsCompletion !== null && overrideIsCompletion !== void 0 ? overrideIsCompletion : !/\\n$/.test(input);\n  const undo = appendToEvalState(state, input);\n  let output;\n  // Based on https://github.com/nodejs/node/blob/92573721c7cff104ccb82b6ed3e8aa69c4b27510/lib/repl.js#L457-L461\n  function adjustUseStrict(code) {\n    // \"void 0\" keeps the repl from returning \"use strict\" as the result\n    // value for statements and declarations that don't return a value.\n    return code.replace(/^\"use strict\";/, '\"use strict\"; void 0;');\n  }\n  try {\n    output = service.compile(state.input, state.path, -lines);\n  } catch (err) {\n    undo();\n    if (wrappedCmd) {\n      if (err instanceof index_1.TSError && err.diagnosticCodes[0] === 2339) {\n        // Ensure consistent and more sane behavior between { a: 1 }['b'] and ({ a: 1 }['b'])\n        throw err;\n      }\n      // Unwrap and try again\n      return appendCompileAndEvalInput({\n        ...options,\n        wrappedErr: err\n      });\n    }\n    if (wrappedErr) throw wrappedErr;\n    throw err;\n  }\n  output = adjustUseStrict(output);\n  // Note: REPL does not respect sourcemaps!\n  // To properly do that, we'd need to prefix the code we eval -- which comes\n  // from `diffLines` -- with newlines so that it's at the proper line numbers.\n  // Then we'd need to ensure each bit of eval-ed code, if there are multiples,\n  // has the sourcemap appended to it.\n  // We might also need to integrate with our sourcemap hooks' cache; I'm not sure.\n  const outputWithoutSourcemapComment = output.replace(sourcemapCommentRe, '');\n  const oldOutputWithoutSourcemapComment = state.output.replace(sourcemapCommentRe, '');\n  // Use `diff` to check for new JavaScript to execute.\n  const changes = getDiffLines()(oldOutputWithoutSourcemapComment, outputWithoutSourcemapComment);\n  if (isCompletion) {\n    undo();\n  } else {\n    state.output = output;\n    // Insert a semicolon to make sure that the code doesn't interact with the next line,\n    // for example to prevent `2\\n+ 2` from producing 4.\n    // This is safe since the output will not change since we can only get here with successful inputs,\n    // and adding a semicolon to the end of a successful input won't ever change the output.\n    state.input = state.input.replace(/([^\\n\\s])([\\n\\s]*)$/, (all, lastChar, whitespace) => {\n      if (lastChar !== ';') return `${lastChar};${whitespace}`;\n      return all;\n    });\n  }\n  let commands = [];\n  let containsTopLevelAwait = false;\n  // Build a list of \"commands\": bits of JS code in the diff that must be executed.\n  for (const change of changes) {\n    if (change.added) {\n      if (enableTopLevelAwait && service.shouldReplAwait && change.value.indexOf('await') > -1) {\n        const processTopLevelAwait = getProcessTopLevelAwait();\n        // Newline prevents comments to mess with wrapper\n        const wrappedResult = processTopLevelAwait(change.value + '\\n');\n        if (wrappedResult !== null) {\n          containsTopLevelAwait = true;\n          commands.push({\n            mustAwait: true,\n            execCommand: () => runInContext(wrappedResult, state.path, context)\n          });\n          continue;\n        }\n      }\n      commands.push({\n        execCommand: () => runInContext(change.value, state.path, context)\n      });\n    }\n  }\n  // Execute all commands asynchronously if necessary, returning the result or a\n  // promise of the result.\n  if (containsTopLevelAwait) {\n    return {\n      containsTopLevelAwait,\n      valuePromise: (async () => {\n        let value;\n        for (const command of commands) {\n          const r = command.execCommand();\n          value = command.mustAwait ? await r : r;\n        }\n        return value;\n      })()\n    };\n  } else {\n    return {\n      containsTopLevelAwait: false,\n      value: commands.reduce((_, c) => c.execCommand(), undefined)\n    };\n  }\n}\n/**\n * Low-level execution of JS code in context\n */\nfunction runInContext(code, filename, context) {\n  const script = new vm_1.Script(code, {\n    filename\n  });\n  if (context === undefined || context === global) {\n    return script.runInThisContext();\n  } else {\n    return script.runInContext(context);\n  }\n}\n/**\n * Append to the eval instance and return an undo function.\n */\nfunction appendToEvalState(state, input) {\n  const undoInput = state.input;\n  const undoVersion = state.version;\n  const undoOutput = state.output;\n  const undoLines = state.lines;\n  state.input += input;\n  state.lines += lineCount(input);\n  state.version++;\n  return function () {\n    state.input = undoInput;\n    state.output = undoOutput;\n    state.version = undoVersion;\n    state.lines = undoLines;\n  };\n}\n/**\n * Count the number of lines.\n */\nfunction lineCount(value) {\n  let count = 0;\n  for (const char of value) {\n    if (char === '\\n') {\n      count++;\n    }\n  }\n  return count;\n}\n/**\n * TS diagnostic codes which are recoverable, meaning that the user likely entered an incomplete line of code\n * and should be prompted for the next.  For example, starting a multi-line for() loop and not finishing it.\n * null value means code is always recoverable.  `Set` means code is only recoverable when occurring alongside at least one\n * of the other codes.\n */\nconst RECOVERY_CODES = new Map([[1003, null], [1005, null], [1109, null], [1126, null], [1136, new Set([1005]) // happens when typing out an object literal or block scope across multiple lines: '{ foo: 123,'\n], [1160, null], [1161, null], [2355, null], [2391, null], [7010, new Set([1005]) // happens when fn signature spread across multiple lines: 'function a(\\nb: any\\n) {'\n]]);\n/**\n * Diagnostic codes raised when using top-level await.\n * These are suppressed when top-level await is enabled.\n * When it is *not* enabled, these trigger a helpful hint about enabling top-level await.\n */\nconst topLevelAwaitDiagnosticCodes = [1375, 1378, 1431, 1432 // Top-level 'for await' loops are only allowed when the 'module' option is set to 'esnext' or 'system', and the 'target' option is set to 'es2017' or higher.\n];\n/**\n * Check if a function can recover gracefully.\n */\nfunction isRecoverable(error) {\n  return error.diagnosticCodes.every(code => {\n    const deps = RECOVERY_CODES.get(code);\n    return deps === null || deps && error.diagnosticCodes.some(code => deps.has(code));\n  });\n}\n/**\n * @internal\n * Set properties on `context` before eval-ing [stdin] or [eval] input.\n */\nfunction setupContext(context, module, filenameAndDirname) {\n  if (filenameAndDirname) {\n    context.__dirname = '.';\n    context.__filename = `[${filenameAndDirname}]`;\n  }\n  context.module = module;\n  context.exports = module.exports;\n  context.require = module.require.bind(module);\n}\nexports.setupContext = setupContext;","map":{"version":3,"names":["os_1","require","path_1","repl_1","vm_1","index_1","fs_1","console_1","assert","module_1","_processTopLevelAwait","getProcessTopLevelAwait","undefined","processTopLevelAwait","diff","getDiffLines","diffLines","exports","EVAL_FILENAME","EVAL_NAME","STDIN_FILENAME","STDIN_NAME","REPL_FILENAME","REPL_NAME","createRepl","options","ignoreDiagnosticsThatAreAnnoyingInInteractiveRepl","service","nodeReplServer","context","state","_a","EvalState","join","process","cwd","evalAwarePartialHost","createEvalAwarePartialHost","composeWithEvalAwarePartialHost","stdin","_b","stdout","_c","stderr","_d","_console","console","Console","replService","_e","setService","evalCode","evalCodeInternal","nodeEval","start","startInternal","_service","addDiagnosticFilter","appliesToAllFiles","filenamesAbsolute","path","diagnosticsIgnored","shouldReplAwait","topLevelAwaitDiagnosticCodes","code","result","appendCompileAndEvalInput","input","overrideIsCompletion","containsTopLevelAwait","value","enableTopLevelAwait","_filename","callback","evalResult","valuePromise","promiseError","handleError","error","canLogTopLevelAwaitHint","experimentalReplAwait","TSError","Recoverable","isRecoverable","diagnosticCodes","some","dC","includes","getTopLevelAwaitHint","_error","SyntaxError","message","stack","replace","_","$1","ts","version","ScriptTarget","config","target","forceToBeModule","optionsOverride","err","exit","compile","repl","prompt","output","terminal","isTTY","parseInt","env","NODE_NO_READLINE","eval","useGlobal","resetEval","appendToEvalState","reset","runInContext","transpileOnly","builtinModules","filter","name","startsWith","map","on","defineCommand","help","action","identifier","displayPrompt","undo","comment","getTypeInfo","length","outputStream","write","setupHistory","historyPath","TS_NODE_HISTORY","homedir","constructor","lines","composeWith","readFile","readFileSync","fileExists","stats","statSync","isFile","isFIFO","sourcemapCommentRe","wrappedErr","wrappedCmd","test","trim","isCompletion","adjustUseStrict","outputWithoutSourcemapComment","oldOutputWithoutSourcemapComment","changes","all","lastChar","whitespace","commands","change","added","indexOf","wrappedResult","push","mustAwait","execCommand","command","r","reduce","c","filename","script","Script","global","runInThisContext","undoInput","undoVersion","undoOutput","undoLines","lineCount","count","char","RECOVERY_CODES","Map","Set","every","deps","get","has","setupContext","module","filenameAndDirname","__dirname","__filename","bind"],"sources":["/Users/mukuljindal/Local/projects/voting/node_modules/ts-node/src/repl.ts"],"sourcesContent":["import type * as _diff from 'diff';\nimport { homedir } from 'os';\nimport { join } from 'path';\nimport {\n  Recoverable,\n  ReplOptions,\n  REPLServer,\n  start as nodeReplStart,\n} from 'repl';\nimport { Context, createContext, Script } from 'vm';\nimport { Service, CreateOptions, TSError, env } from './index';\nimport { readFileSync, statSync } from 'fs';\nimport { Console } from 'console';\nimport * as assert from 'assert';\nimport type * as tty from 'tty';\nimport type * as Module from 'module';\nimport { builtinModules } from 'module';\n\n// Lazy-loaded.\nlet _processTopLevelAwait: (src: string) => string | null;\nfunction getProcessTopLevelAwait() {\n  if (_processTopLevelAwait === undefined) {\n    ({\n      processTopLevelAwait: _processTopLevelAwait,\n    } = require('../dist-raw/node-internal-repl-await'));\n  }\n  return _processTopLevelAwait;\n}\nlet diff: typeof _diff;\nfunction getDiffLines() {\n  if (diff === undefined) {\n    diff = require('diff');\n  }\n  return diff.diffLines;\n}\n\n/** @internal */\nexport const EVAL_FILENAME = `[eval].ts`;\n/** @internal */\nexport const EVAL_NAME = `[eval]`;\n/** @internal */\nexport const STDIN_FILENAME = `[stdin].ts`;\n/** @internal */\nexport const STDIN_NAME = `[stdin]`;\n/** @internal */\nexport const REPL_FILENAME = '<repl>.ts';\n/** @internal */\nexport const REPL_NAME = '<repl>';\n\nexport interface ReplService {\n  readonly state: EvalState;\n  /**\n   * Bind this REPL to a ts-node compiler service.  A compiler service must be bound before `eval`-ing code or starting the REPL\n   */\n  setService(service: Service): void;\n  /**\n   * Append code to the virtual <repl> source file, compile it to JavaScript, throw semantic errors if the typechecker is enabled,\n   * and execute it.\n   *\n   * Note: typically, you will want to call `start()` instead of using this method.\n   *\n   * @param code string of TypeScript.\n   */\n  evalCode(code: string): any;\n  /** @internal */\n  evalCodeInternal(opts: {\n    code: string;\n    enableTopLevelAwait?: boolean;\n    context?: Context;\n  }):\n    | {\n        containsTopLevelAwait: true;\n        valuePromise: Promise<any>;\n      }\n    | {\n        containsTopLevelAwait: false;\n        value: any;\n      };\n  /**\n   * `eval` implementation compatible with node's REPL API\n   *\n   * Can be used in advanced scenarios if you want to manually create your own\n   * node REPL instance and delegate eval to this `ReplService`.\n   *\n   * Example:\n   *\n   *     import {start} from 'repl';\n   *     const replService: tsNode.ReplService = ...; // assuming you have already created a ts-node ReplService\n   *     const nodeRepl = start({eval: replService.eval});\n   */\n  nodeEval(\n    code: string,\n    // TODO change to `Context` in a future release?  Technically a breaking change\n    context: any,\n    _filename: string,\n    callback: (err: Error | null, result?: any) => any\n  ): void;\n  evalAwarePartialHost: EvalAwarePartialHost;\n  /** Start a node REPL */\n  start(): void;\n  /**\n   * Start a node REPL, evaling a string of TypeScript before it starts.\n   * @deprecated\n   */\n  start(code: string): void;\n  /** @internal */\n  startInternal(opts?: ReplOptions): REPLServer;\n  /** @internal */\n  readonly stdin: NodeJS.ReadableStream;\n  /** @internal */\n  readonly stdout: NodeJS.WritableStream;\n  /** @internal */\n  readonly stderr: NodeJS.WritableStream;\n  /** @internal */\n  readonly console: Console;\n}\n\n/** @category REPL */\nexport interface CreateReplOptions {\n  service?: Service;\n  state?: EvalState;\n  stdin?: NodeJS.ReadableStream;\n  stdout?: NodeJS.WritableStream;\n  stderr?: NodeJS.WritableStream;\n  /** @internal */\n  composeWithEvalAwarePartialHost?: EvalAwarePartialHost;\n  /**\n   * @internal\n   * Ignore diagnostics that are annoying when interactively entering input line-by-line.\n   */\n  ignoreDiagnosticsThatAreAnnoyingInInteractiveRepl?: boolean;\n}\n\n/**\n * Create a ts-node REPL instance.\n *\n * Pay close attention to the example below.  Today, the API requires a few lines\n * of boilerplate to correctly bind the `ReplService` to the ts-node `Service` and\n * vice-versa.\n *\n * Usage example:\n *\n *     const repl = tsNode.createRepl();\n *     const service = tsNode.create({...repl.evalAwarePartialHost});\n *     repl.setService(service);\n *     repl.start();\n *\n * @category REPL\n */\nexport function createRepl(options: CreateReplOptions = {}) {\n  const { ignoreDiagnosticsThatAreAnnoyingInInteractiveRepl = true } = options;\n  let service = options.service;\n  let nodeReplServer: REPLServer;\n  // If `useGlobal` is not true, then REPL creates a context when started.\n  // This stores a reference to it or to `global`, whichever is used, after REPL has started.\n  let context: Context | undefined;\n  const state =\n    options.state ?? new EvalState(join(process.cwd(), REPL_FILENAME));\n  const evalAwarePartialHost = createEvalAwarePartialHost(\n    state,\n    options.composeWithEvalAwarePartialHost\n  );\n  const stdin = options.stdin ?? process.stdin;\n  const stdout = options.stdout ?? process.stdout;\n  const stderr = options.stderr ?? process.stderr;\n  const _console =\n    stdout === process.stdout && stderr === process.stderr\n      ? console\n      : new Console(stdout, stderr);\n\n  const replService: ReplService = {\n    state: options.state ?? new EvalState(join(process.cwd(), EVAL_FILENAME)),\n    setService,\n    evalCode,\n    evalCodeInternal,\n    nodeEval,\n    evalAwarePartialHost,\n    start,\n    startInternal,\n    stdin,\n    stdout,\n    stderr,\n    console: _console,\n  };\n\n  return replService;\n\n  function setService(_service: Service) {\n    service = _service;\n    if (ignoreDiagnosticsThatAreAnnoyingInInteractiveRepl) {\n      service.addDiagnosticFilter({\n        appliesToAllFiles: false,\n        filenamesAbsolute: [state.path],\n        diagnosticsIgnored: [\n          2393, // Duplicate function implementation: https://github.com/TypeStrong/ts-node/issues/729\n          6133, // <identifier> is declared but its value is never read. https://github.com/TypeStrong/ts-node/issues/850\n          7027, // Unreachable code detected. https://github.com/TypeStrong/ts-node/issues/469\n          ...(service.shouldReplAwait ? topLevelAwaitDiagnosticCodes : []),\n        ],\n      });\n    }\n  }\n\n  function evalCode(code: string) {\n    const result = appendCompileAndEvalInput({\n      service: service!,\n      state,\n      input: code,\n      context,\n      overrideIsCompletion: false,\n    });\n    assert(result.containsTopLevelAwait === false);\n    return result.value;\n  }\n\n  function evalCodeInternal(options: {\n    code: string;\n    enableTopLevelAwait?: boolean;\n    context: Context;\n  }) {\n    const { code, enableTopLevelAwait, context } = options;\n    return appendCompileAndEvalInput({\n      service: service!,\n      state,\n      input: code,\n      enableTopLevelAwait,\n      context,\n    });\n  }\n\n  function nodeEval(\n    code: string,\n    context: any,\n    _filename: string,\n    callback: (err: Error | null, result?: any) => any\n  ) {\n    // TODO: Figure out how to handle completion here.\n    if (code === '.scope') {\n      callback(null);\n      return;\n    }\n\n    try {\n      const evalResult = evalCodeInternal({\n        code,\n        enableTopLevelAwait: true,\n        context,\n      });\n\n      if (evalResult.containsTopLevelAwait) {\n        (async () => {\n          try {\n            callback(null, await evalResult.valuePromise);\n          } catch (promiseError) {\n            handleError(promiseError);\n          }\n        })();\n      } else {\n        callback(null, evalResult.value);\n      }\n    } catch (error) {\n      handleError(error);\n    }\n\n    // Log TSErrors, check if they're recoverable, log helpful hints for certain\n    // well-known errors, and invoke `callback()`\n    // TODO should evalCode API get the same error-handling benefits?\n    function handleError(error: unknown) {\n      // Don't show TLA hint if the user explicitly disabled repl top level await\n      const canLogTopLevelAwaitHint =\n        service!.options.experimentalReplAwait !== false &&\n        !service!.shouldReplAwait;\n      if (error instanceof TSError) {\n        // Support recoverable compilations using >= node 6.\n        if (Recoverable && isRecoverable(error)) {\n          callback(new Recoverable(error));\n          return;\n        } else {\n          _console.error(error);\n\n          if (\n            canLogTopLevelAwaitHint &&\n            error.diagnosticCodes.some((dC) =>\n              topLevelAwaitDiagnosticCodes.includes(dC)\n            )\n          ) {\n            _console.error(getTopLevelAwaitHint());\n          }\n          callback(null);\n        }\n      } else {\n        let _error = error as Error | undefined;\n        if (\n          canLogTopLevelAwaitHint &&\n          _error instanceof SyntaxError &&\n          _error.message?.includes('await is only valid')\n        ) {\n          try {\n            // Only way I know to make our hint appear after the error\n            _error.message += `\\n\\n${getTopLevelAwaitHint()}`;\n            _error.stack = _error.stack?.replace(\n              /(SyntaxError:.*)/,\n              (_, $1) => `${$1}\\n\\n${getTopLevelAwaitHint()}`\n            );\n          } catch {}\n        }\n        callback(_error as Error);\n      }\n    }\n    function getTopLevelAwaitHint() {\n      return `Hint: REPL top-level await requires TypeScript version 3.8 or higher and target ES2018 or higher. You are using TypeScript ${\n        service!.ts.version\n      } and target ${\n        service!.ts.ScriptTarget[service!.config.options.target!]\n      }.`;\n    }\n  }\n\n  // Note: `code` argument is deprecated\n  function start(code?: string) {\n    startInternal({ code });\n  }\n\n  // Note: `code` argument is deprecated\n  function startInternal(\n    options?: ReplOptions & { code?: string; forceToBeModule?: boolean }\n  ) {\n    const { code, forceToBeModule = true, ...optionsOverride } = options ?? {};\n    // TODO assert that `service` is set; remove all `service!` non-null assertions\n\n    // Eval incoming code before the REPL starts.\n    // Note: deprecated\n    if (code) {\n      try {\n        evalCode(`${code}\\n`);\n      } catch (err) {\n        _console.error(err);\n        // Note: should not be killing the process here, but this codepath is deprecated anyway\n        process.exit(1);\n      }\n    }\n\n    // In case the typescript compiler hasn't compiled anything yet,\n    // make it run though compilation at least one time before\n    // the REPL starts for a snappier user experience on startup.\n    service?.compile('', state.path);\n\n    const repl = nodeReplStart({\n      prompt: '> ',\n      input: replService.stdin,\n      output: replService.stdout,\n      // Mimicking node's REPL implementation: https://github.com/nodejs/node/blob/168b22ba073ee1cbf8d0bcb4ded7ff3099335d04/lib/internal/repl.js#L28-L30\n      terminal:\n        (stdout as tty.WriteStream).isTTY &&\n        !parseInt(env.NODE_NO_READLINE!, 10),\n      eval: nodeEval,\n      useGlobal: true,\n      ...optionsOverride,\n    });\n\n    nodeReplServer = repl;\n    context = repl.context;\n\n    // Bookmark the point where we should reset the REPL state.\n    const resetEval = appendToEvalState(state, '');\n\n    function reset() {\n      resetEval();\n\n      // Hard fix for TypeScript forcing `Object.defineProperty(exports, ...)`.\n      runInContext('exports = module.exports', state.path, context);\n      if (forceToBeModule) {\n        state.input += 'export {};void 0;\\n';\n      }\n\n      // Declare node builtins.\n      // Skip the same builtins as `addBuiltinLibsToObject`:\n      //   those starting with _\n      //   those containing /\n      //   those that already exist as globals\n      // Intentionally suppress type errors in case @types/node does not declare any of them, and because\n      // `declare import` is technically invalid syntax.\n      // Avoid this when in transpileOnly, because third-party transpilers may not handle `declare import`.\n      if (!service?.transpileOnly) {\n        state.input += `// @ts-ignore\\n${builtinModules\n          .filter(\n            (name) =>\n              !name.startsWith('_') &&\n              !name.includes('/') &&\n              !['console', 'module', 'process'].includes(name)\n          )\n          .map((name) => `declare import ${name} = require('${name}')`)\n          .join(';')}\\n`;\n      }\n    }\n\n    reset();\n    repl.on('reset', reset);\n\n    repl.defineCommand('type', {\n      help: 'Check the type of a TypeScript identifier',\n      action: function (identifier: string) {\n        if (!identifier) {\n          repl.displayPrompt();\n          return;\n        }\n\n        const undo = appendToEvalState(state, identifier);\n        const { name, comment } = service!.getTypeInfo(\n          state.input,\n          state.path,\n          state.input.length\n        );\n\n        undo();\n\n        if (name) repl.outputStream.write(`${name}\\n`);\n        if (comment) repl.outputStream.write(`${comment}\\n`);\n        repl.displayPrompt();\n      },\n    });\n\n    // Set up REPL history when available natively via node.js >= 11.\n    if (repl.setupHistory) {\n      const historyPath =\n        env.TS_NODE_HISTORY || join(homedir(), '.ts_node_repl_history');\n\n      repl.setupHistory(historyPath, (err) => {\n        if (!err) return;\n\n        _console.error(err);\n        process.exit(1);\n      });\n    }\n\n    return repl;\n  }\n}\n\n/**\n * Eval state management. Stores virtual `[eval].ts` file\n */\nexport class EvalState {\n  /** @internal */\n  input = '';\n  /** @internal */\n  output = '';\n  /** @internal */\n  version = 0;\n  /** @internal */\n  lines = 0;\n\n  __tsNodeEvalStateBrand: unknown;\n\n  constructor(public path: string) {}\n}\n\n/**\n * Filesystem host functions which are aware of the \"virtual\" `[eval].ts`, `<repl>`, or `[stdin].ts` file used to compile REPL inputs.\n * Must be passed to `create()` to create a ts-node compiler service which can compile REPL inputs.\n */\nexport type EvalAwarePartialHost = Pick<\n  CreateOptions,\n  'readFile' | 'fileExists'\n>;\n\nexport function createEvalAwarePartialHost(\n  state: EvalState,\n  composeWith?: EvalAwarePartialHost\n): EvalAwarePartialHost {\n  function readFile(path: string) {\n    if (path === state.path) return state.input;\n\n    if (composeWith?.readFile) return composeWith.readFile(path);\n\n    try {\n      return readFileSync(path, 'utf8');\n    } catch (err) {\n      /* Ignore. */\n    }\n  }\n  function fileExists(path: string) {\n    if (path === state.path) return true;\n\n    if (composeWith?.fileExists) return composeWith.fileExists(path);\n\n    try {\n      const stats = statSync(path);\n      return stats.isFile() || stats.isFIFO();\n    } catch (err) {\n      return false;\n    }\n  }\n  return { readFile, fileExists };\n}\n\nconst sourcemapCommentRe = /\\/\\/# ?sourceMappingURL=\\S+[\\s\\r\\n]*$/;\n\ntype AppendCompileAndEvalInputResult =\n  | { containsTopLevelAwait: true; valuePromise: Promise<any> }\n  | { containsTopLevelAwait: false; value: any };\n/**\n * Evaluate the code snippet.\n *\n * Append it to virtual .ts file, compile, handle compiler errors, compute a diff of the JS, and eval any code that\n * appears as \"added\" in the diff.\n */\nfunction appendCompileAndEvalInput(options: {\n  service: Service;\n  state: EvalState;\n  input: string;\n  wrappedErr?: unknown;\n  /** Enable top-level await but only if the TSNode service allows it. */\n  enableTopLevelAwait?: boolean;\n  context: Context | undefined;\n  /**\n   * Added so that `evalCode` can be guaranteed *not* to trigger the `isCompletion`\n   * codepath.  However, the `isCompletion` logic is ancient and maybe should be removed entirely.\n   * Nobody's looked at it in a long time.\n   */\n  overrideIsCompletion?: boolean;\n}): AppendCompileAndEvalInputResult {\n  const {\n    service,\n    state,\n    wrappedErr,\n    enableTopLevelAwait = false,\n    context,\n    overrideIsCompletion,\n  } = options;\n  let { input } = options;\n\n  // It's confusing for `{ a: 1 }` to be interpreted as a block statement\n  // rather than an object literal. So, we first try to wrap it in\n  // parentheses, so that it will be interpreted as an expression.\n  // Based on https://github.com/nodejs/node/blob/c2e6822153bad023ab7ebd30a6117dcc049e475c/lib/repl.js#L413-L422\n  let wrappedCmd = false;\n  if (!wrappedErr && /^\\s*{/.test(input) && !/;\\s*$/.test(input)) {\n    input = `(${input.trim()})\\n`;\n    wrappedCmd = true;\n  }\n\n  const lines = state.lines;\n  const isCompletion = overrideIsCompletion ?? !/\\n$/.test(input);\n  const undo = appendToEvalState(state, input);\n  let output: string;\n\n  // Based on https://github.com/nodejs/node/blob/92573721c7cff104ccb82b6ed3e8aa69c4b27510/lib/repl.js#L457-L461\n  function adjustUseStrict(code: string) {\n    // \"void 0\" keeps the repl from returning \"use strict\" as the result\n    // value for statements and declarations that don't return a value.\n    return code.replace(/^\"use strict\";/, '\"use strict\"; void 0;');\n  }\n\n  try {\n    output = service.compile(state.input, state.path, -lines);\n  } catch (err) {\n    undo();\n\n    if (wrappedCmd) {\n      if (err instanceof TSError && err.diagnosticCodes[0] === 2339) {\n        // Ensure consistent and more sane behavior between { a: 1 }['b'] and ({ a: 1 }['b'])\n        throw err;\n      }\n      // Unwrap and try again\n      return appendCompileAndEvalInput({\n        ...options,\n        wrappedErr: err,\n      });\n    }\n\n    if (wrappedErr) throw wrappedErr;\n    throw err;\n  }\n\n  output = adjustUseStrict(output);\n\n  // Note: REPL does not respect sourcemaps!\n  // To properly do that, we'd need to prefix the code we eval -- which comes\n  // from `diffLines` -- with newlines so that it's at the proper line numbers.\n  // Then we'd need to ensure each bit of eval-ed code, if there are multiples,\n  // has the sourcemap appended to it.\n  // We might also need to integrate with our sourcemap hooks' cache; I'm not sure.\n  const outputWithoutSourcemapComment = output.replace(sourcemapCommentRe, '');\n  const oldOutputWithoutSourcemapComment = state.output.replace(\n    sourcemapCommentRe,\n    ''\n  );\n\n  // Use `diff` to check for new JavaScript to execute.\n  const changes = getDiffLines()(\n    oldOutputWithoutSourcemapComment,\n    outputWithoutSourcemapComment\n  );\n\n  if (isCompletion) {\n    undo();\n  } else {\n    state.output = output;\n\n    // Insert a semicolon to make sure that the code doesn't interact with the next line,\n    // for example to prevent `2\\n+ 2` from producing 4.\n    // This is safe since the output will not change since we can only get here with successful inputs,\n    // and adding a semicolon to the end of a successful input won't ever change the output.\n    state.input = state.input.replace(\n      /([^\\n\\s])([\\n\\s]*)$/,\n      (all, lastChar, whitespace) => {\n        if (lastChar !== ';') return `${lastChar};${whitespace}`;\n        return all;\n      }\n    );\n  }\n\n  let commands: Array<{ mustAwait?: true; execCommand: () => any }> = [];\n  let containsTopLevelAwait = false;\n\n  // Build a list of \"commands\": bits of JS code in the diff that must be executed.\n  for (const change of changes) {\n    if (change.added) {\n      if (\n        enableTopLevelAwait &&\n        service.shouldReplAwait &&\n        change.value.indexOf('await') > -1\n      ) {\n        const processTopLevelAwait = getProcessTopLevelAwait();\n\n        // Newline prevents comments to mess with wrapper\n        const wrappedResult = processTopLevelAwait(change.value + '\\n');\n        if (wrappedResult !== null) {\n          containsTopLevelAwait = true;\n          commands.push({\n            mustAwait: true,\n            execCommand: () => runInContext(wrappedResult, state.path, context),\n          });\n          continue;\n        }\n      }\n      commands.push({\n        execCommand: () => runInContext(change.value, state.path, context),\n      });\n    }\n  }\n\n  // Execute all commands asynchronously if necessary, returning the result or a\n  // promise of the result.\n  if (containsTopLevelAwait) {\n    return {\n      containsTopLevelAwait,\n      valuePromise: (async () => {\n        let value;\n        for (const command of commands) {\n          const r = command.execCommand();\n          value = command.mustAwait ? await r : r;\n        }\n        return value;\n      })(),\n    };\n  } else {\n    return {\n      containsTopLevelAwait: false,\n      value: commands.reduce<any>((_, c) => c.execCommand(), undefined),\n    };\n  }\n}\n\n/**\n * Low-level execution of JS code in context\n */\nfunction runInContext(code: string, filename: string, context?: Context) {\n  const script = new Script(code, { filename });\n\n  if (context === undefined || context === global) {\n    return script.runInThisContext();\n  } else {\n    return script.runInContext(context);\n  }\n}\n\n/**\n * Append to the eval instance and return an undo function.\n */\nfunction appendToEvalState(state: EvalState, input: string) {\n  const undoInput = state.input;\n  const undoVersion = state.version;\n  const undoOutput = state.output;\n  const undoLines = state.lines;\n\n  state.input += input;\n  state.lines += lineCount(input);\n  state.version++;\n\n  return function () {\n    state.input = undoInput;\n    state.output = undoOutput;\n    state.version = undoVersion;\n    state.lines = undoLines;\n  };\n}\n\n/**\n * Count the number of lines.\n */\nfunction lineCount(value: string) {\n  let count = 0;\n\n  for (const char of value) {\n    if (char === '\\n') {\n      count++;\n    }\n  }\n\n  return count;\n}\n\n/**\n * TS diagnostic codes which are recoverable, meaning that the user likely entered an incomplete line of code\n * and should be prompted for the next.  For example, starting a multi-line for() loop and not finishing it.\n * null value means code is always recoverable.  `Set` means code is only recoverable when occurring alongside at least one\n * of the other codes.\n */\nconst RECOVERY_CODES: Map<number, Set<number> | null> = new Map([\n  [1003, null], // \"Identifier expected.\"\n  [1005, null], // \"')' expected.\", \"'}' expected.\"\n  [1109, null], // \"Expression expected.\"\n  [1126, null], // \"Unexpected end of text.\"\n  [\n    1136, // \"Property assignment expected.\"\n    new Set([1005]), // happens when typing out an object literal or block scope across multiple lines: '{ foo: 123,'\n  ],\n  [1160, null], // \"Unterminated template literal.\"\n  [1161, null], // \"Unterminated regular expression literal.\"\n  [2355, null], // \"A function whose declared type is neither 'void' nor 'any' must return a value.\"\n  [2391, null], // \"Function implementation is missing or not immediately following the declaration.\"\n  [\n    7010, // \"Function, which lacks return-type annotation, implicitly has an 'any' return type.\"\n    new Set([1005]), // happens when fn signature spread across multiple lines: 'function a(\\nb: any\\n) {'\n  ],\n]);\n\n/**\n * Diagnostic codes raised when using top-level await.\n * These are suppressed when top-level await is enabled.\n * When it is *not* enabled, these trigger a helpful hint about enabling top-level await.\n */\nconst topLevelAwaitDiagnosticCodes = [\n  1375, // 'await' expressions are only allowed at the top level of a file when that file is a module, but this file has no imports or exports. Consider adding an empty 'export {}' to make this file a module.\n  1378, // Top-level 'await' expressions are only allowed when the 'module' option is set to 'esnext' or 'system', and the 'target' option is set to 'es2017' or higher.\n  1431, // 'for await' loops are only allowed at the top level of a file when that file is a module, but this file has no imports or exports. Consider adding an empty 'export {}' to make this file a module.\n  1432, // Top-level 'for await' loops are only allowed when the 'module' option is set to 'esnext' or 'system', and the 'target' option is set to 'es2017' or higher.\n];\n\n/**\n * Check if a function can recover gracefully.\n */\nfunction isRecoverable(error: TSError) {\n  return error.diagnosticCodes.every((code) => {\n    const deps = RECOVERY_CODES.get(code);\n    return (\n      deps === null ||\n      (deps && error.diagnosticCodes.some((code) => deps.has(code)))\n    );\n  });\n}\n\n/**\n * @internal\n * Set properties on `context` before eval-ing [stdin] or [eval] input.\n */\nexport function setupContext(\n  context: any,\n  module: Module,\n  filenameAndDirname: 'eval' | 'stdin' | null\n) {\n  if (filenameAndDirname) {\n    context.__dirname = '.';\n    context.__filename = `[${filenameAndDirname}]`;\n  }\n  context.module = module;\n  context.exports = module.exports;\n  context.require = module.require.bind(module);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}