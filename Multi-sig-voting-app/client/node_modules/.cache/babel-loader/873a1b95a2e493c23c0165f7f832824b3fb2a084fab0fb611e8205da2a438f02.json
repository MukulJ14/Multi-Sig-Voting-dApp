{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createModuleTypeClassifier = void 0;\nconst ts_internals_1 = require(\"./ts-internals\");\nconst util_1 = require(\"./util\");\n/**\n * @internal\n * May receive non-normalized options -- basePath and patterns -- and will normalize them\n * internally.\n * However, calls to `classifyModule` must pass pre-normalized paths!\n */\nfunction createModuleTypeClassifier(options) {\n  const {\n    patterns,\n    basePath: _basePath\n  } = options;\n  const basePath = _basePath !== undefined ? (0, util_1.normalizeSlashes)(_basePath).replace(/\\/$/, '') : undefined;\n  const patternTypePairs = Object.entries(patterns !== null && patterns !== void 0 ? patterns : []).map(([_pattern, type]) => {\n    const pattern = (0, util_1.normalizeSlashes)(_pattern);\n    return {\n      pattern: parsePattern(basePath, pattern),\n      type\n    };\n  });\n  const classifications = {\n    package: {\n      moduleType: 'auto'\n    },\n    cjs: {\n      moduleType: 'cjs'\n    },\n    esm: {\n      moduleType: 'esm'\n    }\n  };\n  const auto = classifications.package;\n  // Passed path must be normalized!\n  function classifyModuleNonCached(path) {\n    const matched = matchPatterns(patternTypePairs, _ => _.pattern, path);\n    if (matched) return classifications[matched.type];\n    return auto;\n  }\n  const classifyModule = (0, util_1.cachedLookup)(classifyModuleNonCached);\n  function classifyModuleAuto(path) {\n    return auto;\n  }\n  return {\n    classifyModuleByModuleTypeOverrides: patternTypePairs.length ? classifyModule : classifyModuleAuto\n  };\n}\nexports.createModuleTypeClassifier = createModuleTypeClassifier;\nfunction parsePattern(basePath, patternString) {\n  const pattern = (0, ts_internals_1.getPatternFromSpec)(patternString, basePath);\n  return pattern !== undefined ? new RegExp(pattern) : /(?:)/;\n}\nfunction matchPatterns(objects, getPattern, candidate) {\n  for (let i = objects.length - 1; i >= 0; i--) {\n    const object = objects[i];\n    const pattern = getPattern(object);\n    if (pattern === null || pattern === void 0 ? void 0 : pattern.test(candidate)) {\n      return object;\n    }\n  }\n}","map":{"version":3,"names":["ts_internals_1","require","util_1","createModuleTypeClassifier","options","patterns","basePath","_basePath","undefined","normalizeSlashes","replace","patternTypePairs","Object","entries","map","_pattern","type","pattern","parsePattern","classifications","package","moduleType","cjs","esm","auto","classifyModuleNonCached","path","matched","matchPatterns","_","classifyModule","cachedLookup","classifyModuleAuto","classifyModuleByModuleTypeOverrides","length","exports","patternString","getPatternFromSpec","RegExp","objects","getPattern","candidate","i","object","test"],"sources":["/Users/mukuljindal/Local/projects/fuckingwork/node_modules/ts-node/src/module-type-classifier.ts"],"sourcesContent":["import type { ModuleTypeOverride, ModuleTypes } from '.';\nimport { getPatternFromSpec } from './ts-internals';\nimport { cachedLookup, normalizeSlashes } from './util';\n\n// Logic to support our `moduleTypes` option, which allows overriding node's default ESM / CJS\n// classification of `.js` files based on package.json `type` field.\n\n/**\n * Seperate internal type because `auto` is clearer than `package`, but changing\n * the public API is a breaking change.\n * @internal\n */\nexport type InternalModuleTypeOverride = 'cjs' | 'esm' | 'auto';\n/** @internal */\nexport interface ModuleTypeClassification {\n  moduleType: InternalModuleTypeOverride;\n}\n/** @internal */\nexport interface ModuleTypeClassifierOptions {\n  basePath?: string;\n  patterns?: ModuleTypes;\n}\n/** @internal */\nexport type ModuleTypeClassifier = ReturnType<\n  typeof createModuleTypeClassifier\n>;\n/**\n * @internal\n * May receive non-normalized options -- basePath and patterns -- and will normalize them\n * internally.\n * However, calls to `classifyModule` must pass pre-normalized paths!\n */\nexport function createModuleTypeClassifier(\n  options: ModuleTypeClassifierOptions\n) {\n  const { patterns, basePath: _basePath } = options;\n  const basePath =\n    _basePath !== undefined\n      ? normalizeSlashes(_basePath).replace(/\\/$/, '')\n      : undefined;\n\n  const patternTypePairs = Object.entries(patterns ?? []).map(\n    ([_pattern, type]) => {\n      const pattern = normalizeSlashes(_pattern);\n      return { pattern: parsePattern(basePath!, pattern), type };\n    }\n  );\n\n  const classifications: Record<ModuleTypeOverride, ModuleTypeClassification> =\n    {\n      package: {\n        moduleType: 'auto',\n      },\n      cjs: {\n        moduleType: 'cjs',\n      },\n      esm: {\n        moduleType: 'esm',\n      },\n    };\n  const auto = classifications.package;\n\n  // Passed path must be normalized!\n  function classifyModuleNonCached(path: string): ModuleTypeClassification {\n    const matched = matchPatterns(patternTypePairs, (_) => _.pattern, path);\n    if (matched) return classifications[matched.type];\n    return auto;\n  }\n\n  const classifyModule = cachedLookup(classifyModuleNonCached);\n\n  function classifyModuleAuto(path: String) {\n    return auto;\n  }\n\n  return {\n    classifyModuleByModuleTypeOverrides: patternTypePairs.length\n      ? classifyModule\n      : classifyModuleAuto,\n  };\n}\n\nfunction parsePattern(basePath: string, patternString: string): RegExp {\n  const pattern = getPatternFromSpec(patternString, basePath);\n  return pattern !== undefined ? new RegExp(pattern) : /(?:)/;\n}\n\nfunction matchPatterns<T>(\n  objects: T[],\n  getPattern: (t: T) => RegExp,\n  candidate: string\n): T | undefined {\n  for (let i = objects.length - 1; i >= 0; i--) {\n    const object = objects[i];\n    const pattern = getPattern(object);\n\n    if (pattern?.test(candidate)) {\n      return object;\n    }\n  }\n}\n"],"mappings":";;;;;;AACA,MAAAA,cAAA,GAAAC,OAAA;AACA,MAAAC,MAAA,GAAAD,OAAA;AAwBA;;;;;;AAMA,SAAgBE,0BAA0BA,CACxCC,OAAoC;EAEpC,MAAM;IAAEC,QAAQ;IAAEC,QAAQ,EAAEC;EAAS,CAAE,GAAGH,OAAO;EACjD,MAAME,QAAQ,GACZC,SAAS,KAAKC,SAAS,GACnB,IAAAN,MAAA,CAAAO,gBAAgB,EAACF,SAAS,CAAC,CAACG,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,GAC9CF,SAAS;EAEf,MAAMG,gBAAgB,GAAGC,MAAM,CAACC,OAAO,CAACR,QAAQ,aAARA,QAAQ,cAARA,QAAQ,GAAI,EAAE,CAAC,CAACS,GAAG,CACzD,CAAC,CAACC,QAAQ,EAAEC,IAAI,CAAC,KAAI;IACnB,MAAMC,OAAO,GAAG,IAAAf,MAAA,CAAAO,gBAAgB,EAACM,QAAQ,CAAC;IAC1C,OAAO;MAAEE,OAAO,EAAEC,YAAY,CAACZ,QAAS,EAAEW,OAAO,CAAC;MAAED;IAAI,CAAE;EAC5D,CAAC,CACF;EAED,MAAMG,eAAe,GACnB;IACEC,OAAO,EAAE;MACPC,UAAU,EAAE;KACb;IACDC,GAAG,EAAE;MACHD,UAAU,EAAE;KACb;IACDE,GAAG,EAAE;MACHF,UAAU,EAAE;;GAEf;EACH,MAAMG,IAAI,GAAGL,eAAe,CAACC,OAAO;EAEpC;EACA,SAASK,uBAAuBA,CAACC,IAAY;IAC3C,MAAMC,OAAO,GAAGC,aAAa,CAACjB,gBAAgB,EAAGkB,CAAC,IAAKA,CAAC,CAACZ,OAAO,EAAES,IAAI,CAAC;IACvE,IAAIC,OAAO,EAAE,OAAOR,eAAe,CAACQ,OAAO,CAACX,IAAI,CAAC;IACjD,OAAOQ,IAAI;EACb;EAEA,MAAMM,cAAc,GAAG,IAAA5B,MAAA,CAAA6B,YAAY,EAACN,uBAAuB,CAAC;EAE5D,SAASO,kBAAkBA,CAACN,IAAY;IACtC,OAAOF,IAAI;EACb;EAEA,OAAO;IACLS,mCAAmC,EAAEtB,gBAAgB,CAACuB,MAAM,GACxDJ,cAAc,GACdE;GACL;AACH;AAhDAG,OAAA,CAAAhC,0BAAA,GAAAA,0BAAA;AAkDA,SAASe,YAAYA,CAACZ,QAAgB,EAAE8B,aAAqB;EAC3D,MAAMnB,OAAO,GAAG,IAAAjB,cAAA,CAAAqC,kBAAkB,EAACD,aAAa,EAAE9B,QAAQ,CAAC;EAC3D,OAAOW,OAAO,KAAKT,SAAS,GAAG,IAAI8B,MAAM,CAACrB,OAAO,CAAC,GAAG,MAAM;AAC7D;AAEA,SAASW,aAAaA,CACpBW,OAAY,EACZC,UAA4B,EAC5BC,SAAiB;EAEjB,KAAK,IAAIC,CAAC,GAAGH,OAAO,CAACL,MAAM,GAAG,CAAC,EAAEQ,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;IAC5C,MAAMC,MAAM,GAAGJ,OAAO,CAACG,CAAC,CAAC;IACzB,MAAMzB,OAAO,GAAGuB,UAAU,CAACG,MAAM,CAAC;IAElC,IAAI1B,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAE2B,IAAI,CAACH,SAAS,CAAC,EAAE;MAC5B,OAAOE,MAAM;;;AAGnB"},"metadata":{},"sourceType":"script","externalDependencies":[]}