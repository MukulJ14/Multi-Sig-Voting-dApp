{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.treePostProcessFromProofNode = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\n/** Duplicated partial declaration to break circular dependency with CompositeType */\nfunction isCompositeType(type) {\n  return !type.isBasic;\n}\n/**\n * Navigates and mutates nodes to post process a tree created with `Tree.createFromProof`.\n * Tree returns regular a tree with only BranchNode and LeafNode instances. However, SSZ features\n * non-standard nodes that make proofs for those types to be un-usable. This include:\n * - BranchNodeStruct: Must contain complete data `tree_fromProofNode` transforms a BranchNode and\n *   all of its data into a single BranchNodeStruct instance.\n *\n * @param bitstring Bitstring without the leading \"1\", since it's only used to compute horizontal indexes.\n */\nfunction treePostProcessFromProofNode(node, type, bitstring = \"\", currentDepth = 0) {\n  // Must run tree_fromProofNode on the first received node (i.e. Validator object)\n  if (currentDepth === 0) {\n    const nodePost = type.tree_fromProofNode(node);\n    if (nodePost.done) {\n      return nodePost.node;\n    } else {\n      node = nodePost.node;\n    }\n  }\n  const atTypeDepth = type.depth === currentDepth;\n  if (node.isLeaf()) {\n    if (atTypeDepth) {\n      const jsonPathProp = type.getIndexProperty(bitstringToIndex(bitstring));\n      if (jsonPathProp === null) {\n        // bitstring is out of bounds, witness node\n        return node;\n      }\n      const childType = type.getPropertyType(jsonPathProp);\n      // If this type merkleized fits in a single chunk then this LeafNode includes all data\n      if (childType.maxChunkCount === 1 && isCompositeType(childType)) {\n        return childType.tree_fromProofNode(node).node;\n      }\n      // Witness node\n      else {\n        return node;\n      }\n    }\n    // LeafNode not at type depth is a witness or a length / selector nodes\n    else {\n      return node;\n    }\n  } else {\n    if (atTypeDepth) {\n      const jsonPathProp = type.getIndexProperty(bitstringToIndex(bitstring));\n      if (jsonPathProp === null) {\n        // bitstring is out of bounds, witness node\n        return node;\n      }\n      const childType = type.getPropertyType(jsonPathProp);\n      if (!isCompositeType(childType)) {\n        throw Error(\"BranchNode does not map to CompositeType\");\n      }\n      const nodePost = childType.tree_fromProofNode(node);\n      // If tree_fromProofNode is the identity function, keep going, otherwise stop navigating\n      if (nodePost.done) {\n        return nodePost.node;\n      } else {\n        return treePostProcessFromProofNode(nodePost.node, childType);\n      }\n    }\n    // BranchNode at not type depth, keep navigating\n    else {\n      const leftNode = treePostProcessFromProofNode(node.left, type, bitstring + \"0\", currentDepth + 1);\n      const rightNode = treePostProcessFromProofNode(node.right, type, bitstring + \"1\", currentDepth + 1);\n      if (leftNode === node.left && rightNode === node.right) {\n        return node;\n      } else {\n        return new persistent_merkle_tree_1.BranchNode(leftNode, rightNode);\n      }\n    }\n  }\n}\nexports.treePostProcessFromProofNode = treePostProcessFromProofNode;\n/** Return the node horizontal index given a bitstring without the leading \"1\" */\nfunction bitstringToIndex(bitstring) {\n  if (bitstring === \"\") return 0;\n  return parseInt(bitstring, 2);\n}","map":{"version":3,"names":["persistent_merkle_tree_1","require","isCompositeType","type","isBasic","treePostProcessFromProofNode","node","bitstring","currentDepth","nodePost","tree_fromProofNode","done","atTypeDepth","depth","isLeaf","jsonPathProp","getIndexProperty","bitstringToIndex","childType","getPropertyType","maxChunkCount","Error","leftNode","left","rightNode","right","BranchNode","exports","parseInt"],"sources":["../../../src/util/proof/treePostProcessFromProofNode.ts"],"sourcesContent":[null],"mappings":";;;;;;AAAA,MAAAA,wBAAA,GAAAC,OAAA;AAuBA;AACA,SAASC,eAAeA,CAACC,IAAU;EACjC,OAAO,CAACA,IAAI,CAACC,OAAO;AACtB;AAEA;;;;;;;;;AASA,SAAgBC,4BAA4BA,CAACC,IAAU,EAAEH,IAAmB,EAAEI,SAAS,GAAG,EAAE,EAAEC,YAAY,GAAG,CAAC;EAC5G;EACA,IAAIA,YAAY,KAAK,CAAC,EAAE;IACtB,MAAMC,QAAQ,GAAGN,IAAI,CAACO,kBAAkB,CAACJ,IAAI,CAAC;IAC9C,IAAIG,QAAQ,CAACE,IAAI,EAAE;MACjB,OAAOF,QAAQ,CAACH,IAAI;KACrB,MAAM;MACLA,IAAI,GAAGG,QAAQ,CAACH,IAAI;;;EAIxB,MAAMM,WAAW,GAAGT,IAAI,CAACU,KAAK,KAAKL,YAAY;EAE/C,IAAIF,IAAI,CAACQ,MAAM,EAAE,EAAE;IACjB,IAAIF,WAAW,EAAE;MACf,MAAMG,YAAY,GAAGZ,IAAI,CAACa,gBAAgB,CAACC,gBAAgB,CAACV,SAAS,CAAC,CAAC;MACvE,IAAIQ,YAAY,KAAK,IAAI,EAAE;QACzB;QACA,OAAOT,IAAI;;MAGb,MAAMY,SAAS,GAAGf,IAAI,CAACgB,eAAe,CAACJ,YAAY,CAAC;MAEpD;MACA,IAAIG,SAAS,CAACE,aAAa,KAAK,CAAC,IAAIlB,eAAe,CAACgB,SAAS,CAAC,EAAE;QAC/D,OAAOA,SAAS,CAACR,kBAAkB,CAACJ,IAAI,CAAC,CAACA,IAAI;;MAEhD;MAAA,KACK;QACH,OAAOA,IAAI;;;IAIf;IAAA,KACK;MACH,OAAOA,IAAI;;GAEd,MAAM;IACL,IAAIM,WAAW,EAAE;MACf,MAAMG,YAAY,GAAGZ,IAAI,CAACa,gBAAgB,CAACC,gBAAgB,CAACV,SAAS,CAAC,CAAC;MACvE,IAAIQ,YAAY,KAAK,IAAI,EAAE;QACzB;QACA,OAAOT,IAAI;;MAGb,MAAMY,SAAS,GAAGf,IAAI,CAACgB,eAAe,CAACJ,YAAY,CAAC;MAEpD,IAAI,CAACb,eAAe,CAACgB,SAAS,CAAC,EAAE;QAC/B,MAAMG,KAAK,CAAC,0CAA0C,CAAC;;MAGzD,MAAMZ,QAAQ,GAAGS,SAAS,CAACR,kBAAkB,CAACJ,IAAI,CAAC;MAEnD;MACA,IAAIG,QAAQ,CAACE,IAAI,EAAE;QACjB,OAAOF,QAAQ,CAACH,IAAI;OACrB,MAAM;QACL,OAAOD,4BAA4B,CAACI,QAAQ,CAACH,IAAI,EAAEY,SAAS,CAAC;;;IAIjE;IAAA,KACK;MACH,MAAMI,QAAQ,GAAGjB,4BAA4B,CAACC,IAAI,CAACiB,IAAI,EAAEpB,IAAI,EAAEI,SAAS,GAAG,GAAG,EAAEC,YAAY,GAAG,CAAC,CAAC;MACjG,MAAMgB,SAAS,GAAGnB,4BAA4B,CAACC,IAAI,CAACmB,KAAK,EAAEtB,IAAI,EAAEI,SAAS,GAAG,GAAG,EAAEC,YAAY,GAAG,CAAC,CAAC;MAEnG,IAAIc,QAAQ,KAAKhB,IAAI,CAACiB,IAAI,IAAIC,SAAS,KAAKlB,IAAI,CAACmB,KAAK,EAAE;QACtD,OAAOnB,IAAI;OACZ,MAAM;QACL,OAAO,IAAIN,wBAAA,CAAA0B,UAAU,CAACJ,QAAQ,EAAEE,SAAS,CAAC;;;;AAIlD;AAzEAG,OAAA,CAAAtB,4BAAA,GAAAA,4BAAA;AA2EA;AACA,SAASY,gBAAgBA,CAACV,SAAiB;EACzC,IAAIA,SAAS,KAAK,EAAE,EAAE,OAAO,CAAC;EAC9B,OAAOqB,QAAQ,CAACrB,SAAS,EAAE,CAAC,CAAC;AAC/B"},"metadata":{},"sourceType":"script","externalDependencies":[]}