{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getPatternFromSpec = exports.createTsInternals = void 0;\nconst path_1 = require(\"path\");\nconst util_1 = require(\"./util\");\n/** @internal */\nexports.createTsInternals = (0, util_1.cachedLookup)(createTsInternalsUncached);\n/**\n * Given a reference to the TS compiler, return some TS internal functions that we\n * could not or did not want to grab off the `ts` object.\n * These have been copy-pasted from TS's source and tweaked as necessary.\n *\n * NOTE: This factory returns *only* functions which need a reference to the TS\n * compiler.  Other functions do not need a reference to the TS compiler so are\n * exported directly from this file.\n */\nfunction createTsInternalsUncached(_ts) {\n  const ts = _ts;\n  /**\n   * Copied from:\n   * https://github.com/microsoft/TypeScript/blob/v4.3.2/src/compiler/commandLineParser.ts#L2821-L2846\n   */\n  function getExtendsConfigPath(extendedConfig, host, basePath, errors, createDiagnostic) {\n    extendedConfig = (0, util_1.normalizeSlashes)(extendedConfig);\n    if (isRootedDiskPath(extendedConfig) || startsWith(extendedConfig, './') || startsWith(extendedConfig, '../')) {\n      let extendedConfigPath = getNormalizedAbsolutePath(extendedConfig, basePath);\n      if (!host.fileExists(extendedConfigPath) && !endsWith(extendedConfigPath, ts.Extension.Json)) {\n        extendedConfigPath = `${extendedConfigPath}.json`;\n        if (!host.fileExists(extendedConfigPath)) {\n          errors.push(createDiagnostic(ts.Diagnostics.File_0_not_found, extendedConfig));\n          return undefined;\n        }\n      }\n      return extendedConfigPath;\n    }\n    // If the path isn't a rooted or relative path, resolve like a module\n    const resolved = ts.nodeModuleNameResolver(extendedConfig, combinePaths(basePath, 'tsconfig.json'), {\n      moduleResolution: ts.ModuleResolutionKind.NodeJs\n    }, host, /*cache*/undefined, /*projectRefs*/undefined, /*lookupConfig*/true);\n    if (resolved.resolvedModule) {\n      return resolved.resolvedModule.resolvedFileName;\n    }\n    errors.push(createDiagnostic(ts.Diagnostics.File_0_not_found, extendedConfig));\n    return undefined;\n  }\n  return {\n    getExtendsConfigPath\n  };\n}\n// These functions have alternative implementation to avoid copying too much from TS\nfunction isRootedDiskPath(path) {\n  return (0, path_1.isAbsolute)(path);\n}\nfunction combinePaths(path, ...paths) {\n  return (0, util_1.normalizeSlashes)((0, path_1.resolve)(path, ...paths.filter(path => path)));\n}\nfunction getNormalizedAbsolutePath(fileName, currentDirectory) {\n  return (0, util_1.normalizeSlashes)(currentDirectory != null ? (0, path_1.resolve)(currentDirectory, fileName) : (0, path_1.resolve)(fileName));\n}\nfunction startsWith(str, prefix) {\n  return str.lastIndexOf(prefix, 0) === 0;\n}\nfunction endsWith(str, suffix) {\n  const expectedPos = str.length - suffix.length;\n  return expectedPos >= 0 && str.indexOf(suffix, expectedPos) === expectedPos;\n}\n// Reserved characters, forces escaping of any non-word (or digit), non-whitespace character.\n// It may be inefficient (we could just match (/[-[\\]{}()*+?.,\\\\^$|#\\s]/g), but this is future\n// proof.\nconst reservedCharacterPattern = /[^\\w\\s\\/]/g;\n/**\n * @internal\n * See also: getRegularExpressionForWildcard, which seems to do almost the same thing\n */\nfunction getPatternFromSpec(spec, basePath) {\n  const pattern = spec && getSubPatternFromSpec(spec, basePath, excludeMatcher);\n  return pattern && `^(${pattern})${'($|/)'}`;\n}\nexports.getPatternFromSpec = getPatternFromSpec;\nfunction getSubPatternFromSpec(spec, basePath, {\n  singleAsteriskRegexFragment,\n  doubleAsteriskRegexFragment,\n  replaceWildcardCharacter\n}) {\n  let subpattern = '';\n  let hasWrittenComponent = false;\n  const components = getNormalizedPathComponents(spec, basePath);\n  const lastComponent = last(components);\n  // getNormalizedPathComponents includes the separator for the root component.\n  // We need to remove to create our regex correctly.\n  components[0] = removeTrailingDirectorySeparator(components[0]);\n  if (isImplicitGlob(lastComponent)) {\n    components.push('**', '*');\n  }\n  let optionalCount = 0;\n  for (let component of components) {\n    if (component === '**') {\n      subpattern += doubleAsteriskRegexFragment;\n    } else {\n      if (hasWrittenComponent) {\n        subpattern += directorySeparator;\n      }\n      subpattern += component.replace(reservedCharacterPattern, replaceWildcardCharacter);\n    }\n    hasWrittenComponent = true;\n  }\n  while (optionalCount > 0) {\n    subpattern += ')?';\n    optionalCount--;\n  }\n  return subpattern;\n}\nconst directoriesMatcher = {\n  singleAsteriskRegexFragment: '[^/]*',\n  /**\n   * Regex for the ** wildcard. Matches any num of subdirectories. When used for including\n   * files or directories, does not match subdirectories that start with a . character\n   */\n  doubleAsteriskRegexFragment: `(/[^/.][^/]*)*?`,\n  replaceWildcardCharacter: match => replaceWildcardCharacter(match, directoriesMatcher.singleAsteriskRegexFragment)\n};\nconst excludeMatcher = {\n  singleAsteriskRegexFragment: '[^/]*',\n  doubleAsteriskRegexFragment: '(/.+?)?',\n  replaceWildcardCharacter: match => replaceWildcardCharacter(match, excludeMatcher.singleAsteriskRegexFragment)\n};\nfunction getNormalizedPathComponents(path, currentDirectory) {\n  return reducePathComponents(getPathComponents(path, currentDirectory));\n}\nfunction getPathComponents(path, currentDirectory = '') {\n  path = combinePaths(currentDirectory, path);\n  return pathComponents(path, getRootLength(path));\n}\nfunction reducePathComponents(components) {\n  if (!some(components)) return [];\n  const reduced = [components[0]];\n  for (let i = 1; i < components.length; i++) {\n    const component = components[i];\n    if (!component) continue;\n    if (component === '.') continue;\n    if (component === '..') {\n      if (reduced.length > 1) {\n        if (reduced[reduced.length - 1] !== '..') {\n          reduced.pop();\n          continue;\n        }\n      } else if (reduced[0]) continue;\n    }\n    reduced.push(component);\n  }\n  return reduced;\n}\nfunction getRootLength(path) {\n  const rootLength = getEncodedRootLength(path);\n  return rootLength < 0 ? ~rootLength : rootLength;\n}\nfunction getEncodedRootLength(path) {\n  if (!path) return 0;\n  const ch0 = path.charCodeAt(0);\n  // POSIX or UNC\n  if (ch0 === 47 /* CharacterCodes.slash */ || ch0 === 92 /* CharacterCodes.backslash */) {\n    if (path.charCodeAt(1) !== ch0) return 1; // POSIX: \"/\" (or non-normalized \"\\\")\n    const p1 = path.indexOf(ch0 === 47 /* CharacterCodes.slash */ ? directorySeparator : altDirectorySeparator, 2);\n    if (p1 < 0) return path.length; // UNC: \"//server\" or \"\\\\server\"\n    return p1 + 1; // UNC: \"//server/\" or \"\\\\server\\\"\n  }\n  // DOS\n  if (isVolumeCharacter(ch0) && path.charCodeAt(1) === 58 /* CharacterCodes.colon */) {\n    const ch2 = path.charCodeAt(2);\n    if (ch2 === 47 /* CharacterCodes.slash */ || ch2 === 92 /* CharacterCodes.backslash */) return 3; // DOS: \"c:/\" or \"c:\\\"\n    if (path.length === 2) return 2; // DOS: \"c:\" (but not \"c:d\")\n  }\n  // URL\n  const schemeEnd = path.indexOf(urlSchemeSeparator);\n  if (schemeEnd !== -1) {\n    const authorityStart = schemeEnd + urlSchemeSeparator.length;\n    const authorityEnd = path.indexOf(directorySeparator, authorityStart);\n    if (authorityEnd !== -1) {\n      // URL: \"file:///\", \"file://server/\", \"file://server/path\"\n      // For local \"file\" URLs, include the leading DOS volume (if present).\n      // Per https://www.ietf.org/rfc/rfc1738.txt, a host of \"\" or \"localhost\" is a\n      // special case interpreted as \"the machine from which the URL is being interpreted\".\n      const scheme = path.slice(0, schemeEnd);\n      const authority = path.slice(authorityStart, authorityEnd);\n      if (scheme === 'file' && (authority === '' || authority === 'localhost') && isVolumeCharacter(path.charCodeAt(authorityEnd + 1))) {\n        const volumeSeparatorEnd = getFileUrlVolumeSeparatorEnd(path, authorityEnd + 2);\n        if (volumeSeparatorEnd !== -1) {\n          if (path.charCodeAt(volumeSeparatorEnd) === 47 /* CharacterCodes.slash */) {\n            // URL: \"file:///c:/\", \"file://localhost/c:/\", \"file:///c%3a/\", \"file://localhost/c%3a/\"\n            return ~(volumeSeparatorEnd + 1);\n          }\n          if (volumeSeparatorEnd === path.length) {\n            // URL: \"file:///c:\", \"file://localhost/c:\", \"file:///c$3a\", \"file://localhost/c%3a\"\n            // but not \"file:///c:d\" or \"file:///c%3ad\"\n            return ~volumeSeparatorEnd;\n          }\n        }\n      }\n      return ~(authorityEnd + 1); // URL: \"file://server/\", \"http://server/\"\n    }\n\n    return ~path.length; // URL: \"file://server\", \"http://server\"\n  }\n  // relative\n  return 0;\n}\nfunction ensureTrailingDirectorySeparator(path) {\n  if (!hasTrailingDirectorySeparator(path)) {\n    return path + directorySeparator;\n  }\n  return path;\n}\nfunction hasTrailingDirectorySeparator(path) {\n  return path.length > 0 && isAnyDirectorySeparator(path.charCodeAt(path.length - 1));\n}\nfunction isAnyDirectorySeparator(charCode) {\n  return charCode === 47 /* CharacterCodes.slash */ || charCode === 92 /* CharacterCodes.backslash */;\n}\n\nfunction removeTrailingDirectorySeparator(path) {\n  if (hasTrailingDirectorySeparator(path)) {\n    return path.substr(0, path.length - 1);\n  }\n  return path;\n}\nconst directorySeparator = '/';\nconst altDirectorySeparator = '\\\\';\nconst urlSchemeSeparator = '://';\nfunction isVolumeCharacter(charCode) {\n  return charCode >= 97 /* CharacterCodes.a */ && charCode <= 122 /* CharacterCodes.z */ || charCode >= 65 /* CharacterCodes.A */ && charCode <= 90 /* CharacterCodes.Z */;\n}\n\nfunction getFileUrlVolumeSeparatorEnd(url, start) {\n  const ch0 = url.charCodeAt(start);\n  if (ch0 === 58 /* CharacterCodes.colon */) return start + 1;\n  if (ch0 === 37 /* CharacterCodes.percent */ && url.charCodeAt(start + 1) === 51 /* CharacterCodes._3 */) {\n    const ch2 = url.charCodeAt(start + 2);\n    if (ch2 === 97 /* CharacterCodes.a */ || ch2 === 65 /* CharacterCodes.A */) return start + 3;\n  }\n  return -1;\n}\nfunction some(array, predicate) {\n  if (array) {\n    if (predicate) {\n      for (const v of array) {\n        if (predicate(v)) {\n          return true;\n        }\n      }\n    } else {\n      return array.length > 0;\n    }\n  }\n  return false;\n}\nfunction pathComponents(path, rootLength) {\n  const root = path.substring(0, rootLength);\n  const rest = path.substring(rootLength).split(directorySeparator);\n  if (rest.length && !lastOrUndefined(rest)) rest.pop();\n  return [root, ...rest];\n}\nfunction lastOrUndefined(array) {\n  return array.length === 0 ? undefined : array[array.length - 1];\n}\nfunction last(array) {\n  // Debug.assert(array.length !== 0);\n  return array[array.length - 1];\n}\nfunction replaceWildcardCharacter(match, singleAsteriskRegexFragment) {\n  return match === '*' ? singleAsteriskRegexFragment : match === '?' ? '[^/]' : '\\\\' + match;\n}\n/**\n * An \"includes\" path \"foo\" is implicitly a glob \"foo/** /*\" (without the space) if its last component has no extension,\n * and does not contain any glob characters itself.\n */\nfunction isImplicitGlob(lastPathComponent) {\n  return !/[.*?]/.test(lastPathComponent);\n}","map":{"version":3,"names":["path_1","require","util_1","exports","createTsInternals","cachedLookup","createTsInternalsUncached","_ts","ts","getExtendsConfigPath","extendedConfig","host","basePath","errors","createDiagnostic","normalizeSlashes","isRootedDiskPath","startsWith","extendedConfigPath","getNormalizedAbsolutePath","fileExists","endsWith","Extension","Json","push","Diagnostics","File_0_not_found","undefined","resolved","nodeModuleNameResolver","combinePaths","moduleResolution","ModuleResolutionKind","NodeJs","resolvedModule","resolvedFileName","path","isAbsolute","paths","resolve","filter","fileName","currentDirectory","str","prefix","lastIndexOf","suffix","expectedPos","length","indexOf","reservedCharacterPattern","getPatternFromSpec","spec","pattern","getSubPatternFromSpec","excludeMatcher","singleAsteriskRegexFragment","doubleAsteriskRegexFragment","replaceWildcardCharacter","subpattern","hasWrittenComponent","components","getNormalizedPathComponents","lastComponent","last","removeTrailingDirectorySeparator","isImplicitGlob","optionalCount","component","directorySeparator","replace","directoriesMatcher","match","reducePathComponents","getPathComponents","pathComponents","getRootLength","some","reduced","i","pop","rootLength","getEncodedRootLength","ch0","charCodeAt","p1","altDirectorySeparator","isVolumeCharacter","ch2","schemeEnd","urlSchemeSeparator","authorityStart","authorityEnd","scheme","slice","authority","volumeSeparatorEnd","getFileUrlVolumeSeparatorEnd","ensureTrailingDirectorySeparator","hasTrailingDirectorySeparator","isAnyDirectorySeparator","charCode","substr","url","start","array","predicate","v","root","substring","rest","split","lastOrUndefined","lastPathComponent","test"],"sources":["/Users/mukuljindal/Local/projects/fuckingwork/node_modules/ts-node/src/ts-internals.ts"],"sourcesContent":["import { isAbsolute, resolve } from 'path';\nimport { cachedLookup, normalizeSlashes } from './util';\nimport type * as _ts from 'typescript';\nimport type { TSCommon, TSInternal } from './ts-compiler-types';\n\n/** @internal */\nexport const createTsInternals = cachedLookup(createTsInternalsUncached);\n/**\n * Given a reference to the TS compiler, return some TS internal functions that we\n * could not or did not want to grab off the `ts` object.\n * These have been copy-pasted from TS's source and tweaked as necessary.\n *\n * NOTE: This factory returns *only* functions which need a reference to the TS\n * compiler.  Other functions do not need a reference to the TS compiler so are\n * exported directly from this file.\n */\nfunction createTsInternalsUncached(_ts: TSCommon) {\n  const ts = _ts as TSCommon & TSInternal;\n  /**\n   * Copied from:\n   * https://github.com/microsoft/TypeScript/blob/v4.3.2/src/compiler/commandLineParser.ts#L2821-L2846\n   */\n  function getExtendsConfigPath(\n    extendedConfig: string,\n    host: _ts.ParseConfigHost,\n    basePath: string,\n    errors: _ts.Push<_ts.Diagnostic>,\n    createDiagnostic: (\n      message: _ts.DiagnosticMessage,\n      arg1?: string\n    ) => _ts.Diagnostic\n  ) {\n    extendedConfig = normalizeSlashes(extendedConfig);\n    if (\n      isRootedDiskPath(extendedConfig) ||\n      startsWith(extendedConfig, './') ||\n      startsWith(extendedConfig, '../')\n    ) {\n      let extendedConfigPath = getNormalizedAbsolutePath(\n        extendedConfig,\n        basePath\n      );\n      if (\n        !host.fileExists(extendedConfigPath) &&\n        !endsWith(extendedConfigPath, ts.Extension.Json)\n      ) {\n        extendedConfigPath = `${extendedConfigPath}.json`;\n        if (!host.fileExists(extendedConfigPath)) {\n          errors.push(\n            createDiagnostic(ts.Diagnostics.File_0_not_found, extendedConfig)\n          );\n          return undefined;\n        }\n      }\n      return extendedConfigPath;\n    }\n    // If the path isn't a rooted or relative path, resolve like a module\n    const resolved = ts.nodeModuleNameResolver(\n      extendedConfig,\n      combinePaths(basePath, 'tsconfig.json'),\n      { moduleResolution: ts.ModuleResolutionKind.NodeJs },\n      host,\n      /*cache*/ undefined,\n      /*projectRefs*/ undefined,\n      /*lookupConfig*/ true\n    );\n    if (resolved.resolvedModule) {\n      return resolved.resolvedModule.resolvedFileName;\n    }\n    errors.push(\n      createDiagnostic(ts.Diagnostics.File_0_not_found, extendedConfig)\n    );\n    return undefined;\n  }\n\n  return { getExtendsConfigPath };\n}\n\n// These functions have alternative implementation to avoid copying too much from TS\nfunction isRootedDiskPath(path: string) {\n  return isAbsolute(path);\n}\nfunction combinePaths(path: string, ...paths: (string | undefined)[]): string {\n  return normalizeSlashes(\n    resolve(path, ...(paths.filter((path) => path) as string[]))\n  );\n}\nfunction getNormalizedAbsolutePath(\n  fileName: string,\n  currentDirectory: string | undefined\n) {\n  return normalizeSlashes(\n    currentDirectory != null\n      ? resolve(currentDirectory!, fileName)\n      : resolve(fileName)\n  );\n}\n\nfunction startsWith(str: string, prefix: string): boolean {\n  return str.lastIndexOf(prefix, 0) === 0;\n}\n\nfunction endsWith(str: string, suffix: string): boolean {\n  const expectedPos = str.length - suffix.length;\n  return expectedPos >= 0 && str.indexOf(suffix, expectedPos) === expectedPos;\n}\n// Reserved characters, forces escaping of any non-word (or digit), non-whitespace character.\n// It may be inefficient (we could just match (/[-[\\]{}()*+?.,\\\\^$|#\\s]/g), but this is future\n// proof.\nconst reservedCharacterPattern = /[^\\w\\s\\/]/g;\n\n/**\n * @internal\n * See also: getRegularExpressionForWildcard, which seems to do almost the same thing\n */\nexport function getPatternFromSpec(spec: string, basePath: string) {\n  const pattern = spec && getSubPatternFromSpec(spec, basePath, excludeMatcher);\n  return pattern && `^(${pattern})${'($|/)'}`;\n}\nfunction getSubPatternFromSpec(\n  spec: string,\n  basePath: string,\n  {\n    singleAsteriskRegexFragment,\n    doubleAsteriskRegexFragment,\n    replaceWildcardCharacter,\n  }: WildcardMatcher\n): string {\n  let subpattern = '';\n  let hasWrittenComponent = false;\n  const components = getNormalizedPathComponents(spec, basePath);\n  const lastComponent = last(components);\n\n  // getNormalizedPathComponents includes the separator for the root component.\n  // We need to remove to create our regex correctly.\n  components[0] = removeTrailingDirectorySeparator(components[0]);\n\n  if (isImplicitGlob(lastComponent)) {\n    components.push('**', '*');\n  }\n\n  let optionalCount = 0;\n  for (let component of components) {\n    if (component === '**') {\n      subpattern += doubleAsteriskRegexFragment;\n    } else {\n      if (hasWrittenComponent) {\n        subpattern += directorySeparator;\n      }\n      subpattern += component.replace(\n        reservedCharacterPattern,\n        replaceWildcardCharacter\n      );\n    }\n\n    hasWrittenComponent = true;\n  }\n\n  while (optionalCount > 0) {\n    subpattern += ')?';\n    optionalCount--;\n  }\n\n  return subpattern;\n}\ninterface WildcardMatcher {\n  singleAsteriskRegexFragment: string;\n  doubleAsteriskRegexFragment: string;\n  replaceWildcardCharacter: (match: string) => string;\n}\nconst directoriesMatcher: WildcardMatcher = {\n  singleAsteriskRegexFragment: '[^/]*',\n  /**\n   * Regex for the ** wildcard. Matches any num of subdirectories. When used for including\n   * files or directories, does not match subdirectories that start with a . character\n   */\n  doubleAsteriskRegexFragment: `(/[^/.][^/]*)*?`,\n  replaceWildcardCharacter: (match) =>\n    replaceWildcardCharacter(\n      match,\n      directoriesMatcher.singleAsteriskRegexFragment\n    ),\n};\nconst excludeMatcher: WildcardMatcher = {\n  singleAsteriskRegexFragment: '[^/]*',\n  doubleAsteriskRegexFragment: '(/.+?)?',\n  replaceWildcardCharacter: (match) =>\n    replaceWildcardCharacter(match, excludeMatcher.singleAsteriskRegexFragment),\n};\nfunction getNormalizedPathComponents(\n  path: string,\n  currentDirectory: string | undefined\n) {\n  return reducePathComponents(getPathComponents(path, currentDirectory));\n}\nfunction getPathComponents(path: string, currentDirectory = '') {\n  path = combinePaths(currentDirectory, path);\n  return pathComponents(path, getRootLength(path));\n}\nfunction reducePathComponents(components: readonly string[]) {\n  if (!some(components)) return [];\n  const reduced = [components[0]];\n  for (let i = 1; i < components.length; i++) {\n    const component = components[i];\n    if (!component) continue;\n    if (component === '.') continue;\n    if (component === '..') {\n      if (reduced.length > 1) {\n        if (reduced[reduced.length - 1] !== '..') {\n          reduced.pop();\n          continue;\n        }\n      } else if (reduced[0]) continue;\n    }\n    reduced.push(component);\n  }\n  return reduced;\n}\nfunction getRootLength(path: string) {\n  const rootLength = getEncodedRootLength(path);\n  return rootLength < 0 ? ~rootLength : rootLength;\n}\nfunction getEncodedRootLength(path: string): number {\n  if (!path) return 0;\n  const ch0 = path.charCodeAt(0);\n\n  // POSIX or UNC\n  if (ch0 === CharacterCodes.slash || ch0 === CharacterCodes.backslash) {\n    if (path.charCodeAt(1) !== ch0) return 1; // POSIX: \"/\" (or non-normalized \"\\\")\n\n    const p1 = path.indexOf(\n      ch0 === CharacterCodes.slash ? directorySeparator : altDirectorySeparator,\n      2\n    );\n    if (p1 < 0) return path.length; // UNC: \"//server\" or \"\\\\server\"\n\n    return p1 + 1; // UNC: \"//server/\" or \"\\\\server\\\"\n  }\n\n  // DOS\n  if (isVolumeCharacter(ch0) && path.charCodeAt(1) === CharacterCodes.colon) {\n    const ch2 = path.charCodeAt(2);\n    if (ch2 === CharacterCodes.slash || ch2 === CharacterCodes.backslash)\n      return 3; // DOS: \"c:/\" or \"c:\\\"\n    if (path.length === 2) return 2; // DOS: \"c:\" (but not \"c:d\")\n  }\n\n  // URL\n  const schemeEnd = path.indexOf(urlSchemeSeparator);\n  if (schemeEnd !== -1) {\n    const authorityStart = schemeEnd + urlSchemeSeparator.length;\n    const authorityEnd = path.indexOf(directorySeparator, authorityStart);\n    if (authorityEnd !== -1) {\n      // URL: \"file:///\", \"file://server/\", \"file://server/path\"\n      // For local \"file\" URLs, include the leading DOS volume (if present).\n      // Per https://www.ietf.org/rfc/rfc1738.txt, a host of \"\" or \"localhost\" is a\n      // special case interpreted as \"the machine from which the URL is being interpreted\".\n      const scheme = path.slice(0, schemeEnd);\n      const authority = path.slice(authorityStart, authorityEnd);\n      if (\n        scheme === 'file' &&\n        (authority === '' || authority === 'localhost') &&\n        isVolumeCharacter(path.charCodeAt(authorityEnd + 1))\n      ) {\n        const volumeSeparatorEnd = getFileUrlVolumeSeparatorEnd(\n          path,\n          authorityEnd + 2\n        );\n        if (volumeSeparatorEnd !== -1) {\n          if (path.charCodeAt(volumeSeparatorEnd) === CharacterCodes.slash) {\n            // URL: \"file:///c:/\", \"file://localhost/c:/\", \"file:///c%3a/\", \"file://localhost/c%3a/\"\n            return ~(volumeSeparatorEnd + 1);\n          }\n          if (volumeSeparatorEnd === path.length) {\n            // URL: \"file:///c:\", \"file://localhost/c:\", \"file:///c$3a\", \"file://localhost/c%3a\"\n            // but not \"file:///c:d\" or \"file:///c%3ad\"\n            return ~volumeSeparatorEnd;\n          }\n        }\n      }\n      return ~(authorityEnd + 1); // URL: \"file://server/\", \"http://server/\"\n    }\n    return ~path.length; // URL: \"file://server\", \"http://server\"\n  }\n\n  // relative\n  return 0;\n}\nfunction ensureTrailingDirectorySeparator(path: string) {\n  if (!hasTrailingDirectorySeparator(path)) {\n    return path + directorySeparator;\n  }\n\n  return path;\n}\nfunction hasTrailingDirectorySeparator(path: string) {\n  return (\n    path.length > 0 && isAnyDirectorySeparator(path.charCodeAt(path.length - 1))\n  );\n}\nfunction isAnyDirectorySeparator(charCode: number): boolean {\n  return (\n    charCode === CharacterCodes.slash || charCode === CharacterCodes.backslash\n  );\n}\nfunction removeTrailingDirectorySeparator(path: string) {\n  if (hasTrailingDirectorySeparator(path)) {\n    return path.substr(0, path.length - 1);\n  }\n\n  return path;\n}\nconst directorySeparator = '/';\nconst altDirectorySeparator = '\\\\';\nconst urlSchemeSeparator = '://';\nfunction isVolumeCharacter(charCode: number) {\n  return (\n    (charCode >= CharacterCodes.a && charCode <= CharacterCodes.z) ||\n    (charCode >= CharacterCodes.A && charCode <= CharacterCodes.Z)\n  );\n}\nfunction getFileUrlVolumeSeparatorEnd(url: string, start: number) {\n  const ch0 = url.charCodeAt(start);\n  if (ch0 === CharacterCodes.colon) return start + 1;\n  if (\n    ch0 === CharacterCodes.percent &&\n    url.charCodeAt(start + 1) === CharacterCodes._3\n  ) {\n    const ch2 = url.charCodeAt(start + 2);\n    if (ch2 === CharacterCodes.a || ch2 === CharacterCodes.A) return start + 3;\n  }\n  return -1;\n}\nfunction some<T>(array: readonly T[] | undefined): array is readonly T[];\nfunction some<T>(\n  array: readonly T[] | undefined,\n  predicate: (value: T) => boolean\n): boolean;\nfunction some<T>(\n  array: readonly T[] | undefined,\n  predicate?: (value: T) => boolean\n): boolean {\n  if (array) {\n    if (predicate) {\n      for (const v of array) {\n        if (predicate(v)) {\n          return true;\n        }\n      }\n    } else {\n      return array.length > 0;\n    }\n  }\n  return false;\n}\n/* @internal */\nconst enum CharacterCodes {\n  _3 = 0x33,\n  a = 0x61,\n  z = 0x7a,\n  A = 0x41,\n  Z = 0x5a,\n  asterisk = 0x2a, // *\n  backslash = 0x5c, // \\\n  colon = 0x3a, // :\n  percent = 0x25, // %\n  question = 0x3f, // ?\n  slash = 0x2f, // /\n}\nfunction pathComponents(path: string, rootLength: number) {\n  const root = path.substring(0, rootLength);\n  const rest = path.substring(rootLength).split(directorySeparator);\n  if (rest.length && !lastOrUndefined(rest)) rest.pop();\n  return [root, ...rest];\n}\nfunction lastOrUndefined<T>(array: readonly T[]): T | undefined {\n  return array.length === 0 ? undefined : array[array.length - 1];\n}\nfunction last<T>(array: readonly T[]): T {\n  // Debug.assert(array.length !== 0);\n  return array[array.length - 1];\n}\nfunction replaceWildcardCharacter(\n  match: string,\n  singleAsteriskRegexFragment: string\n) {\n  return match === '*'\n    ? singleAsteriskRegexFragment\n    : match === '?'\n    ? '[^/]'\n    : '\\\\' + match;\n}\n/**\n * An \"includes\" path \"foo\" is implicitly a glob \"foo/** /*\" (without the space) if its last component has no extension,\n * and does not contain any glob characters itself.\n */\nfunction isImplicitGlob(lastPathComponent: string): boolean {\n  return !/[.*?]/.test(lastPathComponent);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}