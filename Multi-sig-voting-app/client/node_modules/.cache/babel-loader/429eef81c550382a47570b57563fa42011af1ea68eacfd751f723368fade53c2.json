{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getTsConfigDefaults = exports.ComputeAsCommonRootOfFiles = exports.loadCompiler = exports.resolveAndLoadCompiler = exports.readConfig = exports.findAndReadConfig = void 0;\nconst path_1 = require(\"path\");\nconst index_1 = require(\"./index\");\nconst ts_internals_1 = require(\"./ts-internals\");\nconst tsconfigs_1 = require(\"./tsconfigs\");\nconst util_1 = require(\"./util\");\n/**\n * TypeScript compiler option values required by `ts-node` which cannot be overridden.\n */\nconst TS_NODE_COMPILER_OPTIONS = {\n  sourceMap: true,\n  inlineSourceMap: false,\n  inlineSources: true,\n  declaration: false,\n  noEmit: false,\n  outDir: '.ts-node'\n};\n/*\n * Do post-processing on config options to support `ts-node`.\n */\nfunction fixConfig(ts, config) {\n  // Delete options that *should not* be passed through.\n  delete config.options.out;\n  delete config.options.outFile;\n  delete config.options.composite;\n  delete config.options.declarationDir;\n  delete config.options.declarationMap;\n  delete config.options.emitDeclarationOnly;\n  // Target ES5 output by default (instead of ES3).\n  if (config.options.target === undefined) {\n    config.options.target = ts.ScriptTarget.ES5;\n  }\n  // Target CommonJS modules by default (instead of magically switching to ES6 when the target is ES6).\n  if (config.options.module === undefined) {\n    config.options.module = ts.ModuleKind.CommonJS;\n  }\n  return config;\n}\n/** @internal */\nfunction findAndReadConfig(rawOptions) {\n  var _a, _b, _c, _d, _e;\n  const cwd = (0, path_1.resolve)((_c = (_b = (_a = rawOptions.cwd) !== null && _a !== void 0 ? _a : rawOptions.dir) !== null && _b !== void 0 ? _b : index_1.DEFAULTS.cwd) !== null && _c !== void 0 ? _c : process.cwd());\n  const compilerName = (_d = rawOptions.compiler) !== null && _d !== void 0 ? _d : index_1.DEFAULTS.compiler;\n  // Compute minimum options to read the config file.\n  let projectLocalResolveDir = (0, util_1.getBasePathForProjectLocalDependencyResolution)(undefined, rawOptions.projectSearchDir, rawOptions.project, cwd);\n  let {\n    compiler,\n    ts\n  } = resolveAndLoadCompiler(compilerName, projectLocalResolveDir);\n  // Read config file and merge new options between env and CLI options.\n  const {\n    configFilePath,\n    config,\n    tsNodeOptionsFromTsconfig,\n    optionBasePaths\n  } = readConfig(cwd, ts, rawOptions);\n  const options = (0, util_1.assign)({}, index_1.DEFAULTS, tsNodeOptionsFromTsconfig || {}, {\n    optionBasePaths\n  }, rawOptions);\n  options.require = [...(tsNodeOptionsFromTsconfig.require || []), ...(rawOptions.require || [])];\n  // Re-resolve the compiler in case it has changed.\n  // Compiler is loaded relative to tsconfig.json, so tsconfig discovery may cause us to load a\n  // different compiler than we did above, even if the name has not changed.\n  if (configFilePath) {\n    projectLocalResolveDir = (0, util_1.getBasePathForProjectLocalDependencyResolution)(configFilePath, rawOptions.projectSearchDir, rawOptions.project, cwd);\n    ({\n      compiler\n    } = resolveCompiler(options.compiler, (_e = optionBasePaths.compiler) !== null && _e !== void 0 ? _e : projectLocalResolveDir));\n  }\n  return {\n    options,\n    config,\n    projectLocalResolveDir,\n    optionBasePaths,\n    configFilePath,\n    cwd,\n    compiler\n  };\n}\nexports.findAndReadConfig = findAndReadConfig;\n/**\n * Load TypeScript configuration. Returns the parsed TypeScript config and\n * any `ts-node` options specified in the config file.\n *\n * Even when a tsconfig.json is not loaded, this function still handles merging\n * compilerOptions from various sources: API, environment variables, etc.\n *\n * @internal\n */\nfunction readConfig(cwd, ts, rawApiOptions) {\n  var _a, _b, _c;\n  // Ordered [a, b, c] where config a extends b extends c\n  const configChain = [];\n  let config = {\n    compilerOptions: {}\n  };\n  let basePath = cwd;\n  let configFilePath = undefined;\n  const projectSearchDir = (0, path_1.resolve)(cwd, (_a = rawApiOptions.projectSearchDir) !== null && _a !== void 0 ? _a : cwd);\n  const {\n    fileExists = ts.sys.fileExists,\n    readFile = ts.sys.readFile,\n    skipProject = index_1.DEFAULTS.skipProject,\n    project = index_1.DEFAULTS.project,\n    tsTrace = index_1.DEFAULTS.tsTrace\n  } = rawApiOptions;\n  // Read project configuration when available.\n  if (!skipProject) {\n    if (project) {\n      const resolved = (0, path_1.resolve)(cwd, project);\n      const nested = (0, path_1.join)(resolved, 'tsconfig.json');\n      configFilePath = fileExists(nested) ? nested : resolved;\n    } else {\n      configFilePath = ts.findConfigFile(projectSearchDir, fileExists);\n    }\n    if (configFilePath) {\n      let pathToNextConfigInChain = configFilePath;\n      const tsInternals = (0, ts_internals_1.createTsInternals)(ts);\n      const errors = [];\n      // Follow chain of \"extends\"\n      while (true) {\n        const result = ts.readConfigFile(pathToNextConfigInChain, readFile);\n        // Return diagnostics.\n        if (result.error) {\n          return {\n            configFilePath,\n            config: {\n              errors: [result.error],\n              fileNames: [],\n              options: {}\n            },\n            tsNodeOptionsFromTsconfig: {},\n            optionBasePaths: {}\n          };\n        }\n        const c = result.config;\n        const bp = (0, path_1.dirname)(pathToNextConfigInChain);\n        configChain.push({\n          config: c,\n          basePath: bp,\n          configPath: pathToNextConfigInChain\n        });\n        if (c.extends == null) break;\n        const resolvedExtendedConfigPath = tsInternals.getExtendsConfigPath(c.extends, {\n          fileExists,\n          readDirectory: ts.sys.readDirectory,\n          readFile,\n          useCaseSensitiveFileNames: ts.sys.useCaseSensitiveFileNames,\n          trace: tsTrace\n        }, bp, errors, ts.createCompilerDiagnostic);\n        if (errors.length) {\n          return {\n            configFilePath,\n            config: {\n              errors,\n              fileNames: [],\n              options: {}\n            },\n            tsNodeOptionsFromTsconfig: {},\n            optionBasePaths: {}\n          };\n        }\n        if (resolvedExtendedConfigPath == null) break;\n        pathToNextConfigInChain = resolvedExtendedConfigPath;\n      }\n      ({\n        config,\n        basePath\n      } = configChain[0]);\n    }\n  }\n  // Merge and fix ts-node options that come from tsconfig.json(s)\n  const tsNodeOptionsFromTsconfig = {};\n  const optionBasePaths = {};\n  for (let i = configChain.length - 1; i >= 0; i--) {\n    const {\n      config,\n      basePath,\n      configPath\n    } = configChain[i];\n    const options = filterRecognizedTsConfigTsNodeOptions(config['ts-node']).recognized;\n    // Some options are relative to the config file, so must be converted to absolute paths here\n    if (options.require) {\n      // Modules are found relative to the tsconfig file, not the `dir` option\n      const tsconfigRelativeResolver = (0, util_1.createProjectLocalResolveHelper)((0, path_1.dirname)(configPath));\n      options.require = options.require.map(path => tsconfigRelativeResolver(path, false));\n    }\n    if (options.scopeDir) {\n      options.scopeDir = (0, path_1.resolve)(basePath, options.scopeDir);\n    }\n    // Downstream code uses the basePath; we do not do that here.\n    if (options.moduleTypes) {\n      optionBasePaths.moduleTypes = basePath;\n    }\n    if (options.transpiler != null) {\n      optionBasePaths.transpiler = basePath;\n    }\n    if (options.compiler != null) {\n      optionBasePaths.compiler = basePath;\n    }\n    if (options.swc != null) {\n      optionBasePaths.swc = basePath;\n    }\n    (0, util_1.assign)(tsNodeOptionsFromTsconfig, options);\n  }\n  // Remove resolution of \"files\".\n  const files = (_c = (_b = rawApiOptions.files) !== null && _b !== void 0 ? _b : tsNodeOptionsFromTsconfig.files) !== null && _c !== void 0 ? _c : index_1.DEFAULTS.files;\n  // Only if a config file is *not* loaded, load an implicit configuration from @tsconfig/bases\n  const skipDefaultCompilerOptions = configFilePath != null;\n  const defaultCompilerOptionsForNodeVersion = skipDefaultCompilerOptions ? undefined : {\n    ...(0, tsconfigs_1.getDefaultTsconfigJsonForNodeVersion)(ts).compilerOptions,\n    types: ['node']\n  };\n  // Merge compilerOptions from all sources\n  config.compilerOptions = Object.assign({},\n  // automatically-applied options from @tsconfig/bases\n  defaultCompilerOptionsForNodeVersion,\n  // tsconfig.json \"compilerOptions\"\n  config.compilerOptions,\n  // from env var\n  index_1.DEFAULTS.compilerOptions,\n  // tsconfig.json \"ts-node\": \"compilerOptions\"\n  tsNodeOptionsFromTsconfig.compilerOptions,\n  // passed programmatically\n  rawApiOptions.compilerOptions,\n  // overrides required by ts-node, cannot be changed\n  TS_NODE_COMPILER_OPTIONS);\n  const fixedConfig = fixConfig(ts, ts.parseJsonConfigFileContent(config, {\n    fileExists,\n    readFile,\n    // Only used for globbing \"files\", \"include\", \"exclude\"\n    // When `files` option disabled, we want to avoid the fs calls\n    readDirectory: files ? ts.sys.readDirectory : () => [],\n    useCaseSensitiveFileNames: ts.sys.useCaseSensitiveFileNames\n  }, basePath, undefined, configFilePath));\n  return {\n    configFilePath,\n    config: fixedConfig,\n    tsNodeOptionsFromTsconfig,\n    optionBasePaths\n  };\n}\nexports.readConfig = readConfig;\n/**\n * Load the typescript compiler. It is required to load the tsconfig but might\n * be changed by the tsconfig, so we have to do this twice.\n * @internal\n */\nfunction resolveAndLoadCompiler(name, relativeToPath) {\n  const {\n    compiler\n  } = resolveCompiler(name, relativeToPath);\n  const ts = loadCompiler(compiler);\n  return {\n    compiler,\n    ts\n  };\n}\nexports.resolveAndLoadCompiler = resolveAndLoadCompiler;\nfunction resolveCompiler(name, relativeToPath) {\n  const projectLocalResolveHelper = (0, util_1.createProjectLocalResolveHelper)(relativeToPath);\n  const compiler = projectLocalResolveHelper(name || 'typescript', true);\n  return {\n    compiler\n  };\n}\n/** @internal */\nfunction loadCompiler(compiler) {\n  return (0, util_1.attemptRequireWithV8CompileCache)(require, compiler);\n}\nexports.loadCompiler = loadCompiler;\n/**\n * Given the raw \"ts-node\" sub-object from a tsconfig, return an object with only the properties\n * recognized by \"ts-node\"\n */\nfunction filterRecognizedTsConfigTsNodeOptions(jsonObject) {\n  if (jsonObject == null) return {\n    recognized: {},\n    unrecognized: {}\n  };\n  const {\n    compiler,\n    compilerHost,\n    compilerOptions,\n    emit,\n    files,\n    ignore,\n    ignoreDiagnostics,\n    logError,\n    preferTsExts,\n    pretty,\n    require,\n    skipIgnore,\n    transpileOnly,\n    typeCheck,\n    transpiler,\n    scope,\n    scopeDir,\n    moduleTypes,\n    experimentalReplAwait,\n    swc,\n    experimentalResolver,\n    esm,\n    experimentalSpecifierResolution,\n    experimentalTsImportSpecifiers,\n    ...unrecognized\n  } = jsonObject;\n  const filteredTsConfigOptions = {\n    compiler,\n    compilerHost,\n    compilerOptions,\n    emit,\n    experimentalReplAwait,\n    files,\n    ignore,\n    ignoreDiagnostics,\n    logError,\n    preferTsExts,\n    pretty,\n    require,\n    skipIgnore,\n    transpileOnly,\n    typeCheck,\n    transpiler,\n    scope,\n    scopeDir,\n    moduleTypes,\n    swc,\n    experimentalResolver,\n    esm,\n    experimentalSpecifierResolution,\n    experimentalTsImportSpecifiers\n  };\n  // Use the typechecker to make sure this implementation has the correct set of properties\n  const catchExtraneousProps = null;\n  const catchMissingProps = null;\n  return {\n    recognized: filteredTsConfigOptions,\n    unrecognized\n  };\n}\n/** @internal */\nexports.ComputeAsCommonRootOfFiles = Symbol();\n/**\n * Some TS compiler options have defaults which are not provided by TS's config parsing functions.\n * This function centralizes the logic for computing those defaults.\n * @internal\n */\nfunction getTsConfigDefaults(config, basePath, _files, _include, _exclude) {\n  const {\n    composite = false\n  } = config.options;\n  let rootDir = config.options.rootDir;\n  if (rootDir == null) {\n    if (composite) rootDir = basePath;\n    // Return this symbol to avoid computing from `files`, which would require fs calls\n    else rootDir = exports.ComputeAsCommonRootOfFiles;\n  }\n  const {\n    outDir = rootDir\n  } = config.options;\n  // Docs are wrong: https://www.typescriptlang.org/tsconfig#include\n  // Docs say **, but it's actually **/*; compiler throws error for **\n  const include = _files ? [] : ['**/*'];\n  const files = _files !== null && _files !== void 0 ? _files : [];\n  // Docs are misleading: https://www.typescriptlang.org/tsconfig#exclude\n  // Docs say it excludes node_modules, bower_components, jspm_packages, but actually those are excluded via behavior of \"include\"\n  const exclude = _exclude !== null && _exclude !== void 0 ? _exclude : [outDir]; // TODO technically, outDir is absolute path, but exclude should be relative glob pattern?\n  // TODO compute baseUrl\n  return {\n    rootDir,\n    outDir,\n    include,\n    files,\n    exclude,\n    composite\n  };\n}\nexports.getTsConfigDefaults = getTsConfigDefaults;","map":{"version":3,"names":["path_1","require","index_1","ts_internals_1","tsconfigs_1","util_1","TS_NODE_COMPILER_OPTIONS","sourceMap","inlineSourceMap","inlineSources","declaration","noEmit","outDir","fixConfig","ts","config","options","out","outFile","composite","declarationDir","declarationMap","emitDeclarationOnly","target","undefined","ScriptTarget","ES5","module","ModuleKind","CommonJS","findAndReadConfig","rawOptions","cwd","resolve","_c","_b","_a","dir","DEFAULTS","process","compilerName","_d","compiler","projectLocalResolveDir","getBasePathForProjectLocalDependencyResolution","projectSearchDir","project","resolveAndLoadCompiler","configFilePath","tsNodeOptionsFromTsconfig","optionBasePaths","readConfig","assign","resolveCompiler","_e","exports","rawApiOptions","configChain","compilerOptions","basePath","fileExists","sys","readFile","skipProject","tsTrace","resolved","nested","join","findConfigFile","pathToNextConfigInChain","tsInternals","createTsInternals","errors","result","readConfigFile","error","fileNames","c","bp","dirname","push","configPath","extends","resolvedExtendedConfigPath","getExtendsConfigPath","readDirectory","useCaseSensitiveFileNames","trace","createCompilerDiagnostic","length","i","filterRecognizedTsConfigTsNodeOptions","recognized","tsconfigRelativeResolver","createProjectLocalResolveHelper","map","path","scopeDir","moduleTypes","transpiler","swc","files","skipDefaultCompilerOptions","defaultCompilerOptionsForNodeVersion","getDefaultTsconfigJsonForNodeVersion","types","Object","fixedConfig","parseJsonConfigFileContent","name","relativeToPath","loadCompiler","projectLocalResolveHelper","attemptRequireWithV8CompileCache","jsonObject","unrecognized","compilerHost","emit","ignore","ignoreDiagnostics","logError","preferTsExts","pretty","skipIgnore","transpileOnly","typeCheck","scope","experimentalReplAwait","experimentalResolver","esm","experimentalSpecifierResolution","experimentalTsImportSpecifiers","filteredTsConfigOptions","catchExtraneousProps","catchMissingProps","ComputeAsCommonRootOfFiles","Symbol","getTsConfigDefaults","_files","_include","_exclude","rootDir","include","exclude"],"sources":["/Users/mukuljindal/Local/projects/voting/node_modules/ts-node/src/configuration.ts"],"sourcesContent":["import { resolve, dirname, join } from 'path';\nimport type * as _ts from 'typescript';\nimport {\n  CreateOptions,\n  DEFAULTS,\n  OptionBasePaths,\n  RegisterOptions,\n  TSCommon,\n  TsConfigOptions,\n} from './index';\nimport type { TSInternal } from './ts-compiler-types';\nimport { createTsInternals } from './ts-internals';\nimport { getDefaultTsconfigJsonForNodeVersion } from './tsconfigs';\nimport {\n  assign,\n  attemptRequireWithV8CompileCache,\n  createProjectLocalResolveHelper,\n  getBasePathForProjectLocalDependencyResolution,\n} from './util';\n\n/**\n * TypeScript compiler option values required by `ts-node` which cannot be overridden.\n */\nconst TS_NODE_COMPILER_OPTIONS = {\n  sourceMap: true,\n  inlineSourceMap: false,\n  inlineSources: true,\n  declaration: false,\n  noEmit: false,\n  outDir: '.ts-node',\n};\n\n/*\n * Do post-processing on config options to support `ts-node`.\n */\nfunction fixConfig(ts: TSCommon, config: _ts.ParsedCommandLine) {\n  // Delete options that *should not* be passed through.\n  delete config.options.out;\n  delete config.options.outFile;\n  delete config.options.composite;\n  delete config.options.declarationDir;\n  delete config.options.declarationMap;\n  delete config.options.emitDeclarationOnly;\n\n  // Target ES5 output by default (instead of ES3).\n  if (config.options.target === undefined) {\n    config.options.target = ts.ScriptTarget.ES5;\n  }\n\n  // Target CommonJS modules by default (instead of magically switching to ES6 when the target is ES6).\n  if (config.options.module === undefined) {\n    config.options.module = ts.ModuleKind.CommonJS;\n  }\n\n  return config;\n}\n\n/** @internal */\nexport function findAndReadConfig(rawOptions: CreateOptions) {\n  const cwd = resolve(\n    rawOptions.cwd ?? rawOptions.dir ?? DEFAULTS.cwd ?? process.cwd()\n  );\n  const compilerName = rawOptions.compiler ?? DEFAULTS.compiler;\n\n  // Compute minimum options to read the config file.\n  let projectLocalResolveDir = getBasePathForProjectLocalDependencyResolution(\n    undefined,\n    rawOptions.projectSearchDir,\n    rawOptions.project,\n    cwd\n  );\n  let { compiler, ts } = resolveAndLoadCompiler(\n    compilerName,\n    projectLocalResolveDir\n  );\n\n  // Read config file and merge new options between env and CLI options.\n  const { configFilePath, config, tsNodeOptionsFromTsconfig, optionBasePaths } =\n    readConfig(cwd, ts, rawOptions);\n\n  const options = assign<RegisterOptions>(\n    {},\n    DEFAULTS,\n    tsNodeOptionsFromTsconfig || {},\n    { optionBasePaths },\n    rawOptions\n  );\n  options.require = [\n    ...(tsNodeOptionsFromTsconfig.require || []),\n    ...(rawOptions.require || []),\n  ];\n\n  // Re-resolve the compiler in case it has changed.\n  // Compiler is loaded relative to tsconfig.json, so tsconfig discovery may cause us to load a\n  // different compiler than we did above, even if the name has not changed.\n  if (configFilePath) {\n    projectLocalResolveDir = getBasePathForProjectLocalDependencyResolution(\n      configFilePath,\n      rawOptions.projectSearchDir,\n      rawOptions.project,\n      cwd\n    );\n    ({ compiler } = resolveCompiler(\n      options.compiler,\n      optionBasePaths.compiler ?? projectLocalResolveDir\n    ));\n  }\n\n  return {\n    options,\n    config,\n    projectLocalResolveDir,\n    optionBasePaths,\n    configFilePath,\n    cwd,\n    compiler,\n  };\n}\n\n/**\n * Load TypeScript configuration. Returns the parsed TypeScript config and\n * any `ts-node` options specified in the config file.\n *\n * Even when a tsconfig.json is not loaded, this function still handles merging\n * compilerOptions from various sources: API, environment variables, etc.\n *\n * @internal\n */\nexport function readConfig(\n  cwd: string,\n  ts: TSCommon,\n  rawApiOptions: CreateOptions\n): {\n  /**\n   * Path of tsconfig file if one was loaded\n   */\n  configFilePath: string | undefined;\n  /**\n   * Parsed TypeScript configuration with compilerOptions merged from all other sources (env vars, etc)\n   */\n  config: _ts.ParsedCommandLine;\n  /**\n   * ts-node options pulled from `tsconfig.json`, NOT merged with any other sources.  Merging must happen outside\n   * this function.\n   */\n  tsNodeOptionsFromTsconfig: TsConfigOptions;\n  optionBasePaths: OptionBasePaths;\n} {\n  // Ordered [a, b, c] where config a extends b extends c\n  const configChain: Array<{\n    config: any;\n    basePath: string;\n    configPath: string;\n  }> = [];\n  let config: any = { compilerOptions: {} };\n  let basePath = cwd;\n  let configFilePath: string | undefined = undefined;\n  const projectSearchDir = resolve(cwd, rawApiOptions.projectSearchDir ?? cwd);\n\n  const {\n    fileExists = ts.sys.fileExists,\n    readFile = ts.sys.readFile,\n    skipProject = DEFAULTS.skipProject,\n    project = DEFAULTS.project,\n    tsTrace = DEFAULTS.tsTrace,\n  } = rawApiOptions;\n\n  // Read project configuration when available.\n  if (!skipProject) {\n    if (project) {\n      const resolved = resolve(cwd, project);\n      const nested = join(resolved, 'tsconfig.json');\n      configFilePath = fileExists(nested) ? nested : resolved;\n    } else {\n      configFilePath = ts.findConfigFile(projectSearchDir, fileExists);\n    }\n\n    if (configFilePath) {\n      let pathToNextConfigInChain = configFilePath;\n      const tsInternals = createTsInternals(ts);\n      const errors: Array<_ts.Diagnostic> = [];\n\n      // Follow chain of \"extends\"\n      while (true) {\n        const result = ts.readConfigFile(pathToNextConfigInChain, readFile);\n\n        // Return diagnostics.\n        if (result.error) {\n          return {\n            configFilePath,\n            config: { errors: [result.error], fileNames: [], options: {} },\n            tsNodeOptionsFromTsconfig: {},\n            optionBasePaths: {},\n          };\n        }\n\n        const c = result.config;\n        const bp = dirname(pathToNextConfigInChain);\n        configChain.push({\n          config: c,\n          basePath: bp,\n          configPath: pathToNextConfigInChain,\n        });\n\n        if (c.extends == null) break;\n        const resolvedExtendedConfigPath = tsInternals.getExtendsConfigPath(\n          c.extends,\n          {\n            fileExists,\n            readDirectory: ts.sys.readDirectory,\n            readFile,\n            useCaseSensitiveFileNames: ts.sys.useCaseSensitiveFileNames,\n            trace: tsTrace,\n          },\n          bp,\n          errors,\n          (ts as unknown as TSInternal).createCompilerDiagnostic\n        );\n        if (errors.length) {\n          return {\n            configFilePath,\n            config: { errors, fileNames: [], options: {} },\n            tsNodeOptionsFromTsconfig: {},\n            optionBasePaths: {},\n          };\n        }\n        if (resolvedExtendedConfigPath == null) break;\n        pathToNextConfigInChain = resolvedExtendedConfigPath;\n      }\n\n      ({ config, basePath } = configChain[0]);\n    }\n  }\n\n  // Merge and fix ts-node options that come from tsconfig.json(s)\n  const tsNodeOptionsFromTsconfig: TsConfigOptions = {};\n  const optionBasePaths: OptionBasePaths = {};\n  for (let i = configChain.length - 1; i >= 0; i--) {\n    const { config, basePath, configPath } = configChain[i];\n    const options = filterRecognizedTsConfigTsNodeOptions(\n      config['ts-node']\n    ).recognized;\n\n    // Some options are relative to the config file, so must be converted to absolute paths here\n    if (options.require) {\n      // Modules are found relative to the tsconfig file, not the `dir` option\n      const tsconfigRelativeResolver = createProjectLocalResolveHelper(\n        dirname(configPath)\n      );\n      options.require = options.require.map((path: string) =>\n        tsconfigRelativeResolver(path, false)\n      );\n    }\n    if (options.scopeDir) {\n      options.scopeDir = resolve(basePath, options.scopeDir!);\n    }\n\n    // Downstream code uses the basePath; we do not do that here.\n    if (options.moduleTypes) {\n      optionBasePaths.moduleTypes = basePath;\n    }\n    if (options.transpiler != null) {\n      optionBasePaths.transpiler = basePath;\n    }\n    if (options.compiler != null) {\n      optionBasePaths.compiler = basePath;\n    }\n    if (options.swc != null) {\n      optionBasePaths.swc = basePath;\n    }\n\n    assign(tsNodeOptionsFromTsconfig, options);\n  }\n\n  // Remove resolution of \"files\".\n  const files =\n    rawApiOptions.files ?? tsNodeOptionsFromTsconfig.files ?? DEFAULTS.files;\n\n  // Only if a config file is *not* loaded, load an implicit configuration from @tsconfig/bases\n  const skipDefaultCompilerOptions = configFilePath != null;\n  const defaultCompilerOptionsForNodeVersion = skipDefaultCompilerOptions\n    ? undefined\n    : {\n        ...getDefaultTsconfigJsonForNodeVersion(ts).compilerOptions,\n        types: ['node'],\n      };\n\n  // Merge compilerOptions from all sources\n  config.compilerOptions = Object.assign(\n    {},\n    // automatically-applied options from @tsconfig/bases\n    defaultCompilerOptionsForNodeVersion,\n    // tsconfig.json \"compilerOptions\"\n    config.compilerOptions,\n    // from env var\n    DEFAULTS.compilerOptions,\n    // tsconfig.json \"ts-node\": \"compilerOptions\"\n    tsNodeOptionsFromTsconfig.compilerOptions,\n    // passed programmatically\n    rawApiOptions.compilerOptions,\n    // overrides required by ts-node, cannot be changed\n    TS_NODE_COMPILER_OPTIONS\n  );\n\n  const fixedConfig = fixConfig(\n    ts,\n    ts.parseJsonConfigFileContent(\n      config,\n      {\n        fileExists,\n        readFile,\n        // Only used for globbing \"files\", \"include\", \"exclude\"\n        // When `files` option disabled, we want to avoid the fs calls\n        readDirectory: files ? ts.sys.readDirectory : () => [],\n        useCaseSensitiveFileNames: ts.sys.useCaseSensitiveFileNames,\n      },\n      basePath,\n      undefined,\n      configFilePath\n    )\n  );\n\n  return {\n    configFilePath,\n    config: fixedConfig,\n    tsNodeOptionsFromTsconfig,\n    optionBasePaths,\n  };\n}\n\n/**\n * Load the typescript compiler. It is required to load the tsconfig but might\n * be changed by the tsconfig, so we have to do this twice.\n * @internal\n */\nexport function resolveAndLoadCompiler(\n  name: string | undefined,\n  relativeToPath: string\n) {\n  const { compiler } = resolveCompiler(name, relativeToPath);\n  const ts = loadCompiler(compiler);\n  return { compiler, ts };\n}\n\nfunction resolveCompiler(name: string | undefined, relativeToPath: string) {\n  const projectLocalResolveHelper =\n    createProjectLocalResolveHelper(relativeToPath);\n  const compiler = projectLocalResolveHelper(name || 'typescript', true);\n  return { compiler };\n}\n\n/** @internal */\nexport function loadCompiler(compiler: string): TSCommon {\n  return attemptRequireWithV8CompileCache(require, compiler);\n}\n\n/**\n * Given the raw \"ts-node\" sub-object from a tsconfig, return an object with only the properties\n * recognized by \"ts-node\"\n */\nfunction filterRecognizedTsConfigTsNodeOptions(jsonObject: any): {\n  recognized: TsConfigOptions;\n  unrecognized: any;\n} {\n  if (jsonObject == null) return { recognized: {}, unrecognized: {} };\n  const {\n    compiler,\n    compilerHost,\n    compilerOptions,\n    emit,\n    files,\n    ignore,\n    ignoreDiagnostics,\n    logError,\n    preferTsExts,\n    pretty,\n    require,\n    skipIgnore,\n    transpileOnly,\n    typeCheck,\n    transpiler,\n    scope,\n    scopeDir,\n    moduleTypes,\n    experimentalReplAwait,\n    swc,\n    experimentalResolver,\n    esm,\n    experimentalSpecifierResolution,\n    experimentalTsImportSpecifiers,\n    ...unrecognized\n  } = jsonObject as TsConfigOptions;\n  const filteredTsConfigOptions = {\n    compiler,\n    compilerHost,\n    compilerOptions,\n    emit,\n    experimentalReplAwait,\n    files,\n    ignore,\n    ignoreDiagnostics,\n    logError,\n    preferTsExts,\n    pretty,\n    require,\n    skipIgnore,\n    transpileOnly,\n    typeCheck,\n    transpiler,\n    scope,\n    scopeDir,\n    moduleTypes,\n    swc,\n    experimentalResolver,\n    esm,\n    experimentalSpecifierResolution,\n    experimentalTsImportSpecifiers,\n  };\n  // Use the typechecker to make sure this implementation has the correct set of properties\n  const catchExtraneousProps: keyof TsConfigOptions =\n    null as any as keyof typeof filteredTsConfigOptions;\n  const catchMissingProps: keyof typeof filteredTsConfigOptions =\n    null as any as keyof TsConfigOptions;\n  return { recognized: filteredTsConfigOptions, unrecognized };\n}\n\n/** @internal */\nexport const ComputeAsCommonRootOfFiles = Symbol();\n\n/**\n * Some TS compiler options have defaults which are not provided by TS's config parsing functions.\n * This function centralizes the logic for computing those defaults.\n * @internal\n */\nexport function getTsConfigDefaults(\n  config: _ts.ParsedCommandLine,\n  basePath: string,\n  _files: string[] | undefined,\n  _include: string[] | undefined,\n  _exclude: string[] | undefined\n) {\n  const { composite = false } = config.options;\n  let rootDir: string | typeof ComputeAsCommonRootOfFiles =\n    config.options.rootDir!;\n  if (rootDir == null) {\n    if (composite) rootDir = basePath;\n    // Return this symbol to avoid computing from `files`, which would require fs calls\n    else rootDir = ComputeAsCommonRootOfFiles;\n  }\n  const { outDir = rootDir } = config.options;\n  // Docs are wrong: https://www.typescriptlang.org/tsconfig#include\n  // Docs say **, but it's actually **/*; compiler throws error for **\n  const include = _files ? [] : ['**/*'];\n  const files = _files ?? [];\n  // Docs are misleading: https://www.typescriptlang.org/tsconfig#exclude\n  // Docs say it excludes node_modules, bower_components, jspm_packages, but actually those are excluded via behavior of \"include\"\n  const exclude = _exclude ?? [outDir]; // TODO technically, outDir is absolute path, but exclude should be relative glob pattern?\n\n  // TODO compute baseUrl\n\n  return { rootDir, outDir, include, files, exclude, composite };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}