{"ast":null,"code":"// Ported from https://github.com/nodejs/undici/pull/907\n\n'use strict';\n\nconst assert = require('assert');\nconst {\n  Readable\n} = require('stream');\nconst {\n  RequestAbortedError,\n  NotSupportedError,\n  InvalidArgumentError\n} = require('../core/errors');\nconst util = require('../core/util');\nconst {\n  ReadableStreamFrom,\n  toUSVString\n} = require('../core/util');\nlet Blob;\nconst kConsume = Symbol('kConsume');\nconst kReading = Symbol('kReading');\nconst kBody = Symbol('kBody');\nconst kAbort = Symbol('abort');\nconst kContentType = Symbol('kContentType');\nmodule.exports = class BodyReadable extends Readable {\n  constructor({\n    resume,\n    abort,\n    contentType = '',\n    highWaterMark = 64 * 1024 // Same as nodejs fs streams.\n  }) {\n    super({\n      autoDestroy: true,\n      read: resume,\n      highWaterMark\n    });\n    this._readableState.dataEmitted = false;\n    this[kAbort] = abort;\n    this[kConsume] = null;\n    this[kBody] = null;\n    this[kContentType] = contentType;\n\n    // Is stream being consumed through Readable API?\n    // This is an optimization so that we avoid checking\n    // for 'data' and 'readable' listeners in the hot path\n    // inside push().\n    this[kReading] = false;\n  }\n  destroy(err) {\n    if (this.destroyed) {\n      // Node < 16\n      return this;\n    }\n    if (!err && !this._readableState.endEmitted) {\n      err = new RequestAbortedError();\n    }\n    if (err) {\n      this[kAbort]();\n    }\n    return super.destroy(err);\n  }\n  emit(ev, ...args) {\n    if (ev === 'data') {\n      // Node < 16.7\n      this._readableState.dataEmitted = true;\n    } else if (ev === 'error') {\n      // Node < 16\n      this._readableState.errorEmitted = true;\n    }\n    return super.emit(ev, ...args);\n  }\n  on(ev, ...args) {\n    if (ev === 'data' || ev === 'readable') {\n      this[kReading] = true;\n    }\n    return super.on(ev, ...args);\n  }\n  addListener(ev, ...args) {\n    return this.on(ev, ...args);\n  }\n  off(ev, ...args) {\n    const ret = super.off(ev, ...args);\n    if (ev === 'data' || ev === 'readable') {\n      this[kReading] = this.listenerCount('data') > 0 || this.listenerCount('readable') > 0;\n    }\n    return ret;\n  }\n  removeListener(ev, ...args) {\n    return this.off(ev, ...args);\n  }\n  push(chunk) {\n    if (this[kConsume] && chunk !== null && this.readableLength === 0) {\n      consumePush(this[kConsume], chunk);\n      return this[kReading] ? super.push(chunk) : true;\n    }\n    return super.push(chunk);\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-text\n  async text() {\n    return consume(this, 'text');\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-json\n  async json() {\n    return consume(this, 'json');\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-blob\n  async blob() {\n    return consume(this, 'blob');\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-arraybuffer\n  async arrayBuffer() {\n    return consume(this, 'arrayBuffer');\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-formdata\n  async formData() {\n    // TODO: Implement.\n    throw new NotSupportedError();\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-bodyused\n  get bodyUsed() {\n    return util.isDisturbed(this);\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-body\n  get body() {\n    if (!this[kBody]) {\n      this[kBody] = ReadableStreamFrom(this);\n      if (this[kConsume]) {\n        // TODO: Is this the best way to force a lock?\n        this[kBody].getReader(); // Ensure stream is locked.\n        assert(this[kBody].locked);\n      }\n    }\n    return this[kBody];\n  }\n  async dump(opts) {\n    let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144;\n    const signal = opts && opts.signal;\n    const abortFn = () => {\n      this.destroy();\n    };\n    let signalListenerCleanup;\n    if (signal) {\n      if (typeof signal !== 'object' || !('aborted' in signal)) {\n        throw new InvalidArgumentError('signal must be an AbortSignal');\n      }\n      util.throwIfAborted(signal);\n      signalListenerCleanup = util.addAbortListener(signal, abortFn);\n    }\n    try {\n      for await (const chunk of this) {\n        util.throwIfAborted(signal);\n        limit -= Buffer.byteLength(chunk);\n        if (limit < 0) {\n          return;\n        }\n      }\n    } catch {\n      util.throwIfAborted(signal);\n    } finally {\n      if (typeof signalListenerCleanup === 'function') {\n        signalListenerCleanup();\n      } else if (signalListenerCleanup) {\n        signalListenerCleanup[Symbol.dispose]();\n      }\n    }\n  }\n};\n\n// https://streams.spec.whatwg.org/#readablestream-locked\nfunction isLocked(self) {\n  // Consume is an implicit lock.\n  return self[kBody] && self[kBody].locked === true || self[kConsume];\n}\n\n// https://fetch.spec.whatwg.org/#body-unusable\nfunction isUnusable(self) {\n  return util.isDisturbed(self) || isLocked(self);\n}\nasync function consume(stream, type) {\n  if (isUnusable(stream)) {\n    throw new TypeError('unusable');\n  }\n  assert(!stream[kConsume]);\n  return new Promise((resolve, reject) => {\n    stream[kConsume] = {\n      type,\n      stream,\n      resolve,\n      reject,\n      length: 0,\n      body: []\n    };\n    stream.on('error', function (err) {\n      consumeFinish(this[kConsume], err);\n    }).on('close', function () {\n      if (this[kConsume].body !== null) {\n        consumeFinish(this[kConsume], new RequestAbortedError());\n      }\n    });\n    process.nextTick(consumeStart, stream[kConsume]);\n  });\n}\nfunction consumeStart(consume) {\n  if (consume.body === null) {\n    return;\n  }\n  const {\n    _readableState: state\n  } = consume.stream;\n  for (const chunk of state.buffer) {\n    consumePush(consume, chunk);\n  }\n  if (state.endEmitted) {\n    consumeEnd(this[kConsume]);\n  } else {\n    consume.stream.on('end', function () {\n      consumeEnd(this[kConsume]);\n    });\n  }\n  consume.stream.resume();\n  while (consume.stream.read() != null) {\n    // Loop\n  }\n}\nfunction consumeEnd(consume) {\n  const {\n    type,\n    body,\n    resolve,\n    stream,\n    length\n  } = consume;\n  try {\n    if (type === 'text') {\n      resolve(toUSVString(Buffer.concat(body)));\n    } else if (type === 'json') {\n      resolve(JSON.parse(Buffer.concat(body)));\n    } else if (type === 'arrayBuffer') {\n      const dst = new Uint8Array(length);\n      let pos = 0;\n      for (const buf of body) {\n        dst.set(buf, pos);\n        pos += buf.byteLength;\n      }\n      resolve(dst.buffer);\n    } else if (type === 'blob') {\n      if (!Blob) {\n        Blob = require('buffer').Blob;\n      }\n      resolve(new Blob(body, {\n        type: stream[kContentType]\n      }));\n    }\n    consumeFinish(consume);\n  } catch (err) {\n    stream.destroy(err);\n  }\n}\nfunction consumePush(consume, chunk) {\n  consume.length += chunk.length;\n  consume.body.push(chunk);\n}\nfunction consumeFinish(consume, err) {\n  if (consume.body === null) {\n    return;\n  }\n  if (err) {\n    consume.reject(err);\n  } else {\n    consume.resolve();\n  }\n  consume.type = null;\n  consume.stream = null;\n  consume.resolve = null;\n  consume.reject = null;\n  consume.length = 0;\n  consume.body = null;\n}","map":{"version":3,"names":["assert","require","Readable","RequestAbortedError","NotSupportedError","InvalidArgumentError","util","ReadableStreamFrom","toUSVString","Blob","kConsume","Symbol","kReading","kBody","kAbort","kContentType","module","exports","BodyReadable","constructor","resume","abort","contentType","highWaterMark","autoDestroy","read","_readableState","dataEmitted","destroy","err","destroyed","endEmitted","emit","ev","args","errorEmitted","on","addListener","off","ret","listenerCount","removeListener","push","chunk","readableLength","consumePush","text","consume","json","blob","arrayBuffer","formData","bodyUsed","isDisturbed","body","getReader","locked","dump","opts","limit","Number","isFinite","signal","abortFn","signalListenerCleanup","throwIfAborted","addAbortListener","Buffer","byteLength","dispose","isLocked","self","isUnusable","stream","type","TypeError","Promise","resolve","reject","length","consumeFinish","process","nextTick","consumeStart","state","buffer","consumeEnd","concat","JSON","parse","dst","Uint8Array","pos","buf","set"],"sources":["/Users/mukuljindal/Local/projects/fuckingwork/node_modules/undici/lib/api/readable.js"],"sourcesContent":["// Ported from https://github.com/nodejs/undici/pull/907\n\n'use strict'\n\nconst assert = require('assert')\nconst { Readable } = require('stream')\nconst { RequestAbortedError, NotSupportedError, InvalidArgumentError } = require('../core/errors')\nconst util = require('../core/util')\nconst { ReadableStreamFrom, toUSVString } = require('../core/util')\n\nlet Blob\n\nconst kConsume = Symbol('kConsume')\nconst kReading = Symbol('kReading')\nconst kBody = Symbol('kBody')\nconst kAbort = Symbol('abort')\nconst kContentType = Symbol('kContentType')\n\nmodule.exports = class BodyReadable extends Readable {\n  constructor ({\n    resume,\n    abort,\n    contentType = '',\n    highWaterMark = 64 * 1024 // Same as nodejs fs streams.\n  }) {\n    super({\n      autoDestroy: true,\n      read: resume,\n      highWaterMark\n    })\n\n    this._readableState.dataEmitted = false\n\n    this[kAbort] = abort\n    this[kConsume] = null\n    this[kBody] = null\n    this[kContentType] = contentType\n\n    // Is stream being consumed through Readable API?\n    // This is an optimization so that we avoid checking\n    // for 'data' and 'readable' listeners in the hot path\n    // inside push().\n    this[kReading] = false\n  }\n\n  destroy (err) {\n    if (this.destroyed) {\n      // Node < 16\n      return this\n    }\n\n    if (!err && !this._readableState.endEmitted) {\n      err = new RequestAbortedError()\n    }\n\n    if (err) {\n      this[kAbort]()\n    }\n\n    return super.destroy(err)\n  }\n\n  emit (ev, ...args) {\n    if (ev === 'data') {\n      // Node < 16.7\n      this._readableState.dataEmitted = true\n    } else if (ev === 'error') {\n      // Node < 16\n      this._readableState.errorEmitted = true\n    }\n    return super.emit(ev, ...args)\n  }\n\n  on (ev, ...args) {\n    if (ev === 'data' || ev === 'readable') {\n      this[kReading] = true\n    }\n    return super.on(ev, ...args)\n  }\n\n  addListener (ev, ...args) {\n    return this.on(ev, ...args)\n  }\n\n  off (ev, ...args) {\n    const ret = super.off(ev, ...args)\n    if (ev === 'data' || ev === 'readable') {\n      this[kReading] = (\n        this.listenerCount('data') > 0 ||\n        this.listenerCount('readable') > 0\n      )\n    }\n    return ret\n  }\n\n  removeListener (ev, ...args) {\n    return this.off(ev, ...args)\n  }\n\n  push (chunk) {\n    if (this[kConsume] && chunk !== null && this.readableLength === 0) {\n      consumePush(this[kConsume], chunk)\n      return this[kReading] ? super.push(chunk) : true\n    }\n    return super.push(chunk)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-text\n  async text () {\n    return consume(this, 'text')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-json\n  async json () {\n    return consume(this, 'json')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-blob\n  async blob () {\n    return consume(this, 'blob')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-arraybuffer\n  async arrayBuffer () {\n    return consume(this, 'arrayBuffer')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-formdata\n  async formData () {\n    // TODO: Implement.\n    throw new NotSupportedError()\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-bodyused\n  get bodyUsed () {\n    return util.isDisturbed(this)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-body\n  get body () {\n    if (!this[kBody]) {\n      this[kBody] = ReadableStreamFrom(this)\n      if (this[kConsume]) {\n        // TODO: Is this the best way to force a lock?\n        this[kBody].getReader() // Ensure stream is locked.\n        assert(this[kBody].locked)\n      }\n    }\n    return this[kBody]\n  }\n\n  async dump (opts) {\n    let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144\n    const signal = opts && opts.signal\n    const abortFn = () => {\n      this.destroy()\n    }\n    let signalListenerCleanup\n    if (signal) {\n      if (typeof signal !== 'object' || !('aborted' in signal)) {\n        throw new InvalidArgumentError('signal must be an AbortSignal')\n      }\n      util.throwIfAborted(signal)\n      signalListenerCleanup = util.addAbortListener(signal, abortFn)\n    }\n    try {\n      for await (const chunk of this) {\n        util.throwIfAborted(signal)\n        limit -= Buffer.byteLength(chunk)\n        if (limit < 0) {\n          return\n        }\n      }\n    } catch {\n      util.throwIfAborted(signal)\n    } finally {\n      if (typeof signalListenerCleanup === 'function') {\n        signalListenerCleanup()\n      } else if (signalListenerCleanup) {\n        signalListenerCleanup[Symbol.dispose]()\n      }\n    }\n  }\n}\n\n// https://streams.spec.whatwg.org/#readablestream-locked\nfunction isLocked (self) {\n  // Consume is an implicit lock.\n  return (self[kBody] && self[kBody].locked === true) || self[kConsume]\n}\n\n// https://fetch.spec.whatwg.org/#body-unusable\nfunction isUnusable (self) {\n  return util.isDisturbed(self) || isLocked(self)\n}\n\nasync function consume (stream, type) {\n  if (isUnusable(stream)) {\n    throw new TypeError('unusable')\n  }\n\n  assert(!stream[kConsume])\n\n  return new Promise((resolve, reject) => {\n    stream[kConsume] = {\n      type,\n      stream,\n      resolve,\n      reject,\n      length: 0,\n      body: []\n    }\n\n    stream\n      .on('error', function (err) {\n        consumeFinish(this[kConsume], err)\n      })\n      .on('close', function () {\n        if (this[kConsume].body !== null) {\n          consumeFinish(this[kConsume], new RequestAbortedError())\n        }\n      })\n\n    process.nextTick(consumeStart, stream[kConsume])\n  })\n}\n\nfunction consumeStart (consume) {\n  if (consume.body === null) {\n    return\n  }\n\n  const { _readableState: state } = consume.stream\n\n  for (const chunk of state.buffer) {\n    consumePush(consume, chunk)\n  }\n\n  if (state.endEmitted) {\n    consumeEnd(this[kConsume])\n  } else {\n    consume.stream.on('end', function () {\n      consumeEnd(this[kConsume])\n    })\n  }\n\n  consume.stream.resume()\n\n  while (consume.stream.read() != null) {\n    // Loop\n  }\n}\n\nfunction consumeEnd (consume) {\n  const { type, body, resolve, stream, length } = consume\n\n  try {\n    if (type === 'text') {\n      resolve(toUSVString(Buffer.concat(body)))\n    } else if (type === 'json') {\n      resolve(JSON.parse(Buffer.concat(body)))\n    } else if (type === 'arrayBuffer') {\n      const dst = new Uint8Array(length)\n\n      let pos = 0\n      for (const buf of body) {\n        dst.set(buf, pos)\n        pos += buf.byteLength\n      }\n\n      resolve(dst.buffer)\n    } else if (type === 'blob') {\n      if (!Blob) {\n        Blob = require('buffer').Blob\n      }\n      resolve(new Blob(body, { type: stream[kContentType] }))\n    }\n\n    consumeFinish(consume)\n  } catch (err) {\n    stream.destroy(err)\n  }\n}\n\nfunction consumePush (consume, chunk) {\n  consume.length += chunk.length\n  consume.body.push(chunk)\n}\n\nfunction consumeFinish (consume, err) {\n  if (consume.body === null) {\n    return\n  }\n\n  if (err) {\n    consume.reject(err)\n  } else {\n    consume.resolve()\n  }\n\n  consume.type = null\n  consume.stream = null\n  consume.resolve = null\n  consume.reject = null\n  consume.length = 0\n  consume.body = null\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}