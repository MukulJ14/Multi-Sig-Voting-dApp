{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ModulesLogger = void 0;\nconst ethereumjs_util_1 = require(\"@nomicfoundation/ethereumjs-util\");\nconst ansi_escapes_1 = __importDefault(require(\"ansi-escapes\"));\nconst chalk_1 = __importDefault(require(\"chalk\"));\nconst util_1 = __importDefault(require(\"util\"));\nconst errors_1 = require(\"../../../core/errors\");\nconst errors_2 = require(\"../../../core/providers/errors\");\nconst wei_values_1 = require(\"../../../util/wei-values\");\nconst message_trace_1 = require(\"../../stack-traces/message-trace\");\nconst model_1 = require(\"../../stack-traces/model\");\nconst solidity_errors_1 = require(\"../../stack-traces/solidity-errors\");\nconst solidity_stack_trace_1 = require(\"../../stack-traces/solidity-stack-trace\");\nfunction printLine(line) {\n  console.log(line);\n}\nfunction replaceLastLine(newLine) {\n  if (process.stdout.isTTY === true) {\n    process.stdout.write(\n    // eslint-disable-next-line prefer-template\n    ansi_escapes_1.default.cursorHide + ansi_escapes_1.default.cursorPrevLine + newLine + ansi_escapes_1.default.eraseEndLine + \"\\n\" + ansi_escapes_1.default.cursorShow);\n  } else {\n    process.stdout.write(`${newLine}\\n`);\n  }\n}\n/**\n * Handles all the logging made from the Hardhat Network.\n *\n * Methods of this class follow this convention:\n * - Methods that start with `log` add those messages to a list of things to log\n * - Methods that start with `print` print to stdout immediately\n */\nclass ModulesLogger {\n  constructor(_enabled, _printLine = printLine, _replaceLastLine = replaceLastLine) {\n    this._enabled = _enabled;\n    this._printLine = _printLine;\n    this._replaceLastLine = _replaceLastLine;\n    this._logs = [];\n    this._titleLength = 0;\n    this._currentIndent = 0;\n    this._emptyIntervalMinedBlocksRangeStart = undefined;\n    this._emptyHardhatMinedBlocksRangeStart = undefined;\n    this._methodCollapsedCount = 0;\n  }\n  isEnabled() {\n    return this._enabled;\n  }\n  setEnabled(enabled) {\n    this._enabled = enabled;\n  }\n  isLoggedError(err) {\n    return err instanceof solidity_errors_1.SolidityError || err instanceof errors_2.TransactionExecutionError;\n  }\n  logBlockFromAutomine(result, codes, txHashToHighlight) {\n    const {\n      block,\n      blockResult,\n      traces\n    } = result;\n    const {\n      results\n    } = blockResult;\n    (0, errors_1.assertHardhatInvariant)(results.length === codes.length, \"The array of codes should have the same length as the array of results\");\n    this._indent(() => {\n      this._logBlockNumber(block);\n      this._indent(() => {\n        this._logBaseFeePerGas(block);\n        for (let i = 0; i < block.transactions.length; i++) {\n          const tx = block.transactions[i];\n          const txGasUsed = results[i].totalGasSpent;\n          const txTrace = traces[i];\n          const code = codes[i];\n          const highlightTxHash = tx.hash().equals(txHashToHighlight);\n          this._logTxInsideBlock(tx, txTrace, code, txGasUsed, {\n            highlightTxHash\n          });\n          this._logEmptyLineBetweenTransactions(i, block.transactions.length);\n        }\n      });\n    });\n  }\n  logMinedBlock(result, codes) {\n    const {\n      block,\n      blockResult,\n      traces\n    } = result;\n    const {\n      results\n    } = blockResult;\n    (0, errors_1.assertHardhatInvariant)(results.length === codes.length, \"The array of codes should have the same length as the array of results\");\n    const blockNumber = result.block.header.number;\n    const isEmpty = result.block.transactions.length === 0;\n    this._indent(() => {\n      this.logMinedBlockNumber(blockNumber, isEmpty, block.header.baseFeePerGas);\n      if (isEmpty) {\n        return;\n      }\n      this._indent(() => {\n        this._logBlockHash(block);\n        this._indent(() => {\n          this._logBaseFeePerGas(block);\n          for (let i = 0; i < block.transactions.length; i++) {\n            const tx = block.transactions[i];\n            const txGasUsed = results[i].totalGasSpent;\n            const txTrace = traces[i];\n            const code = codes[i];\n            this._logTxInsideBlock(tx, txTrace, code, txGasUsed, {\n              highlightTxHash: false\n            });\n            this._logEmptyLineBetweenTransactions(i, block.transactions.length);\n          }\n        });\n      });\n    });\n  }\n  logIntervalMinedBlock(result, codes) {\n    const {\n      block,\n      blockResult,\n      traces\n    } = result;\n    const {\n      results\n    } = blockResult;\n    (0, errors_1.assertHardhatInvariant)(results.length === codes.length, \"The array of codes should have the same length as the array of results\");\n    this._indent(() => {\n      this._logBlockHash(block);\n      this._indent(() => {\n        this._logBaseFeePerGas(block);\n        for (let i = 0; i < block.transactions.length; i++) {\n          const tx = block.transactions[i];\n          const txGasUsed = results[i].totalGasSpent;\n          const txTrace = traces[i];\n          const code = codes[i];\n          this._logTxInsideBlock(tx, txTrace, code, txGasUsed, {\n            highlightTxHash: false\n          });\n          this._logEmptyLineBetweenTransactions(i, block.transactions.length);\n        }\n      });\n    });\n  }\n  logSingleTransaction(tx, block, txGasUsed, txTrace, code) {\n    this._indent(() => {\n      this._logContractAndFunctionName(txTrace.trace, code);\n      const txHash = (0, ethereumjs_util_1.bufferToHex)(tx.hash());\n      this._logWithTitle(\"Transaction\", txHash);\n      this._logTxFrom(tx.getSenderAddress().toBuffer());\n      this._logTxTo(tx.to?.toBuffer(), txTrace.trace);\n      this._logTxValue(tx.value);\n      this._logWithTitle(\"Gas used\", `${txGasUsed} of ${tx.gasLimit}`);\n      this._logWithTitle(`Block #${block.header.number}`, (0, ethereumjs_util_1.bufferToHex)(block.hash()));\n      this._logConsoleLogMessages(txTrace.consoleLogMessages);\n      if (txTrace.error !== undefined) {\n        this._logError(txTrace.error);\n      }\n    });\n  }\n  logCurrentlySentTransaction(tx, txGasUsed, txTrace, code, block) {\n    this._indent(() => {\n      this._log(\"Currently sent transaction:\");\n      this.logEmptyLine();\n      this._logContractAndFunctionName(txTrace.trace, code);\n      const txHash = (0, ethereumjs_util_1.bufferToHex)(tx.hash());\n      this._logWithTitle(\"Transaction\", txHash);\n      this._logTxFrom(tx.getSenderAddress().toBuffer());\n      this._logTxTo(tx.to?.toBuffer(), txTrace.trace);\n      this._logTxValue(tx.value);\n      this._logWithTitle(\"Gas used\", `${txGasUsed} of ${tx.gasLimit}`);\n      this._logWithTitle(`Block #${block.header.number}`, (0, ethereumjs_util_1.bufferToHex)(block.hash()));\n      this._logConsoleLogMessages(txTrace.consoleLogMessages);\n      if (txTrace.error !== undefined) {\n        this._logError(txTrace.error);\n      }\n    });\n  }\n  logEstimateGasTrace(callParams, code, trace, consoleLogMessages, error) {\n    this._indent(() => {\n      this._logContractAndFunctionName(trace, code, {\n        printNonContractCalled: true\n      });\n      this._logTxFrom(callParams.from);\n      this._logTxTo(callParams.to, trace);\n      this._logTxValue(callParams.value);\n      this._logConsoleLogMessages(consoleLogMessages);\n      this._logError(error);\n    });\n  }\n  logCallTrace(callParams, code, trace, consoleLogMessages, error) {\n    this._indent(() => {\n      this._logContractAndFunctionName(trace, code, {\n        printNonContractCalled: true\n      });\n      this._logTxFrom(callParams.from);\n      this._logTxTo(callParams.to, trace);\n      if (callParams.value > 0n) {\n        this._logTxValue(callParams.value);\n      }\n      this._logConsoleLogMessages(consoleLogMessages);\n      if (error !== undefined) {\n        // TODO: If throwOnCallFailures is false, this will log the error, but the RPC method won't be red\n        this._logError(error);\n      }\n    });\n  }\n  logMinedBlockNumber(blockNumber, isEmpty, baseFeePerGas) {\n    if (isEmpty) {\n      this._log(`Mined empty block #${blockNumber}${baseFeePerGas !== undefined ? ` with base fee ${baseFeePerGas.toString()}` : \"\"}`);\n      return;\n    }\n    this._log(`Mined block #${blockNumber}`);\n  }\n  logMultipleTransactionsWarning() {\n    this._indent(() => {\n      this._log(\"There were other pending transactions mined in the same block:\");\n    });\n    this.logEmptyLine();\n  }\n  logMultipleBlocksWarning() {\n    this._indent(() => {\n      this._log(\"There were other pending transactions. More than one block had to be mined:\");\n    });\n    this.logEmptyLine();\n  }\n  logEmptyLine() {\n    this._log(\"\");\n  }\n  _logBaseFeePerGas(block) {\n    if (block.header.baseFeePerGas !== undefined) {\n      this._log(`Base fee: ${block.header.baseFeePerGas.toString()}`);\n    }\n  }\n  printErrorMessage(errorMessage) {\n    this._indent(() => {\n      this._print(errorMessage);\n    });\n  }\n  printFailedMethod(method) {\n    this._print(method, {\n      color: chalk_1.default.red\n    });\n  }\n  /**\n   * Print all accumulated logs\n   */\n  printLogs() {\n    const logs = this._getLogs();\n    if (logs.length === 0) {\n      return false;\n    }\n    for (const msg of logs) {\n      this._print(msg);\n    }\n    this._clearLogs();\n    return true;\n  }\n  printIntervalMinedBlockNumber(blockNumber, isEmpty, baseFeePerGas) {\n    if (this._emptyIntervalMinedBlocksRangeStart !== undefined) {\n      this._print(`Mined empty block range #${this._emptyIntervalMinedBlocksRangeStart} to #${blockNumber}`, {\n        collapseIntervalMinedBlock: true,\n        replaceLastLine: true\n      });\n    } else {\n      this._emptyIntervalMinedBlocksRangeStart = blockNumber;\n      if (isEmpty) {\n        this._print(`Mined empty block #${blockNumber}${baseFeePerGas !== undefined ? ` with base fee ${baseFeePerGas.toString()}` : \"\"}`, {\n          collapseIntervalMinedBlock: true\n        });\n        return;\n      }\n      this._print(`Mined block #${blockNumber}`, {\n        collapseIntervalMinedBlock: true\n      });\n    }\n  }\n  logEmptyHardhatMinedBlock(blockNumber, baseFeePerGas) {\n    this._indent(() => {\n      if (this._emptyHardhatMinedBlocksRangeStart !== undefined) {\n        this._log(`Mined empty block range #${this._emptyHardhatMinedBlocksRangeStart} to #${blockNumber}`, {\n          collapseHardhatMinedBlock: true,\n          replaceLastLine: true\n        });\n      } else {\n        this._emptyHardhatMinedBlocksRangeStart = blockNumber;\n        this._log(`Mined empty block #${blockNumber}${baseFeePerGas !== undefined ? ` with base fee ${baseFeePerGas.toString()}` : \"\"}`, {\n          collapseHardhatMinedBlock: true\n        });\n        return;\n      }\n    });\n  }\n  printMetaMaskWarning() {\n    const message = \"If you are using MetaMask, you can learn how to fix this error here: https://hardhat.org/metamask-issue\";\n    this._indent(() => {\n      this._print(message, {\n        color: chalk_1.default.yellow\n      });\n    });\n  }\n  printMethod(method) {\n    if (this._shouldCollapseMethod(method)) {\n      this._methodCollapsedCount += 1;\n      this._print(chalk_1.default.green(`${method} (${this._methodCollapsedCount})`), {\n        collapsePrintedMethod: true,\n        replaceLastLine: true\n      });\n    } else {\n      this._startCollapsingMethod(method);\n      this._print(method, {\n        color: chalk_1.default.green,\n        collapsePrintedMethod: true\n      });\n    }\n  }\n  printMethodNotSupported(method) {\n    this._print(`${method} - Method not supported`, {\n      color: chalk_1.default.red\n    });\n  }\n  printEmptyLine() {\n    this._print(\"\");\n  }\n  printUnknownError(err) {\n    this._indent(() => {\n      this._printError(err);\n      this.printEmptyLine();\n      this._print(\"If you think this is a bug in Hardhat, please report it here: https://hardhat.org/report-bug\");\n    });\n  }\n  _format(msg, {\n    color\n  } = {}) {\n    if (msg === \"\") {\n      // don't indent empty lines\n      return msg;\n    }\n    if (this._currentIndent > 0) {\n      msg = msg.split(\"\\n\").map(line => \" \".repeat(this._currentIndent) + line).join(\"\\n\");\n    }\n    if (color !== undefined) {\n      return color(msg);\n    }\n    return msg;\n  }\n  _indent(cb, enabled = true) {\n    if (enabled) {\n      this._currentIndent += 2;\n    }\n    try {\n      return cb();\n    } finally {\n      if (enabled) {\n        this._currentIndent -= 2;\n      }\n    }\n  }\n  _indentSingleLine(message) {\n    return \" \".repeat(this._currentIndent) + message;\n  }\n  _log(msg, printOptions = {}) {\n    if (printOptions.collapsePrintedMethod !== true) {\n      this._stopCollapsingMethod();\n    }\n    if (printOptions.collapseIntervalMinedBlock !== true) {\n      this._emptyIntervalMinedBlocksRangeStart = undefined;\n    }\n    if (printOptions.collapseHardhatMinedBlock !== true) {\n      this._emptyHardhatMinedBlocksRangeStart = undefined;\n    }\n    const formattedMessage = this._format(msg, printOptions);\n    if (printOptions.replaceLastLine === true) {\n      this._logs[this._logs.length - 1] = formattedMessage;\n    } else {\n      this._logs.push(formattedMessage);\n    }\n  }\n  _logError(err) {\n    if (this.isLoggedError(err)) {\n      this.logEmptyLine();\n      this._log(util_1.default.inspect(err));\n    }\n  }\n  _logTxInsideBlock(tx, txTrace, code, txGasUsed, {\n    highlightTxHash\n  }) {\n    // indentAfterTransactionHash: true,\n    // printTxBlockNumber: false,\n    // startWithTxHash: true,\n    let txHash = (0, ethereumjs_util_1.bufferToHex)(tx.hash());\n    if (highlightTxHash) {\n      txHash = chalk_1.default.bold(txHash);\n    }\n    this._logWithTitle(\"Transaction\", txHash);\n    this._indent(() => {\n      this._logContractAndFunctionName(txTrace.trace, code);\n      this._logTxFrom(tx.getSenderAddress().toBuffer());\n      this._logTxTo(tx.to?.toBuffer(), txTrace.trace);\n      this._logTxValue(tx.value);\n      this._logWithTitle(\"Gas used\", `${txGasUsed} of ${tx.gasLimit}`);\n      this._logConsoleLogMessages(txTrace.consoleLogMessages);\n      if (txTrace.error !== undefined) {\n        this._logError(txTrace.error);\n      }\n    });\n  }\n  /**\n   *  This should be the only function that calls _printLine and\n   *  _replaceLastLine (except for the special console.sol case),\n   *  because it's the only function that checks if the logger\n   *  is enabled.\n   */\n  _print(msg, printOptions = {}) {\n    if (!this._enabled) {\n      return;\n    }\n    if (printOptions.collapsePrintedMethod !== true) {\n      this._stopCollapsingMethod();\n    }\n    if (printOptions.collapseIntervalMinedBlock !== true) {\n      this._emptyIntervalMinedBlocksRangeStart = undefined;\n    }\n    if (printOptions.collapseHardhatMinedBlock !== true) {\n      this._emptyHardhatMinedBlocksRangeStart = undefined;\n    }\n    const formattedMessage = this._format(msg, printOptions);\n    if (printOptions.replaceLastLine === true) {\n      this._replaceLastLine(formattedMessage);\n    } else {\n      this._printLine(formattedMessage);\n    }\n  }\n  _printError(err) {\n    if (this.isLoggedError(err)) {\n      this.printEmptyLine();\n      this._print(util_1.default.inspect(err));\n    }\n  }\n  _logContractAndFunctionName(trace, code, {\n    printNonContractCalled = false\n  } = {}) {\n    if (trace === undefined) {\n      return;\n    }\n    if ((0, message_trace_1.isPrecompileTrace)(trace)) {\n      this._logWithTitle(\"Precompile call\", `<PrecompileContract ${trace.precompile}>`);\n      return;\n    }\n    if ((0, message_trace_1.isCreateTrace)(trace)) {\n      if (trace.bytecode === undefined) {\n        this._logWithTitle(\"Contract deployment\", solidity_stack_trace_1.UNRECOGNIZED_CONTRACT_NAME);\n      } else {\n        this._logWithTitle(\"Contract deployment\", trace.bytecode.contract.name);\n      }\n      if (trace.deployedContract !== undefined && trace.error === undefined) {\n        this._logWithTitle(\"Contract address\", (0, ethereumjs_util_1.bufferToHex)(trace.deployedContract));\n      }\n      return;\n    }\n    if (code.length === 0) {\n      if (printNonContractCalled) {\n        this._log(`WARNING: Calling an account which is not a contract`);\n      }\n      return;\n    }\n    if (trace.bytecode === undefined) {\n      this._logWithTitle(\"Contract call\", solidity_stack_trace_1.UNRECOGNIZED_CONTRACT_NAME);\n      return;\n    }\n    const func = trace.bytecode.contract.getFunctionFromSelector(trace.calldata.slice(0, 4));\n    const functionName = func === undefined ? solidity_stack_trace_1.UNRECOGNIZED_FUNCTION_NAME : func.type === model_1.ContractFunctionType.FALLBACK ? solidity_stack_trace_1.FALLBACK_FUNCTION_NAME : func.type === model_1.ContractFunctionType.RECEIVE ? solidity_stack_trace_1.RECEIVE_FUNCTION_NAME : func.name;\n    this._logWithTitle(\"Contract call\", `${trace.bytecode.contract.name}#${functionName}`);\n  }\n  _shouldCollapseMethod(method) {\n    return method === this._methodBeingCollapsed && !this._hasLogs() && this._methodCollapsedCount > 0;\n  }\n  _startCollapsingMethod(method) {\n    this._methodBeingCollapsed = method;\n    this._methodCollapsedCount = 1;\n  }\n  _stopCollapsingMethod() {\n    this._methodBeingCollapsed = undefined;\n    this._methodCollapsedCount = 0;\n  }\n  _logTxTo(to, trace) {\n    if (trace !== undefined && (0, message_trace_1.isCreateTrace)(trace)) {\n      return;\n    }\n    if (to === undefined) {\n      // only for the type-checker, since `to` is undefined only when\n      // the message is a create trace\n      return;\n    }\n    const toString = (0, ethereumjs_util_1.bufferToHex)(to);\n    this._logWithTitle(\"To\", toString);\n  }\n  _logTxValue(value) {\n    this._logWithTitle(\"Value\", (0, wei_values_1.weiToHumanReadableString)(value));\n  }\n  _logTxFrom(from) {\n    this._logWithTitle(\"From\", (0, ethereumjs_util_1.bufferToHex)(from));\n  }\n  _logBlockNumber(block) {\n    this._log(`Block #${block.header.number}: ${(0, ethereumjs_util_1.bufferToHex)(block.hash())}`);\n  }\n  _logEmptyLineBetweenTransactions(currentIndex, totalTransactions) {\n    if (currentIndex + 1 < totalTransactions && totalTransactions > 1) {\n      this.logEmptyLine();\n    }\n  }\n  _logBlockHash(block) {\n    this._log(`Block: ${(0, ethereumjs_util_1.bufferToHex)(block.hash())}`);\n  }\n  _logConsoleLogMessages(messages) {\n    // This is a especial case, as we always want to print the console.log\n    // messages. The difference is how.\n    // If we have a logger, we should use that, so that logs are printed in\n    // order. If we don't, we just print the messages here.\n    if (!this._enabled) {\n      for (const msg of messages) {\n        this._printLine(msg);\n      }\n      return;\n    }\n    if (messages.length === 0) {\n      return;\n    }\n    this.logEmptyLine();\n    this._log(\"console.log:\");\n    for (const msg of messages) {\n      this._log(`  ${msg}`);\n    }\n  }\n  _logWithTitle(title, message) {\n    title = this._indentSingleLine(title);\n    // We always use the max title length we've seen. Otherwise the value move\n    // a lot with each tx/call.\n    if (title.length > this._titleLength) {\n      this._titleLength = title.length;\n    }\n    this._logs.push([title, message]);\n  }\n  _clearLogs() {\n    this._logs = [];\n  }\n  _hasLogs() {\n    return this._logs.length > 0;\n  }\n  _getLogs() {\n    return this._logs.map(l => {\n      if (typeof l === \"string\") {\n        return l;\n      }\n      const title = `${l[0]}:`;\n      return `${title.padEnd(this._titleLength + 1)} ${l[1]}`;\n    });\n  }\n}\nexports.ModulesLogger = ModulesLogger;","map":{"version":3,"names":["ethereumjs_util_1","require","ansi_escapes_1","__importDefault","chalk_1","util_1","errors_1","errors_2","wei_values_1","message_trace_1","model_1","solidity_errors_1","solidity_stack_trace_1","printLine","line","console","log","replaceLastLine","newLine","process","stdout","isTTY","write","default","cursorHide","cursorPrevLine","eraseEndLine","cursorShow","ModulesLogger","constructor","_enabled","_printLine","_replaceLastLine","_logs","_titleLength","_currentIndent","_emptyIntervalMinedBlocksRangeStart","undefined","_emptyHardhatMinedBlocksRangeStart","_methodCollapsedCount","isEnabled","setEnabled","enabled","isLoggedError","err","SolidityError","TransactionExecutionError","logBlockFromAutomine","result","codes","txHashToHighlight","block","blockResult","traces","results","assertHardhatInvariant","length","_indent","_logBlockNumber","_logBaseFeePerGas","i","transactions","tx","txGasUsed","totalGasSpent","txTrace","code","highlightTxHash","hash","equals","_logTxInsideBlock","_logEmptyLineBetweenTransactions","logMinedBlock","blockNumber","header","number","isEmpty","logMinedBlockNumber","baseFeePerGas","_logBlockHash","logIntervalMinedBlock","logSingleTransaction","_logContractAndFunctionName","trace","txHash","bufferToHex","_logWithTitle","_logTxFrom","getSenderAddress","toBuffer","_logTxTo","to","_logTxValue","value","gasLimit","_logConsoleLogMessages","consoleLogMessages","error","_logError","logCurrentlySentTransaction","_log","logEmptyLine","logEstimateGasTrace","callParams","printNonContractCalled","from","logCallTrace","toString","logMultipleTransactionsWarning","logMultipleBlocksWarning","printErrorMessage","errorMessage","_print","printFailedMethod","method","color","red","printLogs","logs","_getLogs","msg","_clearLogs","printIntervalMinedBlockNumber","collapseIntervalMinedBlock","logEmptyHardhatMinedBlock","collapseHardhatMinedBlock","printMetaMaskWarning","message","yellow","printMethod","_shouldCollapseMethod","green","collapsePrintedMethod","_startCollapsingMethod","printMethodNotSupported","printEmptyLine","printUnknownError","_printError","_format","split","map","repeat","join","cb","_indentSingleLine","printOptions","_stopCollapsingMethod","formattedMessage","push","inspect","bold","isPrecompileTrace","precompile","isCreateTrace","bytecode","UNRECOGNIZED_CONTRACT_NAME","contract","name","deployedContract","func","getFunctionFromSelector","calldata","slice","functionName","UNRECOGNIZED_FUNCTION_NAME","type","ContractFunctionType","FALLBACK","FALLBACK_FUNCTION_NAME","RECEIVE","RECEIVE_FUNCTION_NAME","_methodBeingCollapsed","_hasLogs","weiToHumanReadableString","currentIndex","totalTransactions","messages","title","l","padEnd","exports"],"sources":["/Users/mukuljindal/Local/projects/fuckingwork/node_modules/hardhat/src/internal/hardhat-network/provider/modules/logger.ts"],"sourcesContent":["import { Block } from \"@nomicfoundation/ethereumjs-block\";\nimport { TypedTransaction } from \"@nomicfoundation/ethereumjs-tx\";\nimport { bufferToHex } from \"@nomicfoundation/ethereumjs-util\";\nimport ansiEscapes from \"ansi-escapes\";\nimport chalk, { Chalk } from \"chalk\";\nimport util from \"util\";\n\nimport { assertHardhatInvariant } from \"../../../core/errors\";\nimport { TransactionExecutionError } from \"../../../core/providers/errors\";\nimport { weiToHumanReadableString } from \"../../../util/wei-values\";\nimport {\n  isCreateTrace,\n  isPrecompileTrace,\n  MessageTrace,\n} from \"../../stack-traces/message-trace\";\nimport { ContractFunctionType } from \"../../stack-traces/model\";\nimport { SolidityError } from \"../../stack-traces/solidity-errors\";\nimport {\n  FALLBACK_FUNCTION_NAME,\n  RECEIVE_FUNCTION_NAME,\n  UNRECOGNIZED_CONTRACT_NAME,\n  UNRECOGNIZED_FUNCTION_NAME,\n} from \"../../stack-traces/solidity-stack-trace\";\nimport { CallParams, GatherTracesResult, MineBlockResult } from \"../node-types\";\n\ninterface PrintOptions {\n  color?: Chalk;\n  replaceLastLine?: boolean;\n  collapsePrintedMethod?: boolean;\n  collapseIntervalMinedBlock?: boolean;\n  collapseHardhatMinedBlock?: boolean;\n}\n\nfunction printLine(line: string) {\n  console.log(line);\n}\n\nfunction replaceLastLine(newLine: string) {\n  if (process.stdout.isTTY === true) {\n    process.stdout.write(\n      // eslint-disable-next-line prefer-template\n      ansiEscapes.cursorHide +\n        ansiEscapes.cursorPrevLine +\n        newLine +\n        ansiEscapes.eraseEndLine +\n        \"\\n\" +\n        ansiEscapes.cursorShow\n    );\n  } else {\n    process.stdout.write(`${newLine}\\n`);\n  }\n}\n\n/**\n * Handles all the logging made from the Hardhat Network.\n *\n * Methods of this class follow this convention:\n * - Methods that start with `log` add those messages to a list of things to log\n * - Methods that start with `print` print to stdout immediately\n */\nexport class ModulesLogger {\n  private _logs: Array<string | [string, string]> = [];\n  private _titleLength = 0;\n  private _currentIndent = 0;\n  private _emptyIntervalMinedBlocksRangeStart: bigint | undefined = undefined;\n  private _emptyHardhatMinedBlocksRangeStart: bigint | undefined = undefined;\n  private _methodBeingCollapsed?: string;\n  private _methodCollapsedCount: number = 0;\n\n  constructor(\n    private _enabled: boolean,\n    private _printLine = printLine,\n    private _replaceLastLine = replaceLastLine\n  ) {}\n\n  public isEnabled() {\n    return this._enabled;\n  }\n\n  public setEnabled(enabled: boolean) {\n    this._enabled = enabled;\n  }\n\n  public isLoggedError(err: Error) {\n    return (\n      err instanceof SolidityError || err instanceof TransactionExecutionError\n    );\n  }\n\n  public logBlockFromAutomine(\n    result: MineBlockResult,\n    codes: Buffer[],\n    txHashToHighlight: Buffer\n  ) {\n    const { block, blockResult, traces } = result;\n    const { results } = blockResult;\n\n    assertHardhatInvariant(\n      results.length === codes.length,\n      \"The array of codes should have the same length as the array of results\"\n    );\n\n    this._indent(() => {\n      this._logBlockNumber(block);\n\n      this._indent(() => {\n        this._logBaseFeePerGas(block);\n\n        for (let i = 0; i < block.transactions.length; i++) {\n          const tx = block.transactions[i];\n\n          const txGasUsed = results[i].totalGasSpent;\n          const txTrace = traces[i];\n          const code = codes[i];\n\n          const highlightTxHash = tx.hash().equals(txHashToHighlight);\n\n          this._logTxInsideBlock(tx, txTrace, code, txGasUsed, {\n            highlightTxHash,\n          });\n\n          this._logEmptyLineBetweenTransactions(i, block.transactions.length);\n        }\n      });\n    });\n  }\n\n  public logMinedBlock(result: MineBlockResult, codes: Buffer[]) {\n    const { block, blockResult, traces } = result;\n    const { results } = blockResult;\n\n    assertHardhatInvariant(\n      results.length === codes.length,\n      \"The array of codes should have the same length as the array of results\"\n    );\n\n    const blockNumber = result.block.header.number;\n    const isEmpty = result.block.transactions.length === 0;\n\n    this._indent(() => {\n      this.logMinedBlockNumber(\n        blockNumber,\n        isEmpty,\n        block.header.baseFeePerGas\n      );\n\n      if (isEmpty) {\n        return;\n      }\n\n      this._indent(() => {\n        this._logBlockHash(block);\n\n        this._indent(() => {\n          this._logBaseFeePerGas(block);\n\n          for (let i = 0; i < block.transactions.length; i++) {\n            const tx = block.transactions[i];\n            const txGasUsed = results[i].totalGasSpent;\n            const txTrace = traces[i];\n            const code = codes[i];\n\n            this._logTxInsideBlock(tx, txTrace, code, txGasUsed, {\n              highlightTxHash: false,\n            });\n\n            this._logEmptyLineBetweenTransactions(i, block.transactions.length);\n          }\n        });\n      });\n    });\n  }\n\n  public logIntervalMinedBlock(result: MineBlockResult, codes: Buffer[]) {\n    const { block, blockResult, traces } = result;\n    const { results } = blockResult;\n\n    assertHardhatInvariant(\n      results.length === codes.length,\n      \"The array of codes should have the same length as the array of results\"\n    );\n\n    this._indent(() => {\n      this._logBlockHash(block);\n\n      this._indent(() => {\n        this._logBaseFeePerGas(block);\n\n        for (let i = 0; i < block.transactions.length; i++) {\n          const tx = block.transactions[i];\n          const txGasUsed = results[i].totalGasSpent;\n          const txTrace = traces[i];\n          const code = codes[i];\n\n          this._logTxInsideBlock(tx, txTrace, code, txGasUsed, {\n            highlightTxHash: false,\n          });\n\n          this._logEmptyLineBetweenTransactions(i, block.transactions.length);\n        }\n      });\n    });\n  }\n\n  public logSingleTransaction(\n    tx: TypedTransaction,\n    block: Block,\n    txGasUsed: bigint,\n    txTrace: GatherTracesResult,\n    code: Buffer\n  ) {\n    this._indent(() => {\n      this._logContractAndFunctionName(txTrace.trace, code);\n\n      const txHash = bufferToHex(tx.hash());\n\n      this._logWithTitle(\"Transaction\", txHash);\n\n      this._logTxFrom(tx.getSenderAddress().toBuffer());\n      this._logTxTo(tx.to?.toBuffer(), txTrace.trace);\n      this._logTxValue(tx.value);\n      this._logWithTitle(\"Gas used\", `${txGasUsed} of ${tx.gasLimit}`);\n\n      this._logWithTitle(\n        `Block #${block.header.number}`,\n        bufferToHex(block.hash())\n      );\n\n      this._logConsoleLogMessages(txTrace.consoleLogMessages);\n\n      if (txTrace.error !== undefined) {\n        this._logError(txTrace.error);\n      }\n    });\n  }\n\n  public logCurrentlySentTransaction(\n    tx: TypedTransaction,\n    txGasUsed: bigint,\n    txTrace: GatherTracesResult,\n    code: Buffer,\n    block: Block\n  ) {\n    this._indent(() => {\n      this._log(\"Currently sent transaction:\");\n      this.logEmptyLine();\n\n      this._logContractAndFunctionName(txTrace.trace, code);\n\n      const txHash = bufferToHex(tx.hash());\n\n      this._logWithTitle(\"Transaction\", txHash);\n\n      this._logTxFrom(tx.getSenderAddress().toBuffer());\n      this._logTxTo(tx.to?.toBuffer(), txTrace.trace);\n      this._logTxValue(tx.value);\n      this._logWithTitle(\"Gas used\", `${txGasUsed} of ${tx.gasLimit}`);\n\n      this._logWithTitle(\n        `Block #${block.header.number}`,\n        bufferToHex(block.hash())\n      );\n\n      this._logConsoleLogMessages(txTrace.consoleLogMessages);\n\n      if (txTrace.error !== undefined) {\n        this._logError(txTrace.error);\n      }\n    });\n  }\n\n  public logEstimateGasTrace(\n    callParams: CallParams,\n    code: Buffer,\n    trace: MessageTrace | undefined,\n    consoleLogMessages: string[],\n    error: Error\n  ) {\n    this._indent(() => {\n      this._logContractAndFunctionName(trace, code, {\n        printNonContractCalled: true,\n      });\n\n      this._logTxFrom(callParams.from);\n      this._logTxTo(callParams.to, trace);\n      this._logTxValue(callParams.value);\n\n      this._logConsoleLogMessages(consoleLogMessages);\n\n      this._logError(error);\n    });\n  }\n\n  public logCallTrace(\n    callParams: CallParams,\n    code: Buffer,\n    trace: MessageTrace | undefined,\n    consoleLogMessages: string[],\n    error: Error | undefined\n  ) {\n    this._indent(() => {\n      this._logContractAndFunctionName(trace, code, {\n        printNonContractCalled: true,\n      });\n\n      this._logTxFrom(callParams.from);\n      this._logTxTo(callParams.to, trace);\n      if (callParams.value > 0n) {\n        this._logTxValue(callParams.value);\n      }\n\n      this._logConsoleLogMessages(consoleLogMessages);\n\n      if (error !== undefined) {\n        // TODO: If throwOnCallFailures is false, this will log the error, but the RPC method won't be red\n        this._logError(error);\n      }\n    });\n  }\n\n  public logMinedBlockNumber(\n    blockNumber: bigint,\n    isEmpty: boolean,\n    baseFeePerGas?: bigint\n  ) {\n    if (isEmpty) {\n      this._log(\n        `Mined empty block #${blockNumber}${\n          baseFeePerGas !== undefined\n            ? ` with base fee ${baseFeePerGas.toString()}`\n            : \"\"\n        }`\n      );\n\n      return;\n    }\n\n    this._log(`Mined block #${blockNumber}`);\n  }\n\n  public logMultipleTransactionsWarning() {\n    this._indent(() => {\n      this._log(\n        \"There were other pending transactions mined in the same block:\"\n      );\n    });\n    this.logEmptyLine();\n  }\n\n  public logMultipleBlocksWarning() {\n    this._indent(() => {\n      this._log(\n        \"There were other pending transactions. More than one block had to be mined:\"\n      );\n    });\n    this.logEmptyLine();\n  }\n\n  public logEmptyLine() {\n    this._log(\"\");\n  }\n\n  private _logBaseFeePerGas(block: Block) {\n    if (block.header.baseFeePerGas !== undefined) {\n      this._log(`Base fee: ${block.header.baseFeePerGas.toString()}`);\n    }\n  }\n\n  public printErrorMessage(errorMessage: string) {\n    this._indent(() => {\n      this._print(errorMessage);\n    });\n  }\n\n  public printFailedMethod(method: string) {\n    this._print(method, { color: chalk.red });\n  }\n\n  /**\n   * Print all accumulated logs\n   */\n  public printLogs(): boolean {\n    const logs = this._getLogs();\n    if (logs.length === 0) {\n      return false;\n    }\n\n    for (const msg of logs) {\n      this._print(msg);\n    }\n\n    this._clearLogs();\n\n    return true;\n  }\n\n  public printIntervalMinedBlockNumber(\n    blockNumber: bigint,\n    isEmpty: boolean,\n    baseFeePerGas?: bigint\n  ) {\n    if (this._emptyIntervalMinedBlocksRangeStart !== undefined) {\n      this._print(\n        `Mined empty block range #${this._emptyIntervalMinedBlocksRangeStart} to #${blockNumber}`,\n        { collapseIntervalMinedBlock: true, replaceLastLine: true }\n      );\n    } else {\n      this._emptyIntervalMinedBlocksRangeStart = blockNumber;\n\n      if (isEmpty) {\n        this._print(\n          `Mined empty block #${blockNumber}${\n            baseFeePerGas !== undefined\n              ? ` with base fee ${baseFeePerGas.toString()}`\n              : \"\"\n          }`,\n          {\n            collapseIntervalMinedBlock: true,\n          }\n        );\n\n        return;\n      }\n\n      this._print(`Mined block #${blockNumber}`, {\n        collapseIntervalMinedBlock: true,\n      });\n    }\n  }\n\n  public logEmptyHardhatMinedBlock(\n    blockNumber: bigint,\n    baseFeePerGas?: bigint\n  ) {\n    this._indent(() => {\n      if (this._emptyHardhatMinedBlocksRangeStart !== undefined) {\n        this._log(\n          `Mined empty block range #${this._emptyHardhatMinedBlocksRangeStart} to #${blockNumber}`,\n          { collapseHardhatMinedBlock: true, replaceLastLine: true }\n        );\n      } else {\n        this._emptyHardhatMinedBlocksRangeStart = blockNumber;\n\n        this._log(\n          `Mined empty block #${blockNumber}${\n            baseFeePerGas !== undefined\n              ? ` with base fee ${baseFeePerGas.toString()}`\n              : \"\"\n          }`,\n          {\n            collapseHardhatMinedBlock: true,\n          }\n        );\n\n        return;\n      }\n    });\n  }\n\n  public printMetaMaskWarning() {\n    const message =\n      \"If you are using MetaMask, you can learn how to fix this error here: https://hardhat.org/metamask-issue\";\n\n    this._indent(() => {\n      this._print(message, { color: chalk.yellow });\n    });\n  }\n\n  public printMethod(method: string) {\n    if (this._shouldCollapseMethod(method)) {\n      this._methodCollapsedCount += 1;\n\n      this._print(chalk.green(`${method} (${this._methodCollapsedCount})`), {\n        collapsePrintedMethod: true,\n        replaceLastLine: true,\n      });\n    } else {\n      this._startCollapsingMethod(method);\n      this._print(method, { color: chalk.green, collapsePrintedMethod: true });\n    }\n  }\n\n  public printMethodNotSupported(method: string) {\n    this._print(`${method} - Method not supported`, { color: chalk.red });\n  }\n\n  public printEmptyLine() {\n    this._print(\"\");\n  }\n\n  public printUnknownError(err: Error) {\n    this._indent(() => {\n      this._printError(err);\n      this.printEmptyLine();\n\n      this._print(\n        \"If you think this is a bug in Hardhat, please report it here: https://hardhat.org/report-bug\"\n      );\n    });\n  }\n\n  private _format(msg: string, { color }: PrintOptions = {}): string {\n    if (msg === \"\") {\n      // don't indent empty lines\n      return msg;\n    }\n\n    if (this._currentIndent > 0) {\n      msg = msg\n        .split(\"\\n\")\n        .map((line) => \" \".repeat(this._currentIndent) + line)\n        .join(\"\\n\");\n    }\n\n    if (color !== undefined) {\n      return color(msg);\n    }\n\n    return msg;\n  }\n\n  private _indent<T>(cb: () => T, enabled = true) {\n    if (enabled) {\n      this._currentIndent += 2;\n    }\n    try {\n      return cb();\n    } finally {\n      if (enabled) {\n        this._currentIndent -= 2;\n      }\n    }\n  }\n\n  private _indentSingleLine(message: string): string {\n    return \" \".repeat(this._currentIndent) + message;\n  }\n\n  private _log(msg: string, printOptions: PrintOptions = {}) {\n    if (printOptions.collapsePrintedMethod !== true) {\n      this._stopCollapsingMethod();\n    }\n    if (printOptions.collapseIntervalMinedBlock !== true) {\n      this._emptyIntervalMinedBlocksRangeStart = undefined;\n    }\n    if (printOptions.collapseHardhatMinedBlock !== true) {\n      this._emptyHardhatMinedBlocksRangeStart = undefined;\n    }\n    const formattedMessage = this._format(msg, printOptions);\n\n    if (printOptions.replaceLastLine === true) {\n      this._logs[this._logs.length - 1] = formattedMessage;\n    } else {\n      this._logs.push(formattedMessage);\n    }\n  }\n\n  private _logError(err: Error) {\n    if (this.isLoggedError(err)) {\n      this.logEmptyLine();\n      this._log(util.inspect(err));\n    }\n  }\n\n  private _logTxInsideBlock(\n    tx: TypedTransaction,\n    txTrace: GatherTracesResult,\n    code: Buffer,\n    txGasUsed: bigint,\n    {\n      highlightTxHash,\n    }: {\n      highlightTxHash: boolean;\n    }\n  ) {\n    // indentAfterTransactionHash: true,\n    // printTxBlockNumber: false,\n    // startWithTxHash: true,\n    let txHash = bufferToHex(tx.hash());\n\n    if (highlightTxHash) {\n      txHash = chalk.bold(txHash);\n    }\n\n    this._logWithTitle(\"Transaction\", txHash);\n\n    this._indent(() => {\n      this._logContractAndFunctionName(txTrace.trace, code);\n      this._logTxFrom(tx.getSenderAddress().toBuffer());\n      this._logTxTo(tx.to?.toBuffer(), txTrace.trace);\n      this._logTxValue(tx.value);\n      this._logWithTitle(\"Gas used\", `${txGasUsed} of ${tx.gasLimit}`);\n\n      this._logConsoleLogMessages(txTrace.consoleLogMessages);\n\n      if (txTrace.error !== undefined) {\n        this._logError(txTrace.error);\n      }\n    });\n  }\n\n  /**\n   *  This should be the only function that calls _printLine and\n   *  _replaceLastLine (except for the special console.sol case),\n   *  because it's the only function that checks if the logger\n   *  is enabled.\n   */\n  private _print(msg: string, printOptions: PrintOptions = {}) {\n    if (!this._enabled) {\n      return;\n    }\n\n    if (printOptions.collapsePrintedMethod !== true) {\n      this._stopCollapsingMethod();\n    }\n    if (printOptions.collapseIntervalMinedBlock !== true) {\n      this._emptyIntervalMinedBlocksRangeStart = undefined;\n    }\n    if (printOptions.collapseHardhatMinedBlock !== true) {\n      this._emptyHardhatMinedBlocksRangeStart = undefined;\n    }\n    const formattedMessage = this._format(msg, printOptions);\n\n    if (printOptions.replaceLastLine === true) {\n      this._replaceLastLine(formattedMessage);\n    } else {\n      this._printLine(formattedMessage);\n    }\n  }\n\n  private _printError(err: Error) {\n    if (this.isLoggedError(err)) {\n      this.printEmptyLine();\n      this._print(util.inspect(err));\n    }\n  }\n\n  private _logContractAndFunctionName(\n    trace: MessageTrace | undefined,\n    code: Buffer,\n    {\n      printNonContractCalled = false,\n    }: { printNonContractCalled?: boolean } = {}\n  ) {\n    if (trace === undefined) {\n      return;\n    }\n\n    if (isPrecompileTrace(trace)) {\n      this._logWithTitle(\n        \"Precompile call\",\n        `<PrecompileContract ${trace.precompile}>`\n      );\n      return;\n    }\n\n    if (isCreateTrace(trace)) {\n      if (trace.bytecode === undefined) {\n        this._logWithTitle(\"Contract deployment\", UNRECOGNIZED_CONTRACT_NAME);\n      } else {\n        this._logWithTitle(\"Contract deployment\", trace.bytecode.contract.name);\n      }\n\n      if (trace.deployedContract !== undefined && trace.error === undefined) {\n        this._logWithTitle(\n          \"Contract address\",\n          bufferToHex(trace.deployedContract)\n        );\n      }\n\n      return;\n    }\n\n    if (code.length === 0) {\n      if (printNonContractCalled) {\n        this._log(`WARNING: Calling an account which is not a contract`);\n      }\n\n      return;\n    }\n\n    if (trace.bytecode === undefined) {\n      this._logWithTitle(\"Contract call\", UNRECOGNIZED_CONTRACT_NAME);\n      return;\n    }\n\n    const func = trace.bytecode.contract.getFunctionFromSelector(\n      trace.calldata.slice(0, 4)\n    );\n\n    const functionName: string =\n      func === undefined\n        ? UNRECOGNIZED_FUNCTION_NAME\n        : func.type === ContractFunctionType.FALLBACK\n        ? FALLBACK_FUNCTION_NAME\n        : func.type === ContractFunctionType.RECEIVE\n        ? RECEIVE_FUNCTION_NAME\n        : func.name;\n\n    this._logWithTitle(\n      \"Contract call\",\n      `${trace.bytecode.contract.name}#${functionName}`\n    );\n  }\n\n  private _shouldCollapseMethod(method: string) {\n    return (\n      method === this._methodBeingCollapsed &&\n      !this._hasLogs() &&\n      this._methodCollapsedCount > 0\n    );\n  }\n\n  private _startCollapsingMethod(method: string) {\n    this._methodBeingCollapsed = method;\n    this._methodCollapsedCount = 1;\n  }\n\n  private _stopCollapsingMethod() {\n    this._methodBeingCollapsed = undefined;\n    this._methodCollapsedCount = 0;\n  }\n\n  private _logTxTo(to: Buffer | undefined, trace?: MessageTrace) {\n    if (trace !== undefined && isCreateTrace(trace)) {\n      return;\n    }\n    if (to === undefined) {\n      // only for the type-checker, since `to` is undefined only when\n      // the message is a create trace\n      return;\n    }\n\n    const toString = bufferToHex(to);\n\n    this._logWithTitle(\"To\", toString);\n  }\n\n  private _logTxValue(value: bigint) {\n    this._logWithTitle(\"Value\", weiToHumanReadableString(value));\n  }\n\n  private _logTxFrom(from: Buffer) {\n    this._logWithTitle(\"From\", bufferToHex(from));\n  }\n\n  private _logBlockNumber(block: Block) {\n    this._log(`Block #${block.header.number}: ${bufferToHex(block.hash())}`);\n  }\n\n  private _logEmptyLineBetweenTransactions(\n    currentIndex: number,\n    totalTransactions: number\n  ) {\n    if (currentIndex + 1 < totalTransactions && totalTransactions > 1) {\n      this.logEmptyLine();\n    }\n  }\n\n  private _logBlockHash(block: Block) {\n    this._log(`Block: ${bufferToHex(block.hash())}`);\n  }\n\n  private _logConsoleLogMessages(messages: string[]) {\n    // This is a especial case, as we always want to print the console.log\n    // messages. The difference is how.\n    // If we have a logger, we should use that, so that logs are printed in\n    // order. If we don't, we just print the messages here.\n    if (!this._enabled) {\n      for (const msg of messages) {\n        this._printLine(msg);\n      }\n      return;\n    }\n\n    if (messages.length === 0) {\n      return;\n    }\n\n    this.logEmptyLine();\n    this._log(\"console.log:\");\n\n    for (const msg of messages) {\n      this._log(`  ${msg}`);\n    }\n  }\n\n  private _logWithTitle(title: string, message: string) {\n    title = this._indentSingleLine(title);\n\n    // We always use the max title length we've seen. Otherwise the value move\n    // a lot with each tx/call.\n    if (title.length > this._titleLength) {\n      this._titleLength = title.length;\n    }\n\n    this._logs.push([title, message]);\n  }\n\n  private _clearLogs() {\n    this._logs = [];\n  }\n\n  private _hasLogs(): boolean {\n    return this._logs.length > 0;\n  }\n\n  private _getLogs(): string[] {\n    return this._logs.map((l) => {\n      if (typeof l === \"string\") {\n        return l;\n      }\n\n      const title = `${l[0]}:`;\n\n      return `${title.padEnd(this._titleLength + 1)} ${l[1]}`;\n    });\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}