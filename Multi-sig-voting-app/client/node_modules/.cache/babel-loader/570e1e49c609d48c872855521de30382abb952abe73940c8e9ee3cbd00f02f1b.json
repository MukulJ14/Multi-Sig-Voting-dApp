{"ast":null,"code":"import http from \"http\";\nimport https from \"https\";\nimport { gunzipSync } from \"zlib\";\nimport { assert } from \"./errors.js\";\nimport { getBytes } from \"./data.js\";\n/**\n *  @_ignore:\n */\nexport function createGetUrl(options) {\n  async function getUrl(req, signal) {\n    const protocol = req.url.split(\":\")[0].toLowerCase();\n    assert(protocol === \"http\" || protocol === \"https\", `unsupported protocol ${protocol}`, \"UNSUPPORTED_OPERATION\", {\n      info: {\n        protocol\n      },\n      operation: \"request\"\n    });\n    assert(protocol === \"https\" || !req.credentials || req.allowInsecureAuthentication, \"insecure authorized connections unsupported\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"request\"\n    });\n    const method = req.method;\n    const headers = Object.assign({}, req.headers);\n    const reqOptions = {\n      method,\n      headers\n    };\n    if (options) {\n      if (options.agent) {\n        reqOptions.agent = options.agent;\n      }\n    }\n    const request = (protocol === \"http\" ? http : https).request(req.url, reqOptions);\n    request.setTimeout(req.timeout);\n    const body = req.body;\n    if (body) {\n      request.write(Buffer.from(body));\n    }\n    request.end();\n    return new Promise((resolve, reject) => {\n      // @TODO: Node 15 added AbortSignal; once we drop support for\n      // Node14, we can add that in here too\n      request.once(\"response\", resp => {\n        const statusCode = resp.statusCode || 0;\n        const statusMessage = resp.statusMessage || \"\";\n        const headers = Object.keys(resp.headers || {}).reduce((accum, name) => {\n          let value = resp.headers[name] || \"\";\n          if (Array.isArray(value)) {\n            value = value.join(\", \");\n          }\n          accum[name] = value;\n          return accum;\n        }, {});\n        let body = null;\n        //resp.setEncoding(\"utf8\");\n        resp.on(\"data\", chunk => {\n          if (signal) {\n            try {\n              signal.checkSignal();\n            } catch (error) {\n              return reject(error);\n            }\n          }\n          if (body == null) {\n            body = chunk;\n          } else {\n            const newBody = new Uint8Array(body.length + chunk.length);\n            newBody.set(body, 0);\n            newBody.set(chunk, body.length);\n            body = newBody;\n          }\n        });\n        resp.on(\"end\", () => {\n          if (headers[\"content-encoding\"] === \"gzip\" && body) {\n            body = getBytes(gunzipSync(body));\n          }\n          resolve({\n            statusCode,\n            statusMessage,\n            headers,\n            body\n          });\n        });\n        resp.on(\"error\", error => {\n          //@TODO: Should this just return nornal response with a server error?\n          error.response = {\n            statusCode,\n            statusMessage,\n            headers,\n            body\n          };\n          reject(error);\n        });\n      });\n      request.on(\"error\", error => {\n        reject(error);\n      });\n    });\n  }\n  return getUrl;\n}\n// @TODO: remove in v7; provided for backwards compat\nconst defaultGetUrl = createGetUrl({});\n/**\n *  @_ignore:\n */\nexport async function getUrl(req, signal) {\n  return defaultGetUrl(req, signal);\n}","map":{"version":3,"names":["http","https","gunzipSync","assert","getBytes","createGetUrl","options","getUrl","req","signal","protocol","url","split","toLowerCase","info","operation","credentials","allowInsecureAuthentication","method","headers","Object","assign","reqOptions","agent","request","setTimeout","timeout","body","write","Buffer","from","end","Promise","resolve","reject","once","resp","statusCode","statusMessage","keys","reduce","accum","name","value","Array","isArray","join","on","chunk","checkSignal","error","newBody","Uint8Array","length","set","response","defaultGetUrl"],"sources":["/Users/mukuljindal/Local/projects/Multi-sig-voting-app/work/node_modules/ethers/src.ts/utils/geturl.ts"],"sourcesContent":["import http from \"http\";\nimport https from \"https\";\nimport { gunzipSync } from \"zlib\";\n\nimport { assert } from \"./errors.js\";\nimport { getBytes } from \"./data.js\";\n\nimport type {\n    FetchGetUrlFunc, FetchRequest, FetchCancelSignal, GetUrlResponse\n} from \"./fetch.js\";\n\n/**\n *  @_ignore:\n */\nexport function createGetUrl(options?: Record<string, any>): FetchGetUrlFunc {\n\n    async function getUrl(req: FetchRequest, signal?: FetchCancelSignal): Promise<GetUrlResponse> {\n\n        const protocol = req.url.split(\":\")[0].toLowerCase();\n\n        assert(protocol === \"http\" || protocol === \"https\", `unsupported protocol ${ protocol }`, \"UNSUPPORTED_OPERATION\", {\n            info: { protocol },\n            operation: \"request\"\n        });\n\n        assert(protocol === \"https\" || !req.credentials || req.allowInsecureAuthentication, \"insecure authorized connections unsupported\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"request\"\n        });\n\n        const method = req.method;\n        const headers = Object.assign({ }, req.headers);\n\n        const reqOptions: any = { method, headers };\n        if (options) {\n            if (options.agent) { reqOptions.agent = options.agent; }\n        }\n\n        const request = ((protocol === \"http\") ? http: https).request(req.url, reqOptions);\n\n        request.setTimeout(req.timeout);\n\n        const body = req.body;\n        if (body) { request.write(Buffer.from(body)); }\n\n        request.end();\n\n        return new Promise((resolve, reject) => {\n            // @TODO: Node 15 added AbortSignal; once we drop support for\n            // Node14, we can add that in here too\n\n            request.once(\"response\", (resp: http.IncomingMessage) => {\n                const statusCode = resp.statusCode || 0;\n                const statusMessage = resp.statusMessage || \"\";\n                const headers = Object.keys(resp.headers || {}).reduce((accum, name) => {\n                    let value = resp.headers[name] || \"\";\n                    if (Array.isArray(value)) {\n                        value = value.join(\", \");\n                    }\n                    accum[name] = value;\n                    return accum;\n                }, <{ [ name: string ]: string }>{ });\n\n                let body: null | Uint8Array = null;\n                //resp.setEncoding(\"utf8\");\n\n                resp.on(\"data\", (chunk: Uint8Array) => {\n                    if (signal) {\n                        try {\n                            signal.checkSignal();\n                        } catch (error) {\n                            return reject(error);\n                        }\n                    }\n\n                    if (body == null) {\n                        body = chunk;\n                    } else {\n                        const newBody = new Uint8Array(body.length + chunk.length);\n                        newBody.set(body, 0);\n                        newBody.set(chunk, body.length);\n                        body = newBody;\n                    }\n                });\n\n                resp.on(\"end\", () => {\n                    if (headers[\"content-encoding\"] === \"gzip\" && body) {\n                        body = getBytes(gunzipSync(body));\n                    }\n\n                    resolve({ statusCode, statusMessage, headers, body });\n                });\n\n                resp.on(\"error\", (error) => {\n                //@TODO: Should this just return nornal response with a server error?\n                    (<any>error).response = { statusCode, statusMessage, headers, body };\n                    reject(error);\n                });\n            });\n\n            request.on(\"error\", (error) => { reject(error); });\n        });\n    }\n\n    return getUrl;\n}\n\n// @TODO: remove in v7; provided for backwards compat\nconst defaultGetUrl: FetchGetUrlFunc = createGetUrl({ });\n\n/**\n *  @_ignore:\n */\nexport async function getUrl(req: FetchRequest, signal?: FetchCancelSignal): Promise<GetUrlResponse> {\n    return defaultGetUrl(req, signal);\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}