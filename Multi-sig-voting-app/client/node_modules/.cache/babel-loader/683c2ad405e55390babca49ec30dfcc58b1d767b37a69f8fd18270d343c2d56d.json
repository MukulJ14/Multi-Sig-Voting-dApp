{"ast":null,"code":"\"use strict\";\n\nvar _a, _b;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createEsmHooks = exports.createFromPreloadedConfig = exports.create = exports.register = exports.TSError = exports.DEFAULTS = exports.VERSION = exports.debug = exports.INSPECT_CUSTOM = exports.env = exports.REGISTER_INSTANCE = exports.createRepl = void 0;\nconst path_1 = require(\"path\");\nconst module_1 = require(\"module\");\nconst util = require(\"util\");\nconst url_1 = require(\"url\");\nconst make_error_1 = require(\"make-error\");\nconst util_1 = require(\"./util\");\nconst configuration_1 = require(\"./configuration\");\nconst module_type_classifier_1 = require(\"./module-type-classifier\");\nconst resolver_functions_1 = require(\"./resolver-functions\");\nconst cjs_resolve_hooks_1 = require(\"./cjs-resolve-hooks\");\nconst node_module_type_classifier_1 = require(\"./node-module-type-classifier\");\nconst file_extensions_1 = require(\"./file-extensions\");\nconst ts_transpile_module_1 = require(\"./ts-transpile-module\");\nvar repl_1 = require(\"./repl\");\nObject.defineProperty(exports, \"createRepl\", {\n  enumerable: true,\n  get: function () {\n    return repl_1.createRepl;\n  }\n});\n/**\n * Does this version of node obey the package.json \"type\" field\n * and throw ERR_REQUIRE_ESM when attempting to require() an ESM modules.\n */\nconst engineSupportsPackageTypeField = parseInt(process.versions.node.split('.')[0], 10) >= 12;\n/**\n * Assert that script can be loaded as CommonJS when we attempt to require it.\n * If it should be loaded as ESM, throw ERR_REQUIRE_ESM like node does.\n *\n * Loaded conditionally so we don't need to support older node versions\n */\nlet assertScriptCanLoadAsCJS = engineSupportsPackageTypeField ? require('../dist-raw/node-internal-modules-cjs-loader').assertScriptCanLoadAsCJSImpl : () => {\n  /* noop */\n};\n/**\n * Registered `ts-node` instance information.\n */\nexports.REGISTER_INSTANCE = Symbol.for('ts-node.register.instance');\n/** @internal */\nexports.env = process.env;\n/**\n * @internal\n */\nexports.INSPECT_CUSTOM = util.inspect.custom || 'inspect';\n/**\n * Debugging `ts-node`.\n */\nconst shouldDebug = (0, util_1.yn)(exports.env.TS_NODE_DEBUG);\n/** @internal */\nexports.debug = shouldDebug ? (...args) => console.log(`[ts-node ${new Date().toISOString()}]`, ...args) : () => undefined;\nconst debugFn = shouldDebug ? (key, fn) => {\n  let i = 0;\n  return x => {\n    (0, exports.debug)(key, x, ++i);\n    return fn(x);\n  };\n} : (_, fn) => fn;\n/**\n * Export the current version.\n */\nexports.VERSION = require('../package.json').version;\n/**\n * Default register options, including values specified via environment\n * variables.\n * @internal\n */\nexports.DEFAULTS = {\n  cwd: (_a = exports.env.TS_NODE_CWD) !== null && _a !== void 0 ? _a : exports.env.TS_NODE_DIR,\n  emit: (0, util_1.yn)(exports.env.TS_NODE_EMIT),\n  scope: (0, util_1.yn)(exports.env.TS_NODE_SCOPE),\n  scopeDir: exports.env.TS_NODE_SCOPE_DIR,\n  files: (0, util_1.yn)(exports.env.TS_NODE_FILES),\n  pretty: (0, util_1.yn)(exports.env.TS_NODE_PRETTY),\n  compiler: exports.env.TS_NODE_COMPILER,\n  compilerOptions: (0, util_1.parse)(exports.env.TS_NODE_COMPILER_OPTIONS),\n  ignore: (0, util_1.split)(exports.env.TS_NODE_IGNORE),\n  project: exports.env.TS_NODE_PROJECT,\n  skipProject: (0, util_1.yn)(exports.env.TS_NODE_SKIP_PROJECT),\n  skipIgnore: (0, util_1.yn)(exports.env.TS_NODE_SKIP_IGNORE),\n  preferTsExts: (0, util_1.yn)(exports.env.TS_NODE_PREFER_TS_EXTS),\n  ignoreDiagnostics: (0, util_1.split)(exports.env.TS_NODE_IGNORE_DIAGNOSTICS),\n  transpileOnly: (0, util_1.yn)(exports.env.TS_NODE_TRANSPILE_ONLY),\n  typeCheck: (0, util_1.yn)(exports.env.TS_NODE_TYPE_CHECK),\n  compilerHost: (0, util_1.yn)(exports.env.TS_NODE_COMPILER_HOST),\n  logError: (0, util_1.yn)(exports.env.TS_NODE_LOG_ERROR),\n  experimentalReplAwait: (_b = (0, util_1.yn)(exports.env.TS_NODE_EXPERIMENTAL_REPL_AWAIT)) !== null && _b !== void 0 ? _b : undefined,\n  tsTrace: console.log.bind(console)\n};\n/**\n * TypeScript diagnostics error.\n */\nclass TSError extends make_error_1.BaseError {\n  constructor(diagnosticText, diagnosticCodes, diagnostics = []) {\n    super(`тип Unable to compile TypeScript:\\n${diagnosticText}`);\n    this.diagnosticCodes = diagnosticCodes;\n    this.name = 'TSError';\n    Object.defineProperty(this, 'diagnosticText', {\n      configurable: true,\n      writable: true,\n      value: diagnosticText\n    });\n    Object.defineProperty(this, 'diagnostics', {\n      configurable: true,\n      writable: true,\n      value: diagnostics\n    });\n  }\n  /**\n   * @internal\n   */\n  [exports.INSPECT_CUSTOM]() {\n    return this.diagnosticText;\n  }\n}\nexports.TSError = TSError;\nconst TS_NODE_SERVICE_BRAND = Symbol('TS_NODE_SERVICE_BRAND');\nfunction register(serviceOrOpts) {\n  // Is this a Service or a RegisterOptions?\n  let service = serviceOrOpts;\n  if (!(serviceOrOpts === null || serviceOrOpts === void 0 ? void 0 : serviceOrOpts[TS_NODE_SERVICE_BRAND])) {\n    // Not a service; is options\n    service = create(serviceOrOpts !== null && serviceOrOpts !== void 0 ? serviceOrOpts : {});\n  }\n  const originalJsHandler = require.extensions['.js'];\n  // Expose registered instance globally.\n  process[exports.REGISTER_INSTANCE] = service;\n  // Register the extensions.\n  registerExtensions(service.options.preferTsExts, service.extensions.compiled, service, originalJsHandler);\n  (0, cjs_resolve_hooks_1.installCommonjsResolveHooksIfNecessary)(service);\n  // Require specified modules before start-up.\n  module_1.Module._preloadModules(service.options.require);\n  return service;\n}\nexports.register = register;\n/**\n * Create TypeScript compiler instance.\n *\n * @category Basic\n */\nfunction create(rawOptions = {}) {\n  const foundConfigResult = (0, configuration_1.findAndReadConfig)(rawOptions);\n  return createFromPreloadedConfig(foundConfigResult);\n}\nexports.create = create;\n/** @internal */\nfunction createFromPreloadedConfig(foundConfigResult) {\n  var _a, _b, _c, _d;\n  const {\n    configFilePath,\n    cwd,\n    options,\n    config,\n    compiler,\n    projectLocalResolveDir,\n    optionBasePaths\n  } = foundConfigResult;\n  const projectLocalResolveHelper = (0, util_1.createProjectLocalResolveHelper)(projectLocalResolveDir);\n  const ts = (0, configuration_1.loadCompiler)(compiler);\n  // Experimental REPL await is not compatible targets lower than ES2018\n  const targetSupportsTla = config.options.target >= ts.ScriptTarget.ES2018;\n  if (options.experimentalReplAwait === true && !targetSupportsTla) {\n    throw new Error('Experimental REPL await is not compatible with targets lower than ES2018');\n  }\n  // Top-level await was added in TS 3.8\n  const tsVersionSupportsTla = (0, util_1.versionGteLt)(ts.version, '3.8.0');\n  if (options.experimentalReplAwait === true && !tsVersionSupportsTla) {\n    throw new Error('Experimental REPL await is not compatible with TypeScript versions older than 3.8');\n  }\n  const shouldReplAwait = options.experimentalReplAwait !== false && tsVersionSupportsTla && targetSupportsTla;\n  // swc implies two other options\n  // typeCheck option was implemented specifically to allow overriding tsconfig transpileOnly from the command-line\n  // So we should allow using typeCheck to override swc\n  if (options.swc && !options.typeCheck) {\n    if (options.transpileOnly === false) {\n      throw new Error(\"Cannot enable 'swc' option with 'transpileOnly: false'.  'swc' implies 'transpileOnly'.\");\n    }\n    if (options.transpiler) {\n      throw new Error(\"Cannot specify both 'swc' and 'transpiler' options.  'swc' uses the built-in swc transpiler.\");\n    }\n  }\n  const readFile = options.readFile || ts.sys.readFile;\n  const fileExists = options.fileExists || ts.sys.fileExists;\n  // typeCheck can override transpileOnly, useful for CLI flag to override config file\n  const transpileOnly = (options.transpileOnly === true || options.swc === true) && options.typeCheck !== true;\n  let transpiler = undefined;\n  let transpilerBasePath = undefined;\n  if (options.transpiler) {\n    transpiler = options.transpiler;\n    transpilerBasePath = optionBasePaths.transpiler;\n  } else if (options.swc) {\n    transpiler = require.resolve('./transpilers/swc.js');\n    transpilerBasePath = optionBasePaths.swc;\n  }\n  const transformers = options.transformers || undefined;\n  const diagnosticFilters = [{\n    appliesToAllFiles: true,\n    filenamesAbsolute: [],\n    diagnosticsIgnored: [6059, 18002, 18003, ...(options.experimentalTsImportSpecifiers ? [2691 // \"An import path cannot end with a '.ts' extension. Consider importing '<specifier without ext>' instead.\"\n    ] : []), ...(options.ignoreDiagnostics || [])].map(Number)\n  }];\n  const configDiagnosticList = filterDiagnostics(config.errors, diagnosticFilters);\n  const outputCache = new Map();\n  const configFileDirname = configFilePath ? (0, path_1.dirname)(configFilePath) : null;\n  const scopeDir = (_c = (_b = (_a = options.scopeDir) !== null && _a !== void 0 ? _a : config.options.rootDir) !== null && _b !== void 0 ? _b : configFileDirname) !== null && _c !== void 0 ? _c : cwd;\n  const ignoreBaseDir = configFileDirname !== null && configFileDirname !== void 0 ? configFileDirname : cwd;\n  const isScoped = options.scope ? fileName => (0, path_1.relative)(scopeDir, fileName).charAt(0) !== '.' : () => true;\n  const shouldIgnore = createIgnore(ignoreBaseDir, options.skipIgnore ? [] : (options.ignore || ['(?:^|/)node_modules/']).map(str => new RegExp(str)));\n  const diagnosticHost = {\n    getNewLine: () => ts.sys.newLine,\n    getCurrentDirectory: () => cwd,\n    // TODO switch to getCanonicalFileName we already create later in scope\n    getCanonicalFileName: ts.sys.useCaseSensitiveFileNames ? x => x : x => x.toLowerCase()\n  };\n  if (options.transpileOnly && typeof transformers === 'function') {\n    throw new TypeError('Transformers function is unavailable in \"--transpile-only\"');\n  }\n  let createTranspiler = initializeTranspilerFactory();\n  function initializeTranspilerFactory() {\n    var _a;\n    if (transpiler) {\n      if (!transpileOnly) throw new Error('Custom transpiler can only be used when transpileOnly is enabled.');\n      const transpilerName = typeof transpiler === 'string' ? transpiler : transpiler[0];\n      const transpilerOptions = typeof transpiler === 'string' ? {} : (_a = transpiler[1]) !== null && _a !== void 0 ? _a : {};\n      const transpilerConfigLocalResolveHelper = transpilerBasePath ? (0, util_1.createProjectLocalResolveHelper)(transpilerBasePath) : projectLocalResolveHelper;\n      const transpilerPath = transpilerConfigLocalResolveHelper(transpilerName, true);\n      const transpilerFactory = require(transpilerPath).create;\n      return createTranspiler;\n      function createTranspiler(compilerOptions, nodeModuleEmitKind) {\n        return transpilerFactory === null || transpilerFactory === void 0 ? void 0 : transpilerFactory({\n          service: {\n            options,\n            config: {\n              ...config,\n              options: compilerOptions\n            },\n            projectLocalResolveHelper\n          },\n          transpilerConfigLocalResolveHelper,\n          nodeModuleEmitKind,\n          ...transpilerOptions\n        });\n      }\n    }\n  }\n  /**\n   * True if require() hooks should interop with experimental ESM loader.\n   * Enabled explicitly via a flag since it is a breaking change.\n   */\n  let experimentalEsmLoader = false;\n  function enableExperimentalEsmLoaderInterop() {\n    experimentalEsmLoader = true;\n  }\n  // Install source map support and read from memory cache.\n  installSourceMapSupport();\n  function installSourceMapSupport() {\n    const sourceMapSupport = require('@cspotcode/source-map-support');\n    sourceMapSupport.install({\n      environment: 'node',\n      retrieveFile(pathOrUrl) {\n        var _a;\n        let path = pathOrUrl;\n        // If it's a file URL, convert to local path\n        // Note: fileURLToPath does not exist on early node v10\n        // I could not find a way to handle non-URLs except to swallow an error\n        if (experimentalEsmLoader && path.startsWith('file://')) {\n          try {\n            path = (0, url_1.fileURLToPath)(path);\n          } catch (e) {\n            /* swallow error */\n          }\n        }\n        path = (0, util_1.normalizeSlashes)(path);\n        return ((_a = outputCache.get(path)) === null || _a === void 0 ? void 0 : _a.content) || '';\n      },\n      redirectConflictingLibrary: true,\n      onConflictingLibraryRedirect(request, parent, isMain, options, redirectedRequest) {\n        (0, exports.debug)(`Redirected an attempt to require source-map-support to instead receive @cspotcode/source-map-support.  \"${parent.filename}\" attempted to require or resolve \"${request}\" and was redirected to \"${redirectedRequest}\".`);\n      }\n    });\n  }\n  const shouldHavePrettyErrors = options.pretty === undefined ? process.stdout.isTTY : options.pretty;\n  const formatDiagnostics = shouldHavePrettyErrors ? ts.formatDiagnosticsWithColorAndContext || ts.formatDiagnostics : ts.formatDiagnostics;\n  function createTSError(diagnostics) {\n    const diagnosticText = formatDiagnostics(diagnostics, diagnosticHost);\n    const diagnosticCodes = diagnostics.map(x => x.code);\n    return new TSError(diagnosticText, diagnosticCodes, diagnostics);\n  }\n  function reportTSError(configDiagnosticList) {\n    const error = createTSError(configDiagnosticList);\n    if (options.logError) {\n      // Print error in red color and continue execution.\n      console.error('\\x1b[31m%s\\x1b[0m', error);\n    } else {\n      // Throw error and exit the script.\n      throw error;\n    }\n  }\n  // Render the configuration errors.\n  if (configDiagnosticList.length) reportTSError(configDiagnosticList);\n  const jsxEmitPreserve = config.options.jsx === ts.JsxEmit.Preserve;\n  /**\n   * Get the extension for a transpiled file.\n   * [MUST_UPDATE_FOR_NEW_FILE_EXTENSIONS]\n   */\n  function getEmitExtension(path) {\n    const lastDotIndex = path.lastIndexOf('.');\n    if (lastDotIndex >= 0) {\n      const ext = path.slice(lastDotIndex);\n      switch (ext) {\n        case '.js':\n        case '.ts':\n          return '.js';\n        case '.jsx':\n        case '.tsx':\n          return jsxEmitPreserve ? '.jsx' : '.js';\n        case '.mjs':\n        case '.mts':\n          return '.mjs';\n        case '.cjs':\n        case '.cts':\n          return '.cjs';\n      }\n    }\n    return '.js';\n  }\n  /**\n   * Get output from TS compiler w/typechecking.  `undefined` in `transpileOnly`\n   * mode.\n   */\n  let getOutput;\n  let getTypeInfo;\n  const getCanonicalFileName = ts.createGetCanonicalFileName(ts.sys.useCaseSensitiveFileNames);\n  const moduleTypeClassifier = (0, module_type_classifier_1.createModuleTypeClassifier)({\n    basePath: (_d = options.optionBasePaths) === null || _d === void 0 ? void 0 : _d.moduleTypes,\n    patterns: options.moduleTypes\n  });\n  const extensions = (0, file_extensions_1.getExtensions)(config, options, ts.version);\n  // Use full language services when the fast option is disabled.\n  if (!transpileOnly) {\n    const fileContents = new Map();\n    const rootFileNames = new Set(config.fileNames);\n    const cachedReadFile = (0, util_1.cachedLookup)(debugFn('readFile', readFile));\n    // Use language services by default\n    if (!options.compilerHost) {\n      let projectVersion = 1;\n      const fileVersions = new Map(Array.from(rootFileNames).map(fileName => [fileName, 0]));\n      const getCustomTransformers = () => {\n        if (typeof transformers === 'function') {\n          const program = service.getProgram();\n          return program ? transformers(program) : undefined;\n        }\n        return transformers;\n      };\n      // Create the compiler host for type checking.\n      const serviceHost = {\n        getProjectVersion: () => String(projectVersion),\n        getScriptFileNames: () => Array.from(rootFileNames),\n        getScriptVersion: fileName => {\n          const version = fileVersions.get(fileName);\n          return version ? version.toString() : '';\n        },\n        getScriptSnapshot(fileName) {\n          // TODO ordering of this with getScriptVersion?  Should they sync up?\n          let contents = fileContents.get(fileName);\n          // Read contents into TypeScript memory cache.\n          if (contents === undefined) {\n            contents = cachedReadFile(fileName);\n            if (contents === undefined) return;\n            fileVersions.set(fileName, 1);\n            fileContents.set(fileName, contents);\n            projectVersion++;\n          }\n          return ts.ScriptSnapshot.fromString(contents);\n        },\n        readFile: cachedReadFile,\n        readDirectory: ts.sys.readDirectory,\n        getDirectories: (0, util_1.cachedLookup)(debugFn('getDirectories', ts.sys.getDirectories)),\n        fileExists: (0, util_1.cachedLookup)(debugFn('fileExists', fileExists)),\n        directoryExists: (0, util_1.cachedLookup)(debugFn('directoryExists', ts.sys.directoryExists)),\n        realpath: ts.sys.realpath ? (0, util_1.cachedLookup)(debugFn('realpath', ts.sys.realpath)) : undefined,\n        getNewLine: () => ts.sys.newLine,\n        useCaseSensitiveFileNames: () => ts.sys.useCaseSensitiveFileNames,\n        getCurrentDirectory: () => cwd,\n        getCompilationSettings: () => config.options,\n        getDefaultLibFileName: () => ts.getDefaultLibFilePath(config.options),\n        getCustomTransformers: getCustomTransformers,\n        trace: options.tsTrace\n      };\n      const {\n        resolveModuleNames,\n        getResolvedModuleWithFailedLookupLocationsFromCache,\n        resolveTypeReferenceDirectives,\n        isFileKnownToBeInternal,\n        markBucketOfFilenameInternal\n      } = (0, resolver_functions_1.createResolverFunctions)({\n        host: serviceHost,\n        getCanonicalFileName,\n        ts,\n        cwd,\n        config,\n        projectLocalResolveHelper,\n        options,\n        extensions\n      });\n      serviceHost.resolveModuleNames = resolveModuleNames;\n      serviceHost.getResolvedModuleWithFailedLookupLocationsFromCache = getResolvedModuleWithFailedLookupLocationsFromCache;\n      serviceHost.resolveTypeReferenceDirectives = resolveTypeReferenceDirectives;\n      const registry = ts.createDocumentRegistry(ts.sys.useCaseSensitiveFileNames, cwd);\n      const service = ts.createLanguageService(serviceHost, registry);\n      const updateMemoryCache = (contents, fileName) => {\n        // Add to `rootFiles` as necessary, either to make TS include a file it has not seen,\n        // or to trigger a re-classification of files from external to internal.\n        if (!rootFileNames.has(fileName) && !isFileKnownToBeInternal(fileName)) {\n          markBucketOfFilenameInternal(fileName);\n          rootFileNames.add(fileName);\n          // Increment project version for every change to rootFileNames.\n          projectVersion++;\n        }\n        const previousVersion = fileVersions.get(fileName) || 0;\n        const previousContents = fileContents.get(fileName);\n        // Avoid incrementing cache when nothing has changed.\n        if (contents !== previousContents) {\n          fileVersions.set(fileName, previousVersion + 1);\n          fileContents.set(fileName, contents);\n          // Increment project version for every file change.\n          projectVersion++;\n        }\n      };\n      let previousProgram = undefined;\n      getOutput = (code, fileName) => {\n        updateMemoryCache(code, fileName);\n        const programBefore = service.getProgram();\n        if (programBefore !== previousProgram) {\n          (0, exports.debug)(`compiler rebuilt Program instance when getting output for ${fileName}`);\n        }\n        const output = service.getEmitOutput(fileName);\n        // Get the relevant diagnostics - this is 3x faster than `getPreEmitDiagnostics`.\n        const diagnostics = service.getSemanticDiagnostics(fileName).concat(service.getSyntacticDiagnostics(fileName));\n        const programAfter = service.getProgram();\n        (0, exports.debug)('invariant: Is service.getProject() identical before and after getting emit output and diagnostics? (should always be true) ', programBefore === programAfter);\n        previousProgram = programAfter;\n        const diagnosticList = filterDiagnostics(diagnostics, diagnosticFilters);\n        if (diagnosticList.length) reportTSError(diagnosticList);\n        if (output.emitSkipped) {\n          return [undefined, undefined, true];\n        }\n        // Throw an error when requiring `.d.ts` files.\n        if (output.outputFiles.length === 0) {\n          throw new TypeError(`Unable to require file: ${(0, path_1.relative)(cwd, fileName)}\\n` + 'This is usually the result of a faulty configuration or import. ' + 'Make sure there is a `.js`, `.json` or other executable extension with ' + 'loader attached before `ts-node` available.');\n        }\n        return [output.outputFiles[1].text, output.outputFiles[0].text, false];\n      };\n      getTypeInfo = (code, fileName, position) => {\n        const normalizedFileName = (0, util_1.normalizeSlashes)(fileName);\n        updateMemoryCache(code, normalizedFileName);\n        const info = service.getQuickInfoAtPosition(normalizedFileName, position);\n        const name = ts.displayPartsToString(info ? info.displayParts : []);\n        const comment = ts.displayPartsToString(info ? info.documentation : []);\n        return {\n          name,\n          comment\n        };\n      };\n    } else {\n      const sys = {\n        ...ts.sys,\n        ...diagnosticHost,\n        readFile: fileName => {\n          const cacheContents = fileContents.get(fileName);\n          if (cacheContents !== undefined) return cacheContents;\n          const contents = cachedReadFile(fileName);\n          if (contents) fileContents.set(fileName, contents);\n          return contents;\n        },\n        readDirectory: ts.sys.readDirectory,\n        getDirectories: (0, util_1.cachedLookup)(debugFn('getDirectories', ts.sys.getDirectories)),\n        fileExists: (0, util_1.cachedLookup)(debugFn('fileExists', fileExists)),\n        directoryExists: (0, util_1.cachedLookup)(debugFn('directoryExists', ts.sys.directoryExists)),\n        resolvePath: (0, util_1.cachedLookup)(debugFn('resolvePath', ts.sys.resolvePath)),\n        realpath: ts.sys.realpath ? (0, util_1.cachedLookup)(debugFn('realpath', ts.sys.realpath)) : undefined\n      };\n      const host = ts.createIncrementalCompilerHost ? ts.createIncrementalCompilerHost(config.options, sys) : {\n        ...sys,\n        getSourceFile: (fileName, languageVersion) => {\n          const contents = sys.readFile(fileName);\n          if (contents === undefined) return;\n          return ts.createSourceFile(fileName, contents, languageVersion);\n        },\n        getDefaultLibLocation: () => (0, util_1.normalizeSlashes)((0, path_1.dirname)(compiler)),\n        getDefaultLibFileName: () => (0, util_1.normalizeSlashes)((0, path_1.join)((0, path_1.dirname)(compiler), ts.getDefaultLibFileName(config.options))),\n        useCaseSensitiveFileNames: () => sys.useCaseSensitiveFileNames\n      };\n      host.trace = options.tsTrace;\n      const {\n        resolveModuleNames,\n        resolveTypeReferenceDirectives,\n        isFileKnownToBeInternal,\n        markBucketOfFilenameInternal\n      } = (0, resolver_functions_1.createResolverFunctions)({\n        host,\n        cwd,\n        config,\n        ts,\n        getCanonicalFileName,\n        projectLocalResolveHelper,\n        options,\n        extensions\n      });\n      host.resolveModuleNames = resolveModuleNames;\n      host.resolveTypeReferenceDirectives = resolveTypeReferenceDirectives;\n      // Fallback for older TypeScript releases without incremental API.\n      let builderProgram = ts.createIncrementalProgram ? ts.createIncrementalProgram({\n        rootNames: Array.from(rootFileNames),\n        options: config.options,\n        host,\n        configFileParsingDiagnostics: config.errors,\n        projectReferences: config.projectReferences\n      }) : ts.createEmitAndSemanticDiagnosticsBuilderProgram(Array.from(rootFileNames), config.options, host, undefined, config.errors, config.projectReferences);\n      // Read and cache custom transformers.\n      const customTransformers = typeof transformers === 'function' ? transformers(builderProgram.getProgram()) : transformers;\n      // Set the file contents into cache manually.\n      const updateMemoryCache = (contents, fileName) => {\n        const previousContents = fileContents.get(fileName);\n        const contentsChanged = previousContents !== contents;\n        if (contentsChanged) {\n          fileContents.set(fileName, contents);\n        }\n        // Add to `rootFiles` when discovered by compiler for the first time.\n        let addedToRootFileNames = false;\n        if (!rootFileNames.has(fileName) && !isFileKnownToBeInternal(fileName)) {\n          markBucketOfFilenameInternal(fileName);\n          rootFileNames.add(fileName);\n          addedToRootFileNames = true;\n        }\n        // Update program when file changes.\n        if (addedToRootFileNames || contentsChanged) {\n          builderProgram = ts.createEmitAndSemanticDiagnosticsBuilderProgram(Array.from(rootFileNames), config.options, host, builderProgram, config.errors, config.projectReferences);\n        }\n      };\n      getOutput = (code, fileName) => {\n        let outText = '';\n        let outMap = '';\n        updateMemoryCache(code, fileName);\n        const sourceFile = builderProgram.getSourceFile(fileName);\n        if (!sourceFile) throw new TypeError(`Unable to read file: ${fileName}`);\n        const program = builderProgram.getProgram();\n        const diagnostics = ts.getPreEmitDiagnostics(program, sourceFile);\n        const diagnosticList = filterDiagnostics(diagnostics, diagnosticFilters);\n        if (diagnosticList.length) reportTSError(diagnosticList);\n        const result = builderProgram.emit(sourceFile, (path, file, writeByteOrderMark) => {\n          if (path.endsWith('.map')) {\n            outMap = file;\n          } else {\n            outText = file;\n          }\n          if (options.emit) sys.writeFile(path, file, writeByteOrderMark);\n        }, undefined, undefined, customTransformers);\n        if (result.emitSkipped) {\n          return [undefined, undefined, true];\n        }\n        // Throw an error when requiring files that cannot be compiled.\n        if (outText === '') {\n          if (program.isSourceFileFromExternalLibrary(sourceFile)) {\n            throw new TypeError(`Unable to compile file from external library: ${(0, path_1.relative)(cwd, fileName)}`);\n          }\n          throw new TypeError(`Unable to require file: ${(0, path_1.relative)(cwd, fileName)}\\n` + 'This is usually the result of a faulty configuration or import. ' + 'Make sure there is a `.js`, `.json` or other executable extension with ' + 'loader attached before `ts-node` available.');\n        }\n        return [outText, outMap, false];\n      };\n      getTypeInfo = (code, fileName, position) => {\n        const normalizedFileName = (0, util_1.normalizeSlashes)(fileName);\n        updateMemoryCache(code, normalizedFileName);\n        const sourceFile = builderProgram.getSourceFile(normalizedFileName);\n        if (!sourceFile) throw new TypeError(`Unable to read file: ${fileName}`);\n        const node = getTokenAtPosition(ts, sourceFile, position);\n        const checker = builderProgram.getProgram().getTypeChecker();\n        const symbol = checker.getSymbolAtLocation(node);\n        if (!symbol) return {\n          name: '',\n          comment: ''\n        };\n        const type = checker.getTypeOfSymbolAtLocation(symbol, node);\n        const signatures = [...type.getConstructSignatures(), ...type.getCallSignatures()];\n        return {\n          name: signatures.length ? signatures.map(x => checker.signatureToString(x)).join('\\n') : checker.typeToString(type),\n          comment: ts.displayPartsToString(symbol ? symbol.getDocumentationComment(checker) : [])\n        };\n      };\n      // Write `.tsbuildinfo` when `--build` is enabled.\n      if (options.emit && config.options.incremental) {\n        process.on('exit', () => {\n          // Emits `.tsbuildinfo` to filesystem.\n          builderProgram.getProgram().emitBuildInfo();\n        });\n      }\n    }\n  } else {\n    getTypeInfo = () => {\n      throw new TypeError('Type information is unavailable in \"--transpile-only\"');\n    };\n  }\n  function createTranspileOnlyGetOutputFunction(overrideModuleType, nodeModuleEmitKind) {\n    const compilerOptions = {\n      ...config.options\n    };\n    if (overrideModuleType !== undefined) compilerOptions.module = overrideModuleType;\n    let customTranspiler = createTranspiler === null || createTranspiler === void 0 ? void 0 : createTranspiler(compilerOptions, nodeModuleEmitKind);\n    let tsTranspileModule = (0, util_1.versionGteLt)(ts.version, '4.7.0') ? (0, ts_transpile_module_1.createTsTranspileModule)(ts, {\n      compilerOptions,\n      reportDiagnostics: true,\n      transformers: transformers\n    }) : undefined;\n    return (code, fileName) => {\n      let result;\n      if (customTranspiler) {\n        result = customTranspiler.transpile(code, {\n          fileName\n        });\n      } else if (tsTranspileModule) {\n        result = tsTranspileModule(code, {\n          fileName\n        }, nodeModuleEmitKind === 'nodeesm' ? 'module' : 'commonjs');\n      } else {\n        result = ts.transpileModule(code, {\n          fileName,\n          compilerOptions,\n          reportDiagnostics: true,\n          transformers: transformers\n        });\n      }\n      const diagnosticList = filterDiagnostics(result.diagnostics || [], diagnosticFilters);\n      if (diagnosticList.length) reportTSError(diagnosticList);\n      return [result.outputText, result.sourceMapText, false];\n    };\n  }\n  // When true, these mean that a `moduleType` override will cause a different emit\n  // than the TypeScript compiler, so we *must* overwrite the emit.\n  const shouldOverwriteEmitWhenForcingCommonJS = config.options.module !== ts.ModuleKind.CommonJS;\n  // [MUST_UPDATE_FOR_NEW_MODULEKIND]\n  const shouldOverwriteEmitWhenForcingEsm = !(config.options.module === ts.ModuleKind.ES2015 || ts.ModuleKind.ES2020 && config.options.module === ts.ModuleKind.ES2020 || ts.ModuleKind.ES2022 && config.options.module === ts.ModuleKind.ES2022 || config.options.module === ts.ModuleKind.ESNext);\n  /**\n   * node16 or nodenext\n   * [MUST_UPDATE_FOR_NEW_MODULEKIND]\n   */\n  const isNodeModuleType = ts.ModuleKind.Node16 && config.options.module === ts.ModuleKind.Node16 || ts.ModuleKind.NodeNext && config.options.module === ts.ModuleKind.NodeNext;\n  const getOutputForceCommonJS = createTranspileOnlyGetOutputFunction(ts.ModuleKind.CommonJS);\n  const getOutputForceNodeCommonJS = createTranspileOnlyGetOutputFunction(ts.ModuleKind.NodeNext, 'nodecjs');\n  const getOutputForceNodeESM = createTranspileOnlyGetOutputFunction(ts.ModuleKind.NodeNext, 'nodeesm');\n  // [MUST_UPDATE_FOR_NEW_MODULEKIND]\n  const getOutputForceESM = createTranspileOnlyGetOutputFunction(ts.ModuleKind.ES2022 || ts.ModuleKind.ES2020 || ts.ModuleKind.ES2015);\n  const getOutputTranspileOnly = createTranspileOnlyGetOutputFunction();\n  // Create a simple TypeScript compiler proxy.\n  function compile(code, fileName, lineOffset = 0) {\n    const normalizedFileName = (0, util_1.normalizeSlashes)(fileName);\n    const classification = moduleTypeClassifier.classifyModuleByModuleTypeOverrides(normalizedFileName);\n    let value = '';\n    let sourceMap = '';\n    let emitSkipped = true;\n    if (getOutput) {\n      // Must always call normal getOutput to throw typechecking errors\n      [value, sourceMap, emitSkipped] = getOutput(code, normalizedFileName);\n    }\n    // If module classification contradicts the above, call the relevant transpiler\n    if (classification.moduleType === 'cjs' && (shouldOverwriteEmitWhenForcingCommonJS || emitSkipped)) {\n      [value, sourceMap] = getOutputForceCommonJS(code, normalizedFileName);\n    } else if (classification.moduleType === 'esm' && (shouldOverwriteEmitWhenForcingEsm || emitSkipped)) {\n      [value, sourceMap] = getOutputForceESM(code, normalizedFileName);\n    } else if (emitSkipped) {\n      // Happens when ts compiler skips emit or in transpileOnly mode\n      const classification = (0, node_module_type_classifier_1.classifyModule)(fileName, isNodeModuleType);\n      [value, sourceMap] = classification === 'nodecjs' ? getOutputForceNodeCommonJS(code, normalizedFileName) : classification === 'nodeesm' ? getOutputForceNodeESM(code, normalizedFileName) : classification === 'cjs' ? getOutputForceCommonJS(code, normalizedFileName) : classification === 'esm' ? getOutputForceESM(code, normalizedFileName) : getOutputTranspileOnly(code, normalizedFileName);\n    }\n    const output = updateOutput(value, normalizedFileName, sourceMap, getEmitExtension);\n    outputCache.set(normalizedFileName, {\n      content: output\n    });\n    return output;\n  }\n  let active = true;\n  const enabled = enabled => enabled === undefined ? active : active = !!enabled;\n  const ignored = fileName => {\n    if (!active) return true;\n    const ext = (0, path_1.extname)(fileName);\n    if (extensions.compiled.includes(ext)) {\n      return !isScoped(fileName) || shouldIgnore(fileName);\n    }\n    return true;\n  };\n  function addDiagnosticFilter(filter) {\n    diagnosticFilters.push({\n      ...filter,\n      filenamesAbsolute: filter.filenamesAbsolute.map(f => (0, util_1.normalizeSlashes)(f))\n    });\n  }\n  const getNodeEsmResolver = (0, util_1.once)(() => require('../dist-raw/node-internal-modules-esm-resolve').createResolve({\n    extensions,\n    preferTsExts: options.preferTsExts,\n    tsNodeExperimentalSpecifierResolution: options.experimentalSpecifierResolution\n  }));\n  const getNodeEsmGetFormat = (0, util_1.once)(() => require('../dist-raw/node-internal-modules-esm-get_format').createGetFormat(options.experimentalSpecifierResolution, getNodeEsmResolver()));\n  const getNodeCjsLoader = (0, util_1.once)(() => require('../dist-raw/node-internal-modules-cjs-loader').createCjsLoader({\n    extensions,\n    preferTsExts: options.preferTsExts,\n    nodeEsmResolver: getNodeEsmResolver()\n  }));\n  return {\n    [TS_NODE_SERVICE_BRAND]: true,\n    ts,\n    compilerPath: compiler,\n    config,\n    compile,\n    getTypeInfo,\n    ignored,\n    enabled,\n    options,\n    configFilePath,\n    moduleTypeClassifier,\n    shouldReplAwait,\n    addDiagnosticFilter,\n    installSourceMapSupport,\n    enableExperimentalEsmLoaderInterop,\n    transpileOnly,\n    projectLocalResolveHelper,\n    getNodeEsmResolver,\n    getNodeEsmGetFormat,\n    getNodeCjsLoader,\n    extensions\n  };\n}\nexports.createFromPreloadedConfig = createFromPreloadedConfig;\n/**\n * Check if the filename should be ignored.\n */\nfunction createIgnore(ignoreBaseDir, ignore) {\n  return fileName => {\n    const relname = (0, path_1.relative)(ignoreBaseDir, fileName);\n    const path = (0, util_1.normalizeSlashes)(relname);\n    return ignore.some(x => x.test(path));\n  };\n}\n/**\n * Register the extensions to support when importing files.\n */\nfunction registerExtensions(preferTsExts, extensions, service, originalJsHandler) {\n  const exts = new Set(extensions);\n  // Can't add these extensions cuz would allow omitting file extension; node requires ext for .cjs and .mjs\n  // Unless they're already registered by something else (nyc does this):\n  // then we *must* hook them or else our transformer will not be called.\n  for (const cannotAdd of ['.mts', '.cts', '.mjs', '.cjs']) {\n    if (exts.has(cannotAdd) && !(0, util_1.hasOwnProperty)(require.extensions, cannotAdd)) {\n      // Unrecognized file exts can be transformed via the `.js` handler.\n      exts.add('.js');\n      exts.delete(cannotAdd);\n    }\n  }\n  // Register new extensions.\n  for (const ext of exts) {\n    registerExtension(ext, service, originalJsHandler);\n  }\n  if (preferTsExts) {\n    const preferredExtensions = new Set([...exts, ...Object.keys(require.extensions)]);\n    // Re-sort iteration order of Object.keys()\n    for (const ext of preferredExtensions) {\n      const old = Object.getOwnPropertyDescriptor(require.extensions, ext);\n      delete require.extensions[ext];\n      Object.defineProperty(require.extensions, ext, old);\n    }\n  }\n}\n/**\n * Register the extension for node.\n */\nfunction registerExtension(ext, service, originalHandler) {\n  const old = require.extensions[ext] || originalHandler;\n  require.extensions[ext] = function (m, filename) {\n    if (service.ignored(filename)) return old(m, filename);\n    assertScriptCanLoadAsCJS(service, m, filename);\n    const _compile = m._compile;\n    m._compile = function (code, fileName) {\n      (0, exports.debug)('module._compile', fileName);\n      const result = service.compile(code, fileName);\n      return _compile.call(this, result, fileName);\n    };\n    return old(m, filename);\n  };\n}\n/**\n * Update the output remapping the source map.\n */\nfunction updateOutput(outputText, fileName, sourceMap, getEmitExtension) {\n  const base64Map = Buffer.from(updateSourceMap(sourceMap, fileName), 'utf8').toString('base64');\n  const sourceMapContent = `//# sourceMappingURL=data:application/json;charset=utf-8;base64,${base64Map}`;\n  // Expected form: `//# sourceMappingURL=foo bar.js.map` or `//# sourceMappingURL=foo%20bar.js.map` for input file \"foo bar.tsx\"\n  // Percent-encoding behavior added in TS 4.1.1: https://github.com/microsoft/TypeScript/issues/40951\n  const prefix = '//# sourceMappingURL=';\n  const prefixLength = prefix.length;\n  const baseName = /*foo.tsx*/(0, path_1.basename)(fileName);\n  const extName = /*.tsx*/(0, path_1.extname)(fileName);\n  const extension = /*.js*/getEmitExtension(fileName);\n  const sourcemapFilename = baseName.slice(0, -extName.length) + extension + '.map';\n  const sourceMapLengthWithoutPercentEncoding = prefixLength + sourcemapFilename.length;\n  /*\n   * Only rewrite if existing directive exists at the location we expect, to support:\n   *   a) compilers that do not append a sourcemap directive\n   *   b) situations where we did the math wrong\n   *     Not ideal, but appending our sourcemap *after* a pre-existing sourcemap still overrides, so the end-user is happy.\n   */\n  if (outputText.substr(-sourceMapLengthWithoutPercentEncoding, prefixLength) === prefix) {\n    return outputText.slice(0, -sourceMapLengthWithoutPercentEncoding) + sourceMapContent;\n  }\n  // If anyone asks why we're not using URL, the URL equivalent is: `u = new URL('http://d'); u.pathname = \"/\" + sourcemapFilename; return u.pathname.slice(1);\n  const sourceMapLengthWithPercentEncoding = prefixLength + encodeURI(sourcemapFilename).length;\n  if (outputText.substr(-sourceMapLengthWithPercentEncoding, prefixLength) === prefix) {\n    return outputText.slice(0, -sourceMapLengthWithPercentEncoding) + sourceMapContent;\n  }\n  return `${outputText}\\n${sourceMapContent}`;\n}\n/**\n * Update the source map contents for improved output.\n */\nfunction updateSourceMap(sourceMapText, fileName) {\n  const sourceMap = JSON.parse(sourceMapText);\n  sourceMap.file = fileName;\n  sourceMap.sources = [fileName];\n  delete sourceMap.sourceRoot;\n  return JSON.stringify(sourceMap);\n}\n/**\n * Filter diagnostics.\n */\nfunction filterDiagnostics(diagnostics, filters) {\n  return diagnostics.filter(d => filters.every(f => {\n    var _a;\n    return !f.appliesToAllFiles && f.filenamesAbsolute.indexOf((_a = d.file) === null || _a === void 0 ? void 0 : _a.fileName) === -1 || f.diagnosticsIgnored.indexOf(d.code) === -1;\n  }));\n}\n/**\n * Get token at file position.\n *\n * Reference: https://github.com/microsoft/TypeScript/blob/fcd9334f57d85b73dd66ad2d21c02e84822f4841/src/services/utilities.ts#L705-L731\n */\nfunction getTokenAtPosition(ts, sourceFile, position) {\n  let current = sourceFile;\n  outer: while (true) {\n    for (const child of current.getChildren(sourceFile)) {\n      const start = child.getFullStart();\n      if (start > position) break;\n      const end = child.getEnd();\n      if (position <= end) {\n        current = child;\n        continue outer;\n      }\n    }\n    return current;\n  }\n}\n/**\n * Create an implementation of node's ESM loader hooks.\n *\n * This may be useful if you\n * want to wrap or compose the loader hooks to add additional functionality or\n * combine with another loader.\n *\n * Node changed the hooks API, so there are two possible APIs.  This function\n * detects your node version and returns the appropriate API.\n *\n * @category ESM Loader\n */\nconst createEsmHooks = tsNodeService => require('./esm').createEsmHooks(tsNodeService);\nexports.createEsmHooks = createEsmHooks;","map":{"version":3,"names":["path_1","require","module_1","util","url_1","make_error_1","util_1","configuration_1","module_type_classifier_1","resolver_functions_1","cjs_resolve_hooks_1","node_module_type_classifier_1","file_extensions_1","ts_transpile_module_1","repl_1","Object","defineProperty","exports","enumerable","get","createRepl","engineSupportsPackageTypeField","parseInt","process","versions","node","split","assertScriptCanLoadAsCJS","assertScriptCanLoadAsCJSImpl","REGISTER_INSTANCE","Symbol","for","env","INSPECT_CUSTOM","inspect","custom","shouldDebug","yn","TS_NODE_DEBUG","debug","args","console","log","Date","toISOString","undefined","debugFn","key","fn","i","x","_","VERSION","version","DEFAULTS","cwd","_a","TS_NODE_CWD","TS_NODE_DIR","emit","TS_NODE_EMIT","scope","TS_NODE_SCOPE","scopeDir","TS_NODE_SCOPE_DIR","files","TS_NODE_FILES","pretty","TS_NODE_PRETTY","compiler","TS_NODE_COMPILER","compilerOptions","parse","TS_NODE_COMPILER_OPTIONS","ignore","TS_NODE_IGNORE","project","TS_NODE_PROJECT","skipProject","TS_NODE_SKIP_PROJECT","skipIgnore","TS_NODE_SKIP_IGNORE","preferTsExts","TS_NODE_PREFER_TS_EXTS","ignoreDiagnostics","TS_NODE_IGNORE_DIAGNOSTICS","transpileOnly","TS_NODE_TRANSPILE_ONLY","typeCheck","TS_NODE_TYPE_CHECK","compilerHost","TS_NODE_COMPILER_HOST","logError","TS_NODE_LOG_ERROR","experimentalReplAwait","_b","TS_NODE_EXPERIMENTAL_REPL_AWAIT","tsTrace","bind","TSError","BaseError","constructor","diagnosticText","diagnosticCodes","diagnostics","name","configurable","writable","value","TS_NODE_SERVICE_BRAND","register","serviceOrOpts","service","create","originalJsHandler","extensions","registerExtensions","options","compiled","installCommonjsResolveHooksIfNecessary","Module","_preloadModules","rawOptions","foundConfigResult","findAndReadConfig","createFromPreloadedConfig","configFilePath","config","projectLocalResolveDir","optionBasePaths","projectLocalResolveHelper","createProjectLocalResolveHelper","ts","loadCompiler","targetSupportsTla","target","ScriptTarget","ES2018","Error","tsVersionSupportsTla","versionGteLt","shouldReplAwait","swc","transpiler","readFile","sys","fileExists","transpilerBasePath","resolve","transformers","diagnosticFilters","appliesToAllFiles","filenamesAbsolute","diagnosticsIgnored","experimentalTsImportSpecifiers","map","Number","configDiagnosticList","filterDiagnostics","errors","outputCache","Map","configFileDirname","dirname","_c","rootDir","ignoreBaseDir","isScoped","fileName","relative","charAt","shouldIgnore","createIgnore","str","RegExp","diagnosticHost","getNewLine","newLine","getCurrentDirectory","getCanonicalFileName","useCaseSensitiveFileNames","toLowerCase","TypeError","createTranspiler","initializeTranspilerFactory","transpilerName","transpilerOptions","transpilerConfigLocalResolveHelper","transpilerPath","transpilerFactory","nodeModuleEmitKind","experimentalEsmLoader","enableExperimentalEsmLoaderInterop","installSourceMapSupport","sourceMapSupport","install","environment","retrieveFile","pathOrUrl","path","startsWith","fileURLToPath","e","normalizeSlashes","content","redirectConflictingLibrary","onConflictingLibraryRedirect","request","parent","isMain","redirectedRequest","filename","shouldHavePrettyErrors","stdout","isTTY","formatDiagnostics","formatDiagnosticsWithColorAndContext","createTSError","code","reportTSError","error","length","jsxEmitPreserve","jsx","JsxEmit","Preserve","getEmitExtension","lastDotIndex","lastIndexOf","ext","slice","getOutput","getTypeInfo","createGetCanonicalFileName","moduleTypeClassifier","createModuleTypeClassifier","basePath","_d","moduleTypes","patterns","getExtensions","fileContents","rootFileNames","Set","fileNames","cachedReadFile","cachedLookup","projectVersion","fileVersions","Array","from","getCustomTransformers","program","getProgram","serviceHost","getProjectVersion","String","getScriptFileNames","getScriptVersion","toString","getScriptSnapshot","contents","set","ScriptSnapshot","fromString","readDirectory","getDirectories","directoryExists","realpath","getCompilationSettings","getDefaultLibFileName","getDefaultLibFilePath","trace","resolveModuleNames","getResolvedModuleWithFailedLookupLocationsFromCache","resolveTypeReferenceDirectives","isFileKnownToBeInternal","markBucketOfFilenameInternal","createResolverFunctions","host","registry","createDocumentRegistry","createLanguageService","updateMemoryCache","has","add","previousVersion","previousContents","previousProgram","programBefore","output","getEmitOutput","getSemanticDiagnostics","concat","getSyntacticDiagnostics","programAfter","diagnosticList","emitSkipped","outputFiles","text","position","normalizedFileName","info","getQuickInfoAtPosition","displayPartsToString","displayParts","comment","documentation","cacheContents","resolvePath","createIncrementalCompilerHost","getSourceFile","languageVersion","createSourceFile","getDefaultLibLocation","join","builderProgram","createIncrementalProgram","rootNames","configFileParsingDiagnostics","projectReferences","createEmitAndSemanticDiagnosticsBuilderProgram","customTransformers","contentsChanged","addedToRootFileNames","outText","outMap","sourceFile","getPreEmitDiagnostics","result","file","writeByteOrderMark","endsWith","writeFile","isSourceFileFromExternalLibrary","getTokenAtPosition","checker","getTypeChecker","symbol","getSymbolAtLocation","type","getTypeOfSymbolAtLocation","signatures","getConstructSignatures","getCallSignatures","signatureToString","typeToString","getDocumentationComment","incremental","on","emitBuildInfo","createTranspileOnlyGetOutputFunction","overrideModuleType","module","customTranspiler","tsTranspileModule","createTsTranspileModule","reportDiagnostics","transpile","transpileModule","outputText","sourceMapText","shouldOverwriteEmitWhenForcingCommonJS","ModuleKind","CommonJS","shouldOverwriteEmitWhenForcingEsm","ES2015","ES2020","ES2022","ESNext","isNodeModuleType","Node16","NodeNext","getOutputForceCommonJS","getOutputForceNodeCommonJS","getOutputForceNodeESM","getOutputForceESM","getOutputTranspileOnly","compile","lineOffset","classification","classifyModuleByModuleTypeOverrides","sourceMap","moduleType","classifyModule","updateOutput","active","enabled","ignored","extname","includes","addDiagnosticFilter","filter","push","f","getNodeEsmResolver","once","createResolve","tsNodeExperimentalSpecifierResolution","experimentalSpecifierResolution","getNodeEsmGetFormat","createGetFormat","getNodeCjsLoader","createCjsLoader","nodeEsmResolver","compilerPath","relname","some","test","exts","cannotAdd","hasOwnProperty","delete","registerExtension","preferredExtensions","keys","old","getOwnPropertyDescriptor","originalHandler","m","_compile","call","base64Map","Buffer","updateSourceMap","sourceMapContent","prefix","prefixLength","baseName","basename","extName","extension","sourcemapFilename","sourceMapLengthWithoutPercentEncoding","substr","sourceMapLengthWithPercentEncoding","encodeURI","JSON","sources","sourceRoot","stringify","filters","d","every","indexOf","current","outer","child","getChildren","start","getFullStart","end","getEnd","createEsmHooks","tsNodeService"],"sources":["/Users/mukuljindal/Local/projects/voting/node_modules/ts-node/src/index.ts"],"sourcesContent":["import { relative, basename, extname, dirname, join } from 'path';\nimport { Module } from 'module';\nimport * as util from 'util';\nimport { fileURLToPath } from 'url';\n\nimport type * as _sourceMapSupport from '@cspotcode/source-map-support';\nimport { BaseError } from 'make-error';\nimport type * as _ts from 'typescript';\n\nimport type { Transpiler, TranspilerFactory } from './transpilers/types';\nimport {\n  cachedLookup,\n  createProjectLocalResolveHelper,\n  hasOwnProperty,\n  normalizeSlashes,\n  once,\n  parse,\n  ProjectLocalResolveHelper,\n  split,\n  versionGteLt,\n  yn,\n} from './util';\nimport { findAndReadConfig, loadCompiler } from './configuration';\nimport type { TSCommon, TSInternal } from './ts-compiler-types';\nimport {\n  createModuleTypeClassifier,\n  ModuleTypeClassifier,\n} from './module-type-classifier';\nimport { createResolverFunctions } from './resolver-functions';\nimport type { createEsmHooks as createEsmHooksFn } from './esm';\nimport {\n  installCommonjsResolveHooksIfNecessary,\n  ModuleConstructorWithInternals,\n} from './cjs-resolve-hooks';\nimport { classifyModule } from './node-module-type-classifier';\nimport type * as _nodeInternalModulesEsmResolve from '../dist-raw/node-internal-modules-esm-resolve';\nimport type * as _nodeInternalModulesEsmGetFormat from '../dist-raw/node-internal-modules-esm-get_format';\nimport type * as _nodeInternalModulesCjsLoader from '../dist-raw/node-internal-modules-cjs-loader';\nimport { Extensions, getExtensions } from './file-extensions';\nimport { createTsTranspileModule } from './ts-transpile-module';\n\nexport { TSCommon };\nexport {\n  createRepl,\n  CreateReplOptions,\n  ReplService,\n  EvalAwarePartialHost,\n} from './repl';\nexport type {\n  TranspilerModule,\n  TranspilerFactory,\n  CreateTranspilerOptions,\n  TranspileOutput,\n  TranspileOptions,\n  Transpiler,\n} from './transpilers/types';\nexport type {\n  NodeLoaderHooksAPI1,\n  NodeLoaderHooksAPI2,\n  NodeLoaderHooksFormat,\n} from './esm';\n\n/**\n * Does this version of node obey the package.json \"type\" field\n * and throw ERR_REQUIRE_ESM when attempting to require() an ESM modules.\n */\nconst engineSupportsPackageTypeField =\n  parseInt(process.versions.node.split('.')[0], 10) >= 12;\n\n/**\n * Assert that script can be loaded as CommonJS when we attempt to require it.\n * If it should be loaded as ESM, throw ERR_REQUIRE_ESM like node does.\n *\n * Loaded conditionally so we don't need to support older node versions\n */\nlet assertScriptCanLoadAsCJS: (\n  service: Service,\n  module: NodeJS.Module,\n  filename: string\n) => void = engineSupportsPackageTypeField\n  ? (\n      require('../dist-raw/node-internal-modules-cjs-loader') as typeof _nodeInternalModulesCjsLoader\n    ).assertScriptCanLoadAsCJSImpl\n  : () => {\n      /* noop */\n    };\n\n/**\n * Registered `ts-node` instance information.\n */\nexport const REGISTER_INSTANCE = Symbol.for('ts-node.register.instance');\n\n/**\n * Expose `REGISTER_INSTANCE` information on node.js `process`.\n */\ndeclare global {\n  namespace NodeJS {\n    interface Process {\n      [REGISTER_INSTANCE]?: Service;\n    }\n  }\n}\n\n/** @internal */\nexport const env = process.env as ProcessEnv;\n/**\n * Declare all env vars, to aid discoverability.\n * If an env var affects ts-node's behavior, it should not be buried somewhere in our codebase.\n * @internal\n */\nexport interface ProcessEnv {\n  TS_NODE_DEBUG?: string;\n  TS_NODE_CWD?: string;\n  /** @deprecated */\n  TS_NODE_DIR?: string;\n  TS_NODE_EMIT?: string;\n  TS_NODE_SCOPE?: string;\n  TS_NODE_SCOPE_DIR?: string;\n  TS_NODE_FILES?: string;\n  TS_NODE_PRETTY?: string;\n  TS_NODE_COMPILER?: string;\n  TS_NODE_COMPILER_OPTIONS?: string;\n  TS_NODE_IGNORE?: string;\n  TS_NODE_PROJECT?: string;\n  TS_NODE_SKIP_PROJECT?: string;\n  TS_NODE_SKIP_IGNORE?: string;\n  TS_NODE_PREFER_TS_EXTS?: string;\n  TS_NODE_IGNORE_DIAGNOSTICS?: string;\n  TS_NODE_TRANSPILE_ONLY?: string;\n  TS_NODE_TYPE_CHECK?: string;\n  TS_NODE_COMPILER_HOST?: string;\n  TS_NODE_LOG_ERROR?: string;\n  TS_NODE_HISTORY?: string;\n  TS_NODE_EXPERIMENTAL_REPL_AWAIT?: string;\n\n  NODE_NO_READLINE?: string;\n}\n\n/**\n * @internal\n */\nexport const INSPECT_CUSTOM = util.inspect.custom || 'inspect';\n\n/**\n * Debugging `ts-node`.\n */\nconst shouldDebug = yn(env.TS_NODE_DEBUG);\n/** @internal */\nexport const debug = shouldDebug\n  ? (...args: any) =>\n      console.log(`[ts-node ${new Date().toISOString()}]`, ...args)\n  : () => undefined;\nconst debugFn = shouldDebug\n  ? <T, U>(key: string, fn: (arg: T) => U) => {\n      let i = 0;\n      return (x: T) => {\n        debug(key, x, ++i);\n        return fn(x);\n      };\n    }\n  : <T, U>(_: string, fn: (arg: T) => U) => fn;\n\n/**\n * Export the current version.\n */\nexport const VERSION = require('../package.json').version;\n\n/**\n * Options for creating a new TypeScript compiler instance.\n\n * @category Basic\n */\nexport interface CreateOptions {\n  /**\n   * Behave as if invoked within this working directory.  Roughly equivalent to `cd $dir && ts-node ...`\n   *\n   * @default process.cwd()\n   */\n  cwd?: string;\n  /**\n   * Legacy alias for `cwd`\n   *\n   * @deprecated use `projectSearchDir` or `cwd`\n   */\n  dir?: string;\n  /**\n   * Emit output files into `.ts-node` directory.\n   *\n   * @default false\n   */\n  emit?: boolean;\n  /**\n   * Scope compiler to files within `scopeDir`.\n   *\n   * @default false\n   */\n  scope?: boolean;\n  /**\n   * @default First of: `tsconfig.json` \"rootDir\" if specified, directory containing `tsconfig.json`, or cwd if no `tsconfig.json` is loaded.\n   */\n  scopeDir?: string;\n  /**\n   * Use pretty diagnostic formatter.\n   *\n   * @default false\n   */\n  pretty?: boolean;\n  /**\n   * Use TypeScript's faster `transpileModule`.\n   *\n   * @default false\n   */\n  transpileOnly?: boolean;\n  /**\n   * **DEPRECATED** Specify type-check is enabled (e.g. `transpileOnly == false`).\n   *\n   * @default true\n   */\n  typeCheck?: boolean;\n  /**\n   * Use TypeScript's compiler host API instead of the language service API.\n   *\n   * @default false\n   */\n  compilerHost?: boolean;\n  /**\n   * Logs TypeScript errors to stderr instead of throwing exceptions.\n   *\n   * @default false\n   */\n  logError?: boolean;\n  /**\n   * Load \"files\" and \"include\" from `tsconfig.json` on startup.\n   *\n   * Default is to override `tsconfig.json` \"files\" and \"include\" to only include the entrypoint script.\n   *\n   * @default false\n   */\n  files?: boolean;\n  /**\n   * Specify a custom TypeScript compiler.\n   *\n   * @default \"typescript\"\n   */\n  compiler?: string;\n  /**\n   * Specify a custom transpiler for use with transpileOnly\n   */\n  transpiler?: string | [string, object];\n  /**\n   * Transpile with swc instead of the TypeScript compiler, and skip typechecking.\n   *\n   * Equivalent to setting both `transpileOnly: true` and `transpiler: 'ts-node/transpilers/swc'`\n   *\n   * For complete instructions: https://typestrong.org/ts-node/docs/transpilers\n   */\n  swc?: boolean;\n  /**\n   * Paths which should not be compiled.\n   *\n   * Each string in the array is converted to a regular expression via `new RegExp()` and tested against source paths prior to compilation.\n   *\n   * Source paths are normalized to posix-style separators, relative to the directory containing `tsconfig.json` or to cwd if no `tsconfig.json` is loaded.\n   *\n   * Default is to ignore all node_modules subdirectories.\n   *\n   * @default [\"(?:^|/)node_modules/\"]\n   */\n  ignore?: string[];\n  /**\n   * Path to TypeScript config file or directory containing a `tsconfig.json`.\n   * Similar to the `tsc --project` flag: https://www.typescriptlang.org/docs/handbook/compiler-options.html\n   */\n  project?: string;\n  /**\n   * Search for TypeScript config file (`tsconfig.json`) in this or parent directories.\n   */\n  projectSearchDir?: string;\n  /**\n   * Skip project config resolution and loading.\n   *\n   * @default false\n   */\n  skipProject?: boolean;\n  /**\n   * Skip ignore check, so that compilation will be attempted for all files with matching extensions.\n   *\n   * @default false\n   */\n  skipIgnore?: boolean;\n  /**\n   * JSON object to merge with TypeScript `compilerOptions`.\n   *\n   * @allOf [{\"$ref\": \"https://schemastore.azurewebsites.net/schemas/json/tsconfig.json#definitions/compilerOptionsDefinition/properties/compilerOptions\"}]\n   */\n  compilerOptions?: object;\n  /**\n   * Ignore TypeScript warnings by diagnostic code.\n   */\n  ignoreDiagnostics?: Array<number | string>;\n  /**\n   * Modules to require, like node's `--require` flag.\n   *\n   * If specified in `tsconfig.json`, the modules will be resolved relative to the `tsconfig.json` file.\n   *\n   * If specified programmatically, each input string should be pre-resolved to an absolute path for\n   * best results.\n   */\n  require?: Array<string>;\n  readFile?: (path: string) => string | undefined;\n  fileExists?: (path: string) => boolean;\n  transformers?:\n    | _ts.CustomTransformers\n    | ((p: _ts.Program) => _ts.CustomTransformers);\n  /**\n   * Allows the usage of top level await in REPL.\n   *\n   * Uses node's implementation which accomplishes this with an AST syntax transformation.\n   *\n   * Enabled by default when tsconfig target is es2018 or above. Set to false to disable.\n   *\n   * **Note**: setting to `true` when tsconfig target is too low will throw an Error.  Leave as `undefined`\n   * to get default, automatic behavior.\n   */\n  experimentalReplAwait?: boolean;\n  /**\n   * Override certain paths to be compiled and executed as CommonJS or ECMAScript modules.\n   * When overridden, the tsconfig \"module\" and package.json \"type\" fields are overridden, and\n   * the file extension is ignored.\n   * This is useful if you cannot use .mts, .cts, .mjs, or .cjs file extensions;\n   * it achieves the same effect.\n   *\n   * Each key is a glob pattern following the same rules as tsconfig's \"include\" array.\n   * When multiple patterns match the same file, the last pattern takes precedence.\n   *\n   * `cjs` overrides matches files to compile and execute as CommonJS.\n   * `esm` overrides matches files to compile and execute as native ECMAScript modules.\n   * `package` overrides either of the above to default behavior, which obeys package.json \"type\" and\n   * tsconfig.json \"module\" options.\n   */\n  moduleTypes?: ModuleTypes;\n  /**\n   * @internal\n   * Set by our configuration loader whenever a config file contains options that\n   * are relative to the config file they came from, *and* when other logic needs\n   * to know this.  Some options can be eagerly resolved to absolute paths by\n   * the configuration loader, so it is *not* necessary for their source to be set here.\n   */\n  optionBasePaths?: OptionBasePaths;\n  /**\n   * A function to collect trace messages from the TypeScript compiler, for example when `traceResolution` is enabled.\n   *\n   * @default console.log\n   */\n  tsTrace?: (str: string) => void;\n  /**\n   * Enable native ESM support.\n   *\n   * For details, see https://typestrong.org/ts-node/docs/imports#native-ecmascript-modules\n   */\n  esm?: boolean;\n  /**\n   * Re-order file extensions so that TypeScript imports are preferred.\n   *\n   * For example, when both `index.js` and `index.ts` exist, enabling this option causes `require('./index')` to resolve to `index.ts` instead of `index.js`\n   *\n   * @default false\n   */\n  preferTsExts?: boolean;\n  /**\n   * Like node's `--experimental-specifier-resolution`, , but can also be set in your `tsconfig.json` for convenience.\n   *\n   * For details, see https://nodejs.org/dist/latest-v18.x/docs/api/esm.html#customizing-esm-specifier-resolution-algorithm\n   */\n  experimentalSpecifierResolution?: 'node' | 'explicit';\n  /**\n   * Allow using voluntary `.ts` file extension in import specifiers.\n   *\n   * Typically, in ESM projects, import specifiers must have an emit extension, `.js`, `.cjs`, or `.mjs`,\n   * and we automatically map to the corresponding `.ts`, `.cts`, or `.mts` source file.  This is the\n   * recommended approach.\n   *\n   * However, if you really want to use `.ts` in import specifiers, and are aware that this may\n   * break tooling, you can enable this flag.\n   */\n  experimentalTsImportSpecifiers?: boolean;\n}\n\nexport type ModuleTypes = Record<string, ModuleTypeOverride>;\nexport type ModuleTypeOverride = 'cjs' | 'esm' | 'package';\n\n/** @internal */\nexport interface OptionBasePaths {\n  moduleTypes?: string;\n  transpiler?: string;\n  compiler?: string;\n  swc?: string;\n}\n\n/**\n * Options for registering a TypeScript compiler instance globally.\n\n * @category Basic\n */\nexport interface RegisterOptions extends CreateOptions {\n  /**\n   * Enable experimental features that re-map imports and require calls to support:\n   * `baseUrl`, `paths`, `rootDirs`, `.js` to `.ts` file extension mappings,\n   * `outDir` to `rootDir` mappings for composite projects and monorepos.\n   *\n   * For details, see https://github.com/TypeStrong/ts-node/issues/1514\n   */\n  experimentalResolver?: boolean;\n}\n\nexport type ExperimentalSpecifierResolution = 'node' | 'explicit';\n\n/**\n * Must be an interface to support `typescript-json-schema`.\n */\nexport interface TsConfigOptions\n  extends Omit<\n    RegisterOptions,\n    | 'transformers'\n    | 'readFile'\n    | 'fileExists'\n    | 'skipProject'\n    | 'project'\n    | 'dir'\n    | 'cwd'\n    | 'projectSearchDir'\n    | 'optionBasePaths'\n    | 'tsTrace'\n  > {}\n\n/**\n * Information retrieved from type info check.\n */\nexport interface TypeInfo {\n  name: string;\n  comment: string;\n}\n\n/**\n * Default register options, including values specified via environment\n * variables.\n * @internal\n */\nexport const DEFAULTS: RegisterOptions = {\n  cwd: env.TS_NODE_CWD ?? env.TS_NODE_DIR,\n  emit: yn(env.TS_NODE_EMIT),\n  scope: yn(env.TS_NODE_SCOPE),\n  scopeDir: env.TS_NODE_SCOPE_DIR,\n  files: yn(env.TS_NODE_FILES),\n  pretty: yn(env.TS_NODE_PRETTY),\n  compiler: env.TS_NODE_COMPILER,\n  compilerOptions: parse(env.TS_NODE_COMPILER_OPTIONS),\n  ignore: split(env.TS_NODE_IGNORE),\n  project: env.TS_NODE_PROJECT,\n  skipProject: yn(env.TS_NODE_SKIP_PROJECT),\n  skipIgnore: yn(env.TS_NODE_SKIP_IGNORE),\n  preferTsExts: yn(env.TS_NODE_PREFER_TS_EXTS),\n  ignoreDiagnostics: split(env.TS_NODE_IGNORE_DIAGNOSTICS),\n  transpileOnly: yn(env.TS_NODE_TRANSPILE_ONLY),\n  typeCheck: yn(env.TS_NODE_TYPE_CHECK),\n  compilerHost: yn(env.TS_NODE_COMPILER_HOST),\n  logError: yn(env.TS_NODE_LOG_ERROR),\n  experimentalReplAwait: yn(env.TS_NODE_EXPERIMENTAL_REPL_AWAIT) ?? undefined,\n  tsTrace: console.log.bind(console),\n};\n\n/**\n * TypeScript diagnostics error.\n */\nexport class TSError extends BaseError {\n  name = 'TSError';\n  diagnosticText!: string;\n  diagnostics!: ReadonlyArray<_ts.Diagnostic>;\n\n  constructor(\n    diagnosticText: string,\n    public diagnosticCodes: number[],\n    diagnostics: ReadonlyArray<_ts.Diagnostic> = []\n  ) {\n    super(`тип Unable to compile TypeScript:\\n${diagnosticText}`);\n    Object.defineProperty(this, 'diagnosticText', {\n      configurable: true,\n      writable: true,\n      value: diagnosticText,\n    });\n    Object.defineProperty(this, 'diagnostics', {\n      configurable: true,\n      writable: true,\n      value: diagnostics,\n    });\n  }\n\n  /**\n   * @internal\n   */\n  [INSPECT_CUSTOM]() {\n    return this.diagnosticText;\n  }\n}\n\nconst TS_NODE_SERVICE_BRAND = Symbol('TS_NODE_SERVICE_BRAND');\n\n/**\n * Primary ts-node service, which wraps the TypeScript API and can compile TypeScript to JavaScript\n */\nexport interface Service {\n  /** @internal */\n  [TS_NODE_SERVICE_BRAND]: true;\n  ts: TSCommon;\n  /** @internal */\n  compilerPath: string;\n  config: _ts.ParsedCommandLine;\n  options: RegisterOptions;\n  enabled(enabled?: boolean): boolean;\n  ignored(fileName: string): boolean;\n  compile(code: string, fileName: string, lineOffset?: number): string;\n  getTypeInfo(code: string, fileName: string, position: number): TypeInfo;\n  /** @internal */\n  configFilePath: string | undefined;\n  /** @internal */\n  moduleTypeClassifier: ModuleTypeClassifier;\n  /** @internal */\n  readonly shouldReplAwait: boolean;\n  /** @internal */\n  addDiagnosticFilter(filter: DiagnosticFilter): void;\n  /** @internal */\n  installSourceMapSupport(): void;\n  /** @internal */\n  enableExperimentalEsmLoaderInterop(): void;\n  /** @internal */\n  transpileOnly: boolean;\n  /** @internal */\n  projectLocalResolveHelper: ProjectLocalResolveHelper;\n  /** @internal */\n  getNodeEsmResolver: () => ReturnType<\n    typeof import('../dist-raw/node-internal-modules-esm-resolve').createResolve\n  >;\n  /** @internal */\n  getNodeEsmGetFormat: () => ReturnType<\n    typeof import('../dist-raw/node-internal-modules-esm-get_format').createGetFormat\n  >;\n  /** @internal */\n  getNodeCjsLoader: () => ReturnType<\n    typeof import('../dist-raw/node-internal-modules-cjs-loader').createCjsLoader\n  >;\n  /** @internal */\n  extensions: Extensions;\n}\n\n/**\n * Re-export of `Service` interface for backwards-compatibility\n * @deprecated use `Service` instead\n * @see {Service}\n */\nexport type Register = Service;\n\n/** @internal */\nexport interface DiagnosticFilter {\n  /** if true, filter applies to all files */\n  appliesToAllFiles: boolean;\n  /** Filter applies onto to these filenames.  Only used if appliesToAllFiles is false */\n  filenamesAbsolute: string[];\n  /** these diagnostic codes are ignored */\n  diagnosticsIgnored: number[];\n}\n\n/**\n * Create a new TypeScript compiler instance and register it onto node.js\n *\n * @category Basic\n */\nexport function register(opts?: RegisterOptions): Service;\n/**\n * Register TypeScript compiler instance onto node.js\n\n * @category Basic\n */\nexport function register(service: Service): Service;\nexport function register(\n  serviceOrOpts: Service | RegisterOptions | undefined\n): Service {\n  // Is this a Service or a RegisterOptions?\n  let service = serviceOrOpts as Service;\n  if (!(serviceOrOpts as Service)?.[TS_NODE_SERVICE_BRAND]) {\n    // Not a service; is options\n    service = create((serviceOrOpts ?? {}) as RegisterOptions);\n  }\n\n  const originalJsHandler = require.extensions['.js'];\n\n  // Expose registered instance globally.\n  process[REGISTER_INSTANCE] = service;\n\n  // Register the extensions.\n  registerExtensions(\n    service.options.preferTsExts,\n    service.extensions.compiled,\n    service,\n    originalJsHandler\n  );\n\n  installCommonjsResolveHooksIfNecessary(service);\n\n  // Require specified modules before start-up.\n  (Module as ModuleConstructorWithInternals)._preloadModules(\n    service.options.require\n  );\n\n  return service;\n}\n\n/**\n * Create TypeScript compiler instance.\n *\n * @category Basic\n */\nexport function create(rawOptions: CreateOptions = {}): Service {\n  const foundConfigResult = findAndReadConfig(rawOptions);\n  return createFromPreloadedConfig(foundConfigResult);\n}\n\n/** @internal */\nexport function createFromPreloadedConfig(\n  foundConfigResult: ReturnType<typeof findAndReadConfig>\n): Service {\n  const {\n    configFilePath,\n    cwd,\n    options,\n    config,\n    compiler,\n    projectLocalResolveDir,\n    optionBasePaths,\n  } = foundConfigResult;\n\n  const projectLocalResolveHelper = createProjectLocalResolveHelper(\n    projectLocalResolveDir\n  );\n\n  const ts = loadCompiler(compiler);\n\n  // Experimental REPL await is not compatible targets lower than ES2018\n  const targetSupportsTla = config.options.target! >= ts.ScriptTarget.ES2018;\n  if (options.experimentalReplAwait === true && !targetSupportsTla) {\n    throw new Error(\n      'Experimental REPL await is not compatible with targets lower than ES2018'\n    );\n  }\n  // Top-level await was added in TS 3.8\n  const tsVersionSupportsTla = versionGteLt(ts.version, '3.8.0');\n  if (options.experimentalReplAwait === true && !tsVersionSupportsTla) {\n    throw new Error(\n      'Experimental REPL await is not compatible with TypeScript versions older than 3.8'\n    );\n  }\n\n  const shouldReplAwait =\n    options.experimentalReplAwait !== false &&\n    tsVersionSupportsTla &&\n    targetSupportsTla;\n\n  // swc implies two other options\n  // typeCheck option was implemented specifically to allow overriding tsconfig transpileOnly from the command-line\n  // So we should allow using typeCheck to override swc\n  if (options.swc && !options.typeCheck) {\n    if (options.transpileOnly === false) {\n      throw new Error(\n        \"Cannot enable 'swc' option with 'transpileOnly: false'.  'swc' implies 'transpileOnly'.\"\n      );\n    }\n    if (options.transpiler) {\n      throw new Error(\n        \"Cannot specify both 'swc' and 'transpiler' options.  'swc' uses the built-in swc transpiler.\"\n      );\n    }\n  }\n\n  const readFile = options.readFile || ts.sys.readFile;\n  const fileExists = options.fileExists || ts.sys.fileExists;\n  // typeCheck can override transpileOnly, useful for CLI flag to override config file\n  const transpileOnly =\n    (options.transpileOnly === true || options.swc === true) &&\n    options.typeCheck !== true;\n  let transpiler: RegisterOptions['transpiler'] | undefined = undefined;\n  let transpilerBasePath: string | undefined = undefined;\n  if (options.transpiler) {\n    transpiler = options.transpiler;\n    transpilerBasePath = optionBasePaths.transpiler;\n  } else if (options.swc) {\n    transpiler = require.resolve('./transpilers/swc.js');\n    transpilerBasePath = optionBasePaths.swc;\n  }\n  const transformers = options.transformers || undefined;\n  const diagnosticFilters: Array<DiagnosticFilter> = [\n    {\n      appliesToAllFiles: true,\n      filenamesAbsolute: [],\n      diagnosticsIgnored: [\n        6059, // \"'rootDir' is expected to contain all source files.\"\n        18002, // \"The 'files' list in config file is empty.\"\n        18003, // \"No inputs were found in config file.\"\n        ...(options.experimentalTsImportSpecifiers\n          ? [\n              2691, // \"An import path cannot end with a '.ts' extension. Consider importing '<specifier without ext>' instead.\"\n            ]\n          : []),\n        ...(options.ignoreDiagnostics || []),\n      ].map(Number),\n    },\n  ];\n\n  const configDiagnosticList = filterDiagnostics(\n    config.errors,\n    diagnosticFilters\n  );\n  const outputCache = new Map<\n    string,\n    {\n      content: string;\n    }\n  >();\n\n  const configFileDirname = configFilePath ? dirname(configFilePath) : null;\n  const scopeDir =\n    options.scopeDir ?? config.options.rootDir ?? configFileDirname ?? cwd;\n  const ignoreBaseDir = configFileDirname ?? cwd;\n  const isScoped = options.scope\n    ? (fileName: string) => relative(scopeDir, fileName).charAt(0) !== '.'\n    : () => true;\n  const shouldIgnore = createIgnore(\n    ignoreBaseDir,\n    options.skipIgnore\n      ? []\n      : (options.ignore || ['(?:^|/)node_modules/']).map(\n          (str) => new RegExp(str)\n        )\n  );\n\n  const diagnosticHost: _ts.FormatDiagnosticsHost = {\n    getNewLine: () => ts.sys.newLine,\n    getCurrentDirectory: () => cwd,\n    // TODO switch to getCanonicalFileName we already create later in scope\n    getCanonicalFileName: ts.sys.useCaseSensitiveFileNames\n      ? (x) => x\n      : (x) => x.toLowerCase(),\n  };\n\n  if (options.transpileOnly && typeof transformers === 'function') {\n    throw new TypeError(\n      'Transformers function is unavailable in \"--transpile-only\"'\n    );\n  }\n  let createTranspiler = initializeTranspilerFactory();\n  function initializeTranspilerFactory() {\n    if (transpiler) {\n      if (!transpileOnly)\n        throw new Error(\n          'Custom transpiler can only be used when transpileOnly is enabled.'\n        );\n      const transpilerName =\n        typeof transpiler === 'string' ? transpiler : transpiler[0];\n      const transpilerOptions =\n        typeof transpiler === 'string' ? {} : transpiler[1] ?? {};\n      const transpilerConfigLocalResolveHelper = transpilerBasePath\n        ? createProjectLocalResolveHelper(transpilerBasePath)\n        : projectLocalResolveHelper;\n      const transpilerPath = transpilerConfigLocalResolveHelper(\n        transpilerName,\n        true\n      );\n      const transpilerFactory = require(transpilerPath)\n        .create as TranspilerFactory;\n      return createTranspiler;\n\n      function createTranspiler(\n        compilerOptions: TSCommon.CompilerOptions,\n        nodeModuleEmitKind?: NodeModuleEmitKind\n      ) {\n        return transpilerFactory?.({\n          service: {\n            options,\n            config: {\n              ...config,\n              options: compilerOptions,\n            },\n            projectLocalResolveHelper,\n          },\n          transpilerConfigLocalResolveHelper,\n          nodeModuleEmitKind,\n          ...transpilerOptions,\n        });\n      }\n    }\n  }\n\n  /**\n   * True if require() hooks should interop with experimental ESM loader.\n   * Enabled explicitly via a flag since it is a breaking change.\n   */\n  let experimentalEsmLoader = false;\n  function enableExperimentalEsmLoaderInterop() {\n    experimentalEsmLoader = true;\n  }\n\n  // Install source map support and read from memory cache.\n  installSourceMapSupport();\n  function installSourceMapSupport() {\n    const sourceMapSupport =\n      require('@cspotcode/source-map-support') as typeof _sourceMapSupport;\n    sourceMapSupport.install({\n      environment: 'node',\n      retrieveFile(pathOrUrl: string) {\n        let path = pathOrUrl;\n        // If it's a file URL, convert to local path\n        // Note: fileURLToPath does not exist on early node v10\n        // I could not find a way to handle non-URLs except to swallow an error\n        if (experimentalEsmLoader && path.startsWith('file://')) {\n          try {\n            path = fileURLToPath(path);\n          } catch (e) {\n            /* swallow error */\n          }\n        }\n        path = normalizeSlashes(path);\n        return outputCache.get(path)?.content || '';\n      },\n      redirectConflictingLibrary: true,\n      onConflictingLibraryRedirect(\n        request,\n        parent,\n        isMain,\n        options,\n        redirectedRequest\n      ) {\n        debug(\n          `Redirected an attempt to require source-map-support to instead receive @cspotcode/source-map-support.  \"${\n            (parent as NodeJS.Module).filename\n          }\" attempted to require or resolve \"${request}\" and was redirected to \"${redirectedRequest}\".`\n        );\n      },\n    });\n  }\n\n  const shouldHavePrettyErrors =\n    options.pretty === undefined ? process.stdout.isTTY : options.pretty;\n\n  const formatDiagnostics = shouldHavePrettyErrors\n    ? ts.formatDiagnosticsWithColorAndContext || ts.formatDiagnostics\n    : ts.formatDiagnostics;\n\n  function createTSError(diagnostics: ReadonlyArray<_ts.Diagnostic>) {\n    const diagnosticText = formatDiagnostics(diagnostics, diagnosticHost);\n    const diagnosticCodes = diagnostics.map((x) => x.code);\n    return new TSError(diagnosticText, diagnosticCodes, diagnostics);\n  }\n\n  function reportTSError(configDiagnosticList: _ts.Diagnostic[]) {\n    const error = createTSError(configDiagnosticList);\n    if (options.logError) {\n      // Print error in red color and continue execution.\n      console.error('\\x1b[31m%s\\x1b[0m', error);\n    } else {\n      // Throw error and exit the script.\n      throw error;\n    }\n  }\n\n  // Render the configuration errors.\n  if (configDiagnosticList.length) reportTSError(configDiagnosticList);\n\n  const jsxEmitPreserve = config.options.jsx === ts.JsxEmit.Preserve;\n  /**\n   * Get the extension for a transpiled file.\n   * [MUST_UPDATE_FOR_NEW_FILE_EXTENSIONS]\n   */\n  function getEmitExtension(path: string) {\n    const lastDotIndex = path.lastIndexOf('.');\n    if (lastDotIndex >= 0) {\n      const ext = path.slice(lastDotIndex);\n      switch (ext) {\n        case '.js':\n        case '.ts':\n          return '.js';\n        case '.jsx':\n        case '.tsx':\n          return jsxEmitPreserve ? '.jsx' : '.js';\n        case '.mjs':\n        case '.mts':\n          return '.mjs';\n        case '.cjs':\n        case '.cts':\n          return '.cjs';\n      }\n    }\n    return '.js';\n  }\n\n  type GetOutputFunction = (code: string, fileName: string) => SourceOutput;\n  /**\n   * Get output from TS compiler w/typechecking.  `undefined` in `transpileOnly`\n   * mode.\n   */\n  let getOutput: GetOutputFunction | undefined;\n  let getTypeInfo: (\n    _code: string,\n    _fileName: string,\n    _position: number\n  ) => TypeInfo;\n\n  const getCanonicalFileName = (\n    ts as unknown as TSInternal\n  ).createGetCanonicalFileName(ts.sys.useCaseSensitiveFileNames);\n\n  const moduleTypeClassifier = createModuleTypeClassifier({\n    basePath: options.optionBasePaths?.moduleTypes,\n    patterns: options.moduleTypes,\n  });\n\n  const extensions = getExtensions(config, options, ts.version);\n\n  // Use full language services when the fast option is disabled.\n  if (!transpileOnly) {\n    const fileContents = new Map<string, string>();\n    const rootFileNames = new Set(config.fileNames);\n    const cachedReadFile = cachedLookup(debugFn('readFile', readFile));\n\n    // Use language services by default\n    if (!options.compilerHost) {\n      let projectVersion = 1;\n      const fileVersions = new Map(\n        Array.from(rootFileNames).map((fileName) => [fileName, 0])\n      );\n\n      const getCustomTransformers = () => {\n        if (typeof transformers === 'function') {\n          const program = service.getProgram();\n          return program ? transformers(program) : undefined;\n        }\n\n        return transformers;\n      };\n\n      // Create the compiler host for type checking.\n      const serviceHost: _ts.LanguageServiceHost &\n        Required<Pick<_ts.LanguageServiceHost, 'fileExists' | 'readFile'>> = {\n        getProjectVersion: () => String(projectVersion),\n        getScriptFileNames: () => Array.from(rootFileNames),\n        getScriptVersion: (fileName: string) => {\n          const version = fileVersions.get(fileName);\n          return version ? version.toString() : '';\n        },\n        getScriptSnapshot(fileName: string) {\n          // TODO ordering of this with getScriptVersion?  Should they sync up?\n          let contents = fileContents.get(fileName);\n\n          // Read contents into TypeScript memory cache.\n          if (contents === undefined) {\n            contents = cachedReadFile(fileName);\n            if (contents === undefined) return;\n\n            fileVersions.set(fileName, 1);\n            fileContents.set(fileName, contents);\n            projectVersion++;\n          }\n\n          return ts.ScriptSnapshot.fromString(contents);\n        },\n        readFile: cachedReadFile,\n        readDirectory: ts.sys.readDirectory,\n        getDirectories: cachedLookup(\n          debugFn('getDirectories', ts.sys.getDirectories)\n        ),\n        fileExists: cachedLookup(debugFn('fileExists', fileExists)),\n        directoryExists: cachedLookup(\n          debugFn('directoryExists', ts.sys.directoryExists)\n        ),\n        realpath: ts.sys.realpath\n          ? cachedLookup(debugFn('realpath', ts.sys.realpath))\n          : undefined,\n        getNewLine: () => ts.sys.newLine,\n        useCaseSensitiveFileNames: () => ts.sys.useCaseSensitiveFileNames,\n        getCurrentDirectory: () => cwd,\n        getCompilationSettings: () => config.options,\n        getDefaultLibFileName: () => ts.getDefaultLibFilePath(config.options),\n        getCustomTransformers: getCustomTransformers,\n        trace: options.tsTrace,\n      };\n      const {\n        resolveModuleNames,\n        getResolvedModuleWithFailedLookupLocationsFromCache,\n        resolveTypeReferenceDirectives,\n        isFileKnownToBeInternal,\n        markBucketOfFilenameInternal,\n      } = createResolverFunctions({\n        host: serviceHost,\n        getCanonicalFileName,\n        ts,\n        cwd,\n        config,\n        projectLocalResolveHelper,\n        options,\n        extensions,\n      });\n      serviceHost.resolveModuleNames = resolveModuleNames;\n      serviceHost.getResolvedModuleWithFailedLookupLocationsFromCache =\n        getResolvedModuleWithFailedLookupLocationsFromCache;\n      serviceHost.resolveTypeReferenceDirectives =\n        resolveTypeReferenceDirectives;\n\n      const registry = ts.createDocumentRegistry(\n        ts.sys.useCaseSensitiveFileNames,\n        cwd\n      );\n      const service = ts.createLanguageService(serviceHost, registry);\n\n      const updateMemoryCache = (contents: string, fileName: string) => {\n        // Add to `rootFiles` as necessary, either to make TS include a file it has not seen,\n        // or to trigger a re-classification of files from external to internal.\n        if (\n          !rootFileNames.has(fileName) &&\n          !isFileKnownToBeInternal(fileName)\n        ) {\n          markBucketOfFilenameInternal(fileName);\n          rootFileNames.add(fileName);\n          // Increment project version for every change to rootFileNames.\n          projectVersion++;\n        }\n\n        const previousVersion = fileVersions.get(fileName) || 0;\n        const previousContents = fileContents.get(fileName);\n        // Avoid incrementing cache when nothing has changed.\n        if (contents !== previousContents) {\n          fileVersions.set(fileName, previousVersion + 1);\n          fileContents.set(fileName, contents);\n          // Increment project version for every file change.\n          projectVersion++;\n        }\n      };\n\n      let previousProgram: _ts.Program | undefined = undefined;\n\n      getOutput = (code: string, fileName: string) => {\n        updateMemoryCache(code, fileName);\n\n        const programBefore = service.getProgram();\n        if (programBefore !== previousProgram) {\n          debug(\n            `compiler rebuilt Program instance when getting output for ${fileName}`\n          );\n        }\n\n        const output = service.getEmitOutput(fileName);\n\n        // Get the relevant diagnostics - this is 3x faster than `getPreEmitDiagnostics`.\n        const diagnostics = service\n          .getSemanticDiagnostics(fileName)\n          .concat(service.getSyntacticDiagnostics(fileName));\n\n        const programAfter = service.getProgram();\n\n        debug(\n          'invariant: Is service.getProject() identical before and after getting emit output and diagnostics? (should always be true) ',\n          programBefore === programAfter\n        );\n\n        previousProgram = programAfter;\n\n        const diagnosticList = filterDiagnostics(\n          diagnostics,\n          diagnosticFilters\n        );\n        if (diagnosticList.length) reportTSError(diagnosticList);\n\n        if (output.emitSkipped) {\n          return [undefined, undefined, true];\n        }\n\n        // Throw an error when requiring `.d.ts` files.\n        if (output.outputFiles.length === 0) {\n          throw new TypeError(\n            `Unable to require file: ${relative(cwd, fileName)}\\n` +\n              'This is usually the result of a faulty configuration or import. ' +\n              'Make sure there is a `.js`, `.json` or other executable extension with ' +\n              'loader attached before `ts-node` available.'\n          );\n        }\n\n        return [output.outputFiles[1].text, output.outputFiles[0].text, false];\n      };\n\n      getTypeInfo = (code: string, fileName: string, position: number) => {\n        const normalizedFileName = normalizeSlashes(fileName);\n        updateMemoryCache(code, normalizedFileName);\n\n        const info = service.getQuickInfoAtPosition(\n          normalizedFileName,\n          position\n        );\n        const name = ts.displayPartsToString(info ? info.displayParts : []);\n        const comment = ts.displayPartsToString(info ? info.documentation : []);\n\n        return { name, comment };\n      };\n    } else {\n      const sys: _ts.System & _ts.FormatDiagnosticsHost = {\n        ...ts.sys,\n        ...diagnosticHost,\n        readFile: (fileName: string) => {\n          const cacheContents = fileContents.get(fileName);\n          if (cacheContents !== undefined) return cacheContents;\n          const contents = cachedReadFile(fileName);\n          if (contents) fileContents.set(fileName, contents);\n          return contents;\n        },\n        readDirectory: ts.sys.readDirectory,\n        getDirectories: cachedLookup(\n          debugFn('getDirectories', ts.sys.getDirectories)\n        ),\n        fileExists: cachedLookup(debugFn('fileExists', fileExists)),\n        directoryExists: cachedLookup(\n          debugFn('directoryExists', ts.sys.directoryExists)\n        ),\n        resolvePath: cachedLookup(debugFn('resolvePath', ts.sys.resolvePath)),\n        realpath: ts.sys.realpath\n          ? cachedLookup(debugFn('realpath', ts.sys.realpath))\n          : undefined,\n      };\n\n      const host: _ts.CompilerHost = ts.createIncrementalCompilerHost\n        ? ts.createIncrementalCompilerHost(config.options, sys)\n        : {\n            ...sys,\n            getSourceFile: (fileName, languageVersion) => {\n              const contents = sys.readFile(fileName);\n              if (contents === undefined) return;\n              return ts.createSourceFile(fileName, contents, languageVersion);\n            },\n            getDefaultLibLocation: () => normalizeSlashes(dirname(compiler)),\n            getDefaultLibFileName: () =>\n              normalizeSlashes(\n                join(\n                  dirname(compiler),\n                  ts.getDefaultLibFileName(config.options)\n                )\n              ),\n            useCaseSensitiveFileNames: () => sys.useCaseSensitiveFileNames,\n          };\n      host.trace = options.tsTrace;\n      const {\n        resolveModuleNames,\n        resolveTypeReferenceDirectives,\n        isFileKnownToBeInternal,\n        markBucketOfFilenameInternal,\n      } = createResolverFunctions({\n        host,\n        cwd,\n        config,\n        ts,\n        getCanonicalFileName,\n        projectLocalResolveHelper,\n        options,\n        extensions,\n      });\n      host.resolveModuleNames = resolveModuleNames;\n      host.resolveTypeReferenceDirectives = resolveTypeReferenceDirectives;\n\n      // Fallback for older TypeScript releases without incremental API.\n      let builderProgram = ts.createIncrementalProgram\n        ? ts.createIncrementalProgram({\n            rootNames: Array.from(rootFileNames),\n            options: config.options,\n            host,\n            configFileParsingDiagnostics: config.errors,\n            projectReferences: config.projectReferences,\n          })\n        : ts.createEmitAndSemanticDiagnosticsBuilderProgram(\n            Array.from(rootFileNames),\n            config.options,\n            host,\n            undefined,\n            config.errors,\n            config.projectReferences\n          );\n\n      // Read and cache custom transformers.\n      const customTransformers =\n        typeof transformers === 'function'\n          ? transformers(builderProgram.getProgram())\n          : transformers;\n\n      // Set the file contents into cache manually.\n      const updateMemoryCache = (contents: string, fileName: string) => {\n        const previousContents = fileContents.get(fileName);\n        const contentsChanged = previousContents !== contents;\n        if (contentsChanged) {\n          fileContents.set(fileName, contents);\n        }\n\n        // Add to `rootFiles` when discovered by compiler for the first time.\n        let addedToRootFileNames = false;\n        if (\n          !rootFileNames.has(fileName) &&\n          !isFileKnownToBeInternal(fileName)\n        ) {\n          markBucketOfFilenameInternal(fileName);\n          rootFileNames.add(fileName);\n          addedToRootFileNames = true;\n        }\n\n        // Update program when file changes.\n        if (addedToRootFileNames || contentsChanged) {\n          builderProgram = ts.createEmitAndSemanticDiagnosticsBuilderProgram(\n            Array.from(rootFileNames),\n            config.options,\n            host,\n            builderProgram,\n            config.errors,\n            config.projectReferences\n          );\n        }\n      };\n\n      getOutput = (code: string, fileName: string) => {\n        let outText = '';\n        let outMap = '';\n\n        updateMemoryCache(code, fileName);\n\n        const sourceFile = builderProgram.getSourceFile(fileName);\n        if (!sourceFile)\n          throw new TypeError(`Unable to read file: ${fileName}`);\n\n        const program = builderProgram.getProgram();\n        const diagnostics = ts.getPreEmitDiagnostics(program, sourceFile);\n        const diagnosticList = filterDiagnostics(\n          diagnostics,\n          diagnosticFilters\n        );\n        if (diagnosticList.length) reportTSError(diagnosticList);\n\n        const result = builderProgram.emit(\n          sourceFile,\n          (path, file, writeByteOrderMark) => {\n            if (path.endsWith('.map')) {\n              outMap = file;\n            } else {\n              outText = file;\n            }\n\n            if (options.emit) sys.writeFile(path, file, writeByteOrderMark);\n          },\n          undefined,\n          undefined,\n          customTransformers\n        );\n\n        if (result.emitSkipped) {\n          return [undefined, undefined, true];\n        }\n\n        // Throw an error when requiring files that cannot be compiled.\n        if (outText === '') {\n          if (program.isSourceFileFromExternalLibrary(sourceFile)) {\n            throw new TypeError(\n              `Unable to compile file from external library: ${relative(\n                cwd,\n                fileName\n              )}`\n            );\n          }\n\n          throw new TypeError(\n            `Unable to require file: ${relative(cwd, fileName)}\\n` +\n              'This is usually the result of a faulty configuration or import. ' +\n              'Make sure there is a `.js`, `.json` or other executable extension with ' +\n              'loader attached before `ts-node` available.'\n          );\n        }\n\n        return [outText, outMap, false];\n      };\n\n      getTypeInfo = (code: string, fileName: string, position: number) => {\n        const normalizedFileName = normalizeSlashes(fileName);\n        updateMemoryCache(code, normalizedFileName);\n\n        const sourceFile = builderProgram.getSourceFile(normalizedFileName);\n        if (!sourceFile)\n          throw new TypeError(`Unable to read file: ${fileName}`);\n\n        const node = getTokenAtPosition(ts, sourceFile, position);\n        const checker = builderProgram.getProgram().getTypeChecker();\n        const symbol = checker.getSymbolAtLocation(node);\n\n        if (!symbol) return { name: '', comment: '' };\n\n        const type = checker.getTypeOfSymbolAtLocation(symbol, node);\n        const signatures = [\n          ...type.getConstructSignatures(),\n          ...type.getCallSignatures(),\n        ];\n\n        return {\n          name: signatures.length\n            ? signatures.map((x) => checker.signatureToString(x)).join('\\n')\n            : checker.typeToString(type),\n          comment: ts.displayPartsToString(\n            symbol ? symbol.getDocumentationComment(checker) : []\n          ),\n        };\n      };\n\n      // Write `.tsbuildinfo` when `--build` is enabled.\n      if (options.emit && config.options.incremental) {\n        process.on('exit', () => {\n          // Emits `.tsbuildinfo` to filesystem.\n          (builderProgram.getProgram() as any).emitBuildInfo();\n        });\n      }\n    }\n  } else {\n    getTypeInfo = () => {\n      throw new TypeError(\n        'Type information is unavailable in \"--transpile-only\"'\n      );\n    };\n  }\n\n  function createTranspileOnlyGetOutputFunction(\n    overrideModuleType?: _ts.ModuleKind,\n    nodeModuleEmitKind?: NodeModuleEmitKind\n  ): GetOutputFunction {\n    const compilerOptions = { ...config.options };\n    if (overrideModuleType !== undefined)\n      compilerOptions.module = overrideModuleType;\n    let customTranspiler = createTranspiler?.(\n      compilerOptions,\n      nodeModuleEmitKind\n    );\n    let tsTranspileModule = versionGteLt(ts.version, '4.7.0')\n      ? createTsTranspileModule(ts, {\n          compilerOptions,\n          reportDiagnostics: true,\n          transformers: transformers as _ts.CustomTransformers | undefined,\n        })\n      : undefined;\n    return (code: string, fileName: string): SourceOutput => {\n      let result: _ts.TranspileOutput;\n      if (customTranspiler) {\n        result = customTranspiler.transpile(code, {\n          fileName,\n        });\n      } else if (tsTranspileModule) {\n        result = tsTranspileModule(\n          code,\n          {\n            fileName,\n          },\n          nodeModuleEmitKind === 'nodeesm' ? 'module' : 'commonjs'\n        );\n      } else {\n        result = ts.transpileModule(code, {\n          fileName,\n          compilerOptions,\n          reportDiagnostics: true,\n          transformers: transformers as _ts.CustomTransformers | undefined,\n        });\n      }\n\n      const diagnosticList = filterDiagnostics(\n        result.diagnostics || [],\n        diagnosticFilters\n      );\n      if (diagnosticList.length) reportTSError(diagnosticList);\n\n      return [result.outputText, result.sourceMapText as string, false];\n    };\n  }\n\n  // When true, these mean that a `moduleType` override will cause a different emit\n  // than the TypeScript compiler, so we *must* overwrite the emit.\n  const shouldOverwriteEmitWhenForcingCommonJS =\n    config.options.module !== ts.ModuleKind.CommonJS;\n  // [MUST_UPDATE_FOR_NEW_MODULEKIND]\n  const shouldOverwriteEmitWhenForcingEsm = !(\n    config.options.module === ts.ModuleKind.ES2015 ||\n    (ts.ModuleKind.ES2020 && config.options.module === ts.ModuleKind.ES2020) ||\n    (ts.ModuleKind.ES2022 && config.options.module === ts.ModuleKind.ES2022) ||\n    config.options.module === ts.ModuleKind.ESNext\n  );\n  /**\n   * node16 or nodenext\n   * [MUST_UPDATE_FOR_NEW_MODULEKIND]\n   */\n  const isNodeModuleType =\n    (ts.ModuleKind.Node16 && config.options.module === ts.ModuleKind.Node16) ||\n    (ts.ModuleKind.NodeNext &&\n      config.options.module === ts.ModuleKind.NodeNext);\n  const getOutputForceCommonJS = createTranspileOnlyGetOutputFunction(\n    ts.ModuleKind.CommonJS\n  );\n  const getOutputForceNodeCommonJS = createTranspileOnlyGetOutputFunction(\n    ts.ModuleKind.NodeNext,\n    'nodecjs'\n  );\n  const getOutputForceNodeESM = createTranspileOnlyGetOutputFunction(\n    ts.ModuleKind.NodeNext,\n    'nodeesm'\n  );\n  // [MUST_UPDATE_FOR_NEW_MODULEKIND]\n  const getOutputForceESM = createTranspileOnlyGetOutputFunction(\n    ts.ModuleKind.ES2022 || ts.ModuleKind.ES2020 || ts.ModuleKind.ES2015\n  );\n  const getOutputTranspileOnly = createTranspileOnlyGetOutputFunction();\n\n  // Create a simple TypeScript compiler proxy.\n  function compile(code: string, fileName: string, lineOffset = 0) {\n    const normalizedFileName = normalizeSlashes(fileName);\n    const classification =\n      moduleTypeClassifier.classifyModuleByModuleTypeOverrides(\n        normalizedFileName\n      );\n    let value: string | undefined = '';\n    let sourceMap: string | undefined = '';\n    let emitSkipped = true;\n    if (getOutput) {\n      // Must always call normal getOutput to throw typechecking errors\n      [value, sourceMap, emitSkipped] = getOutput(code, normalizedFileName);\n    }\n    // If module classification contradicts the above, call the relevant transpiler\n    if (\n      classification.moduleType === 'cjs' &&\n      (shouldOverwriteEmitWhenForcingCommonJS || emitSkipped)\n    ) {\n      [value, sourceMap] = getOutputForceCommonJS(code, normalizedFileName);\n    } else if (\n      classification.moduleType === 'esm' &&\n      (shouldOverwriteEmitWhenForcingEsm || emitSkipped)\n    ) {\n      [value, sourceMap] = getOutputForceESM(code, normalizedFileName);\n    } else if (emitSkipped) {\n      // Happens when ts compiler skips emit or in transpileOnly mode\n      const classification = classifyModule(fileName, isNodeModuleType);\n      [value, sourceMap] =\n        classification === 'nodecjs'\n          ? getOutputForceNodeCommonJS(code, normalizedFileName)\n          : classification === 'nodeesm'\n          ? getOutputForceNodeESM(code, normalizedFileName)\n          : classification === 'cjs'\n          ? getOutputForceCommonJS(code, normalizedFileName)\n          : classification === 'esm'\n          ? getOutputForceESM(code, normalizedFileName)\n          : getOutputTranspileOnly(code, normalizedFileName);\n    }\n    const output = updateOutput(\n      value!,\n      normalizedFileName,\n      sourceMap!,\n      getEmitExtension\n    );\n    outputCache.set(normalizedFileName, { content: output });\n    return output;\n  }\n\n  let active = true;\n  const enabled = (enabled?: boolean) =>\n    enabled === undefined ? active : (active = !!enabled);\n  const ignored = (fileName: string) => {\n    if (!active) return true;\n    const ext = extname(fileName);\n    if (extensions.compiled.includes(ext)) {\n      return !isScoped(fileName) || shouldIgnore(fileName);\n    }\n    return true;\n  };\n\n  function addDiagnosticFilter(filter: DiagnosticFilter) {\n    diagnosticFilters.push({\n      ...filter,\n      filenamesAbsolute: filter.filenamesAbsolute.map((f) =>\n        normalizeSlashes(f)\n      ),\n    });\n  }\n\n  const getNodeEsmResolver = once(() =>\n    (\n      require('../dist-raw/node-internal-modules-esm-resolve') as typeof _nodeInternalModulesEsmResolve\n    ).createResolve({\n      extensions,\n      preferTsExts: options.preferTsExts,\n      tsNodeExperimentalSpecifierResolution:\n        options.experimentalSpecifierResolution,\n    })\n  );\n  const getNodeEsmGetFormat = once(() =>\n    (\n      require('../dist-raw/node-internal-modules-esm-get_format') as typeof _nodeInternalModulesEsmGetFormat\n    ).createGetFormat(\n      options.experimentalSpecifierResolution,\n      getNodeEsmResolver()\n    )\n  );\n  const getNodeCjsLoader = once(() =>\n    (\n      require('../dist-raw/node-internal-modules-cjs-loader') as typeof _nodeInternalModulesCjsLoader\n    ).createCjsLoader({\n      extensions,\n      preferTsExts: options.preferTsExts,\n      nodeEsmResolver: getNodeEsmResolver(),\n    })\n  );\n\n  return {\n    [TS_NODE_SERVICE_BRAND]: true,\n    ts,\n    compilerPath: compiler,\n    config,\n    compile,\n    getTypeInfo,\n    ignored,\n    enabled,\n    options,\n    configFilePath,\n    moduleTypeClassifier,\n    shouldReplAwait,\n    addDiagnosticFilter,\n    installSourceMapSupport,\n    enableExperimentalEsmLoaderInterop,\n    transpileOnly,\n    projectLocalResolveHelper,\n    getNodeEsmResolver,\n    getNodeEsmGetFormat,\n    getNodeCjsLoader,\n    extensions,\n  };\n}\n\n/**\n * Check if the filename should be ignored.\n */\nfunction createIgnore(ignoreBaseDir: string, ignore: RegExp[]) {\n  return (fileName: string) => {\n    const relname = relative(ignoreBaseDir, fileName);\n    const path = normalizeSlashes(relname);\n\n    return ignore.some((x) => x.test(path));\n  };\n}\n\n/**\n * Register the extensions to support when importing files.\n */\nfunction registerExtensions(\n  preferTsExts: boolean | null | undefined,\n  extensions: string[],\n  service: Service,\n  originalJsHandler: (m: NodeModule, filename: string) => any\n) {\n  const exts = new Set(extensions);\n  // Can't add these extensions cuz would allow omitting file extension; node requires ext for .cjs and .mjs\n  // Unless they're already registered by something else (nyc does this):\n  // then we *must* hook them or else our transformer will not be called.\n  for (const cannotAdd of ['.mts', '.cts', '.mjs', '.cjs']) {\n    if (exts.has(cannotAdd) && !hasOwnProperty(require.extensions, cannotAdd)) {\n      // Unrecognized file exts can be transformed via the `.js` handler.\n      exts.add('.js');\n      exts.delete(cannotAdd);\n    }\n  }\n\n  // Register new extensions.\n  for (const ext of exts) {\n    registerExtension(ext, service, originalJsHandler);\n  }\n\n  if (preferTsExts) {\n    const preferredExtensions = new Set([\n      ...exts,\n      ...Object.keys(require.extensions),\n    ]);\n\n    // Re-sort iteration order of Object.keys()\n    for (const ext of preferredExtensions) {\n      const old = Object.getOwnPropertyDescriptor(require.extensions, ext);\n      delete require.extensions[ext];\n      Object.defineProperty(require.extensions, ext, old!);\n    }\n  }\n}\n\n/**\n * Register the extension for node.\n */\nfunction registerExtension(\n  ext: string,\n  service: Service,\n  originalHandler: (m: NodeModule, filename: string) => any\n) {\n  const old = require.extensions[ext] || originalHandler;\n\n  require.extensions[ext] = function (m: any, filename) {\n    if (service.ignored(filename)) return old(m, filename);\n\n    assertScriptCanLoadAsCJS(service, m, filename);\n\n    const _compile = m._compile;\n\n    m._compile = function (code: string, fileName: string) {\n      debug('module._compile', fileName);\n\n      const result = service.compile(code, fileName);\n      return _compile.call(this, result, fileName);\n    };\n\n    return old(m, filename);\n  };\n}\n\n/**\n * Internal source output.\n */\ntype SourceOutput = [string, string, false] | [undefined, undefined, true];\n\n/**\n * Update the output remapping the source map.\n */\nfunction updateOutput(\n  outputText: string,\n  fileName: string,\n  sourceMap: string,\n  getEmitExtension: (fileName: string) => string\n) {\n  const base64Map = Buffer.from(\n    updateSourceMap(sourceMap, fileName),\n    'utf8'\n  ).toString('base64');\n  const sourceMapContent = `//# sourceMappingURL=data:application/json;charset=utf-8;base64,${base64Map}`;\n  // Expected form: `//# sourceMappingURL=foo bar.js.map` or `//# sourceMappingURL=foo%20bar.js.map` for input file \"foo bar.tsx\"\n  // Percent-encoding behavior added in TS 4.1.1: https://github.com/microsoft/TypeScript/issues/40951\n  const prefix = '//# sourceMappingURL=';\n  const prefixLength = prefix.length;\n  const baseName = /*foo.tsx*/ basename(fileName);\n  const extName = /*.tsx*/ extname(fileName);\n  const extension = /*.js*/ getEmitExtension(fileName);\n  const sourcemapFilename =\n    baseName.slice(0, -extName.length) + extension + '.map';\n  const sourceMapLengthWithoutPercentEncoding =\n    prefixLength + sourcemapFilename.length;\n  /*\n   * Only rewrite if existing directive exists at the location we expect, to support:\n   *   a) compilers that do not append a sourcemap directive\n   *   b) situations where we did the math wrong\n   *     Not ideal, but appending our sourcemap *after* a pre-existing sourcemap still overrides, so the end-user is happy.\n   */\n  if (\n    outputText.substr(-sourceMapLengthWithoutPercentEncoding, prefixLength) ===\n    prefix\n  ) {\n    return (\n      outputText.slice(0, -sourceMapLengthWithoutPercentEncoding) +\n      sourceMapContent\n    );\n  }\n  // If anyone asks why we're not using URL, the URL equivalent is: `u = new URL('http://d'); u.pathname = \"/\" + sourcemapFilename; return u.pathname.slice(1);\n  const sourceMapLengthWithPercentEncoding =\n    prefixLength + encodeURI(sourcemapFilename).length;\n  if (\n    outputText.substr(-sourceMapLengthWithPercentEncoding, prefixLength) ===\n    prefix\n  ) {\n    return (\n      outputText.slice(0, -sourceMapLengthWithPercentEncoding) +\n      sourceMapContent\n    );\n  }\n\n  return `${outputText}\\n${sourceMapContent}`;\n}\n\n/**\n * Update the source map contents for improved output.\n */\nfunction updateSourceMap(sourceMapText: string, fileName: string) {\n  const sourceMap = JSON.parse(sourceMapText);\n  sourceMap.file = fileName;\n  sourceMap.sources = [fileName];\n  delete sourceMap.sourceRoot;\n  return JSON.stringify(sourceMap);\n}\n\n/**\n * Filter diagnostics.\n */\nfunction filterDiagnostics(\n  diagnostics: readonly _ts.Diagnostic[],\n  filters: DiagnosticFilter[]\n) {\n  return diagnostics.filter((d) =>\n    filters.every(\n      (f) =>\n        (!f.appliesToAllFiles &&\n          f.filenamesAbsolute.indexOf(d.file?.fileName!) === -1) ||\n        f.diagnosticsIgnored.indexOf(d.code) === -1\n    )\n  );\n}\n\n/**\n * Get token at file position.\n *\n * Reference: https://github.com/microsoft/TypeScript/blob/fcd9334f57d85b73dd66ad2d21c02e84822f4841/src/services/utilities.ts#L705-L731\n */\nfunction getTokenAtPosition(\n  ts: TSCommon,\n  sourceFile: _ts.SourceFile,\n  position: number\n): _ts.Node {\n  let current: _ts.Node = sourceFile;\n\n  outer: while (true) {\n    for (const child of current.getChildren(sourceFile)) {\n      const start = child.getFullStart();\n      if (start > position) break;\n\n      const end = child.getEnd();\n      if (position <= end) {\n        current = child;\n        continue outer;\n      }\n    }\n\n    return current;\n  }\n}\n\n/**\n * Create an implementation of node's ESM loader hooks.\n *\n * This may be useful if you\n * want to wrap or compose the loader hooks to add additional functionality or\n * combine with another loader.\n *\n * Node changed the hooks API, so there are two possible APIs.  This function\n * detects your node version and returns the appropriate API.\n *\n * @category ESM Loader\n */\nexport const createEsmHooks: typeof createEsmHooksFn = (\n  tsNodeService: Service\n) => (require('./esm') as typeof import('./esm')).createEsmHooks(tsNodeService);\n\n/**\n * When using `module: nodenext` or `module: node12`, there are two possible styles of emit depending in file extension or package.json \"type\":\n *\n * - CommonJS with dynamic imports preserved (not transformed into `require()` calls)\n * - ECMAScript modules with `import foo = require()` transformed into `require = createRequire(); const foo = require()`\n */\nexport type NodeModuleEmitKind = 'nodeesm' | 'nodecjs';\n"],"mappings":";;;;;;;AAAA,MAAAA,MAAA,GAAAC,OAAA;AACA,MAAAC,QAAA,GAAAD,OAAA;AACA,MAAAE,IAAA,GAAAF,OAAA;AACA,MAAAG,KAAA,GAAAH,OAAA;AAGA,MAAAI,YAAA,GAAAJ,OAAA;AAIA,MAAAK,MAAA,GAAAL,OAAA;AAYA,MAAAM,eAAA,GAAAN,OAAA;AAEA,MAAAO,wBAAA,GAAAP,OAAA;AAIA,MAAAQ,oBAAA,GAAAR,OAAA;AAEA,MAAAS,mBAAA,GAAAT,OAAA;AAIA,MAAAU,6BAAA,GAAAV,OAAA;AAIA,MAAAW,iBAAA,GAAAX,OAAA;AACA,MAAAY,qBAAA,GAAAZ,OAAA;AAGA,IAAAa,MAAA,GAAAb,OAAA;AACEc,MAAA,CAAAC,cAAA,CAAAC,OAAA;EAAAC,UAAA;EAAAC,GAAA,WAAAA,CAAA;IAAA,OAAAL,MAAA,CAAAM,UAAU;EAAA;AAAA;AAmBZ;;;;AAIA,MAAMC,8BAA8B,GAClCC,QAAQ,CAACC,OAAO,CAACC,QAAQ,CAACC,IAAI,CAACC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,IAAI,EAAE;AAEzD;;;;;;AAMA,IAAIC,wBAAwB,GAIhBN,8BAA8B,GAEpCpB,OAAO,CAAC,8CAA8C,CACvD,CAAC2B,4BAA4B,GAC9B,MAAK;EACH;AAAA,CACD;AAEL;;;AAGaX,OAAA,CAAAY,iBAAiB,GAAGC,MAAM,CAACC,GAAG,CAAC,2BAA2B,CAAC;AAaxE;AACad,OAAA,CAAAe,GAAG,GAAGT,OAAO,CAACS,GAAiB;AAkC5C;;;AAGaf,OAAA,CAAAgB,cAAc,GAAG9B,IAAI,CAAC+B,OAAO,CAACC,MAAM,IAAI,SAAS;AAE9D;;;AAGA,MAAMC,WAAW,GAAG,IAAA9B,MAAA,CAAA+B,EAAE,EAACpB,OAAA,CAAAe,GAAG,CAACM,aAAa,CAAC;AACzC;AACarB,OAAA,CAAAsB,KAAK,GAAGH,WAAW,GAC5B,CAAC,GAAGI,IAAS,KACXC,OAAO,CAACC,GAAG,CAAC,YAAY,IAAIC,IAAI,EAAE,CAACC,WAAW,EAAE,GAAG,EAAE,GAAGJ,IAAI,CAAC,GAC/D,MAAMK,SAAS;AACnB,MAAMC,OAAO,GAAGV,WAAW,GACvB,CAAOW,GAAW,EAAEC,EAAiB,KAAI;EACvC,IAAIC,CAAC,GAAG,CAAC;EACT,OAAQC,CAAI,IAAI;IACd,IAAAjC,OAAA,CAAAsB,KAAK,EAACQ,GAAG,EAAEG,CAAC,EAAE,EAAED,CAAC,CAAC;IAClB,OAAOD,EAAE,CAACE,CAAC,CAAC;EACd,CAAC;AACH,CAAC,GACD,CAAOC,CAAS,EAAEH,EAAiB,KAAKA,EAAE;AAE9C;;;AAGa/B,OAAA,CAAAmC,OAAO,GAAGnD,OAAO,CAAC,iBAAiB,CAAC,CAACoD,OAAO;AAsRzD;;;;;AAKapC,OAAA,CAAAqC,QAAQ,GAAoB;EACvCC,GAAG,EAAE,CAAAC,EAAA,GAAAvC,OAAA,CAAAe,GAAG,CAACyB,WAAW,cAAAD,EAAA,cAAAA,EAAA,GAAIvC,OAAA,CAAAe,GAAG,CAAC0B,WAAW;EACvCC,IAAI,EAAE,IAAArD,MAAA,CAAA+B,EAAE,EAACpB,OAAA,CAAAe,GAAG,CAAC4B,YAAY,CAAC;EAC1BC,KAAK,EAAE,IAAAvD,MAAA,CAAA+B,EAAE,EAACpB,OAAA,CAAAe,GAAG,CAAC8B,aAAa,CAAC;EAC5BC,QAAQ,EAAE9C,OAAA,CAAAe,GAAG,CAACgC,iBAAiB;EAC/BC,KAAK,EAAE,IAAA3D,MAAA,CAAA+B,EAAE,EAACpB,OAAA,CAAAe,GAAG,CAACkC,aAAa,CAAC;EAC5BC,MAAM,EAAE,IAAA7D,MAAA,CAAA+B,EAAE,EAACpB,OAAA,CAAAe,GAAG,CAACoC,cAAc,CAAC;EAC9BC,QAAQ,EAAEpD,OAAA,CAAAe,GAAG,CAACsC,gBAAgB;EAC9BC,eAAe,EAAE,IAAAjE,MAAA,CAAAkE,KAAK,EAACvD,OAAA,CAAAe,GAAG,CAACyC,wBAAwB,CAAC;EACpDC,MAAM,EAAE,IAAApE,MAAA,CAAAoB,KAAK,EAACT,OAAA,CAAAe,GAAG,CAAC2C,cAAc,CAAC;EACjCC,OAAO,EAAE3D,OAAA,CAAAe,GAAG,CAAC6C,eAAe;EAC5BC,WAAW,EAAE,IAAAxE,MAAA,CAAA+B,EAAE,EAACpB,OAAA,CAAAe,GAAG,CAAC+C,oBAAoB,CAAC;EACzCC,UAAU,EAAE,IAAA1E,MAAA,CAAA+B,EAAE,EAACpB,OAAA,CAAAe,GAAG,CAACiD,mBAAmB,CAAC;EACvCC,YAAY,EAAE,IAAA5E,MAAA,CAAA+B,EAAE,EAACpB,OAAA,CAAAe,GAAG,CAACmD,sBAAsB,CAAC;EAC5CC,iBAAiB,EAAE,IAAA9E,MAAA,CAAAoB,KAAK,EAACT,OAAA,CAAAe,GAAG,CAACqD,0BAA0B,CAAC;EACxDC,aAAa,EAAE,IAAAhF,MAAA,CAAA+B,EAAE,EAACpB,OAAA,CAAAe,GAAG,CAACuD,sBAAsB,CAAC;EAC7CC,SAAS,EAAE,IAAAlF,MAAA,CAAA+B,EAAE,EAACpB,OAAA,CAAAe,GAAG,CAACyD,kBAAkB,CAAC;EACrCC,YAAY,EAAE,IAAApF,MAAA,CAAA+B,EAAE,EAACpB,OAAA,CAAAe,GAAG,CAAC2D,qBAAqB,CAAC;EAC3CC,QAAQ,EAAE,IAAAtF,MAAA,CAAA+B,EAAE,EAACpB,OAAA,CAAAe,GAAG,CAAC6D,iBAAiB,CAAC;EACnCC,qBAAqB,EAAE,CAAAC,EAAA,OAAAzF,MAAA,CAAA+B,EAAE,EAACpB,OAAA,CAAAe,GAAG,CAACgE,+BAA+B,CAAC,cAAAD,EAAA,cAAAA,EAAA,GAAIlD,SAAS;EAC3EoD,OAAO,EAAExD,OAAO,CAACC,GAAG,CAACwD,IAAI,CAACzD,OAAO;CAClC;AAED;;;AAGA,MAAa0D,OAAQ,SAAQ9F,YAAA,CAAA+F,SAAS;EAKpCC,YACEC,cAAsB,EACfC,eAAyB,EAChCC,WAAA,GAA6C,EAAE;IAE/C,KAAK,CAAC,oCAAoCF,cAAc,EAAE,CAAC;IAHpD,KAAAC,eAAe,GAAfA,eAAe;IANxB,KAAAE,IAAI,GAAG,SAAS;IAUd1F,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,gBAAgB,EAAE;MAC5C0F,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAEN;KACR,CAAC;IACFvF,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,aAAa,EAAE;MACzC0F,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAEJ;KACR,CAAC;EACJ;EAEA;;;EAGA,CAACvF,OAAA,CAAAgB,cAAc,IAAC;IACd,OAAO,IAAI,CAACqE,cAAc;EAC5B;;AA5BFrF,OAAA,CAAAkF,OAAA,GAAAA,OAAA;AA+BA,MAAMU,qBAAqB,GAAG/E,MAAM,CAAC,uBAAuB,CAAC;AA8E7D,SAAgBgF,QAAQA,CACtBC,aAAoD;EAEpD;EACA,IAAIC,OAAO,GAAGD,aAAwB;EACtC,IAAI,EAAEA,aAAyB,aAAzBA,aAAa,uBAAbA,aAAa,CAAeF,qBAAqB,CAAC,GAAE;IACxD;IACAG,OAAO,GAAGC,MAAM,CAAEF,aAAa,aAAbA,aAAa,cAAbA,aAAa,GAAI,EAAsB,CAAC;;EAG5D,MAAMG,iBAAiB,GAAGjH,OAAO,CAACkH,UAAU,CAAC,KAAK,CAAC;EAEnD;EACA5F,OAAO,CAACN,OAAA,CAAAY,iBAAiB,CAAC,GAAGmF,OAAO;EAEpC;EACAI,kBAAkB,CAChBJ,OAAO,CAACK,OAAO,CAACnC,YAAY,EAC5B8B,OAAO,CAACG,UAAU,CAACG,QAAQ,EAC3BN,OAAO,EACPE,iBAAiB,CAClB;EAED,IAAAxG,mBAAA,CAAA6G,sCAAsC,EAACP,OAAO,CAAC;EAE/C;EACC9G,QAAA,CAAAsH,MAAyC,CAACC,eAAe,CACxDT,OAAO,CAACK,OAAO,CAACpH,OAAO,CACxB;EAED,OAAO+G,OAAO;AAChB;AA/BA/F,OAAA,CAAA6F,QAAA,GAAAA,QAAA;AAiCA;;;;;AAKA,SAAgBG,MAAMA,CAACS,UAAA,GAA4B,EAAE;EACnD,MAAMC,iBAAiB,GAAG,IAAApH,eAAA,CAAAqH,iBAAiB,EAACF,UAAU,CAAC;EACvD,OAAOG,yBAAyB,CAACF,iBAAiB,CAAC;AACrD;AAHA1G,OAAA,CAAAgG,MAAA,GAAAA,MAAA;AAKA;AACA,SAAgBY,yBAAyBA,CACvCF,iBAAuD;;EAEvD,MAAM;IACJG,cAAc;IACdvE,GAAG;IACH8D,OAAO;IACPU,MAAM;IACN1D,QAAQ;IACR2D,sBAAsB;IACtBC;EAAe,CAChB,GAAGN,iBAAiB;EAErB,MAAMO,yBAAyB,GAAG,IAAA5H,MAAA,CAAA6H,+BAA+B,EAC/DH,sBAAsB,CACvB;EAED,MAAMI,EAAE,GAAG,IAAA7H,eAAA,CAAA8H,YAAY,EAAChE,QAAQ,CAAC;EAEjC;EACA,MAAMiE,iBAAiB,GAAGP,MAAM,CAACV,OAAO,CAACkB,MAAO,IAAIH,EAAE,CAACI,YAAY,CAACC,MAAM;EAC1E,IAAIpB,OAAO,CAACvB,qBAAqB,KAAK,IAAI,IAAI,CAACwC,iBAAiB,EAAE;IAChE,MAAM,IAAII,KAAK,CACb,0EAA0E,CAC3E;;EAEH;EACA,MAAMC,oBAAoB,GAAG,IAAArI,MAAA,CAAAsI,YAAY,EAACR,EAAE,CAAC/E,OAAO,EAAE,OAAO,CAAC;EAC9D,IAAIgE,OAAO,CAACvB,qBAAqB,KAAK,IAAI,IAAI,CAAC6C,oBAAoB,EAAE;IACnE,MAAM,IAAID,KAAK,CACb,mFAAmF,CACpF;;EAGH,MAAMG,eAAe,GACnBxB,OAAO,CAACvB,qBAAqB,KAAK,KAAK,IACvC6C,oBAAoB,IACpBL,iBAAiB;EAEnB;EACA;EACA;EACA,IAAIjB,OAAO,CAACyB,GAAG,IAAI,CAACzB,OAAO,CAAC7B,SAAS,EAAE;IACrC,IAAI6B,OAAO,CAAC/B,aAAa,KAAK,KAAK,EAAE;MACnC,MAAM,IAAIoD,KAAK,CACb,yFAAyF,CAC1F;;IAEH,IAAIrB,OAAO,CAAC0B,UAAU,EAAE;MACtB,MAAM,IAAIL,KAAK,CACb,8FAA8F,CAC/F;;;EAIL,MAAMM,QAAQ,GAAG3B,OAAO,CAAC2B,QAAQ,IAAIZ,EAAE,CAACa,GAAG,CAACD,QAAQ;EACpD,MAAME,UAAU,GAAG7B,OAAO,CAAC6B,UAAU,IAAId,EAAE,CAACa,GAAG,CAACC,UAAU;EAC1D;EACA,MAAM5D,aAAa,GACjB,CAAC+B,OAAO,CAAC/B,aAAa,KAAK,IAAI,IAAI+B,OAAO,CAACyB,GAAG,KAAK,IAAI,KACvDzB,OAAO,CAAC7B,SAAS,KAAK,IAAI;EAC5B,IAAIuD,UAAU,GAA8ClG,SAAS;EACrE,IAAIsG,kBAAkB,GAAuBtG,SAAS;EACtD,IAAIwE,OAAO,CAAC0B,UAAU,EAAE;IACtBA,UAAU,GAAG1B,OAAO,CAAC0B,UAAU;IAC/BI,kBAAkB,GAAGlB,eAAe,CAACc,UAAU;GAChD,MAAM,IAAI1B,OAAO,CAACyB,GAAG,EAAE;IACtBC,UAAU,GAAG9I,OAAO,CAACmJ,OAAO,CAAC,sBAAsB,CAAC;IACpDD,kBAAkB,GAAGlB,eAAe,CAACa,GAAG;;EAE1C,MAAMO,YAAY,GAAGhC,OAAO,CAACgC,YAAY,IAAIxG,SAAS;EACtD,MAAMyG,iBAAiB,GAA4B,CACjD;IACEC,iBAAiB,EAAE,IAAI;IACvBC,iBAAiB,EAAE,EAAE;IACrBC,kBAAkB,EAAE,CAClB,IAAI,EACJ,KAAK,EACL,KAAK,EACL,IAAIpC,OAAO,CAACqC,8BAA8B,GACtC,CACE,IAAI,CAAE;IAAA,CACP,GACD,EAAE,CAAC,EACP,IAAIrC,OAAO,CAACjC,iBAAiB,IAAI,EAAE,CAAC,CACrC,CAACuE,GAAG,CAACC,MAAM;GACb,CACF;EAED,MAAMC,oBAAoB,GAAGC,iBAAiB,CAC5C/B,MAAM,CAACgC,MAAM,EACbT,iBAAiB,CAClB;EACD,MAAMU,WAAW,GAAG,IAAIC,GAAG,EAKxB;EAEH,MAAMC,iBAAiB,GAAGpC,cAAc,GAAG,IAAA9H,MAAA,CAAAmK,OAAO,EAACrC,cAAc,CAAC,GAAG,IAAI;EACzE,MAAM/D,QAAQ,GACZ,CAAAqG,EAAA,IAAArE,EAAA,IAAAvC,EAAA,GAAA6D,OAAO,CAACtD,QAAQ,cAAAP,EAAA,cAAAA,EAAA,GAAIuE,MAAM,CAACV,OAAO,CAACgD,OAAO,cAAAtE,EAAA,cAAAA,EAAA,GAAImE,iBAAiB,cAAAE,EAAA,cAAAA,EAAA,GAAI7G,GAAG;EACxE,MAAM+G,aAAa,GAAGJ,iBAAiB,aAAjBA,iBAAiB,cAAjBA,iBAAiB,GAAI3G,GAAG;EAC9C,MAAMgH,QAAQ,GAAGlD,OAAO,CAACxD,KAAK,GACzB2G,QAAgB,IAAK,IAAAxK,MAAA,CAAAyK,QAAQ,EAAC1G,QAAQ,EAAEyG,QAAQ,CAAC,CAACE,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,GACpE,MAAM,IAAI;EACd,MAAMC,YAAY,GAAGC,YAAY,CAC/BN,aAAa,EACbjD,OAAO,CAACrC,UAAU,GACd,EAAE,GACF,CAACqC,OAAO,CAAC3C,MAAM,IAAI,CAAC,sBAAsB,CAAC,EAAEiF,GAAG,CAC7CkB,GAAG,IAAK,IAAIC,MAAM,CAACD,GAAG,CAAC,CACzB,CACN;EAED,MAAME,cAAc,GAA8B;IAChDC,UAAU,EAAEA,CAAA,KAAM5C,EAAE,CAACa,GAAG,CAACgC,OAAO;IAChCC,mBAAmB,EAAEA,CAAA,KAAM3H,GAAG;IAC9B;IACA4H,oBAAoB,EAAE/C,EAAE,CAACa,GAAG,CAACmC,yBAAyB,GACjDlI,CAAC,IAAKA,CAAC,GACPA,CAAC,IAAKA,CAAC,CAACmI,WAAW;GACzB;EAED,IAAIhE,OAAO,CAAC/B,aAAa,IAAI,OAAO+D,YAAY,KAAK,UAAU,EAAE;IAC/D,MAAM,IAAIiC,SAAS,CACjB,4DAA4D,CAC7D;;EAEH,IAAIC,gBAAgB,GAAGC,2BAA2B,EAAE;EACpD,SAASA,2BAA2BA,CAAA;;IAClC,IAAIzC,UAAU,EAAE;MACd,IAAI,CAACzD,aAAa,EAChB,MAAM,IAAIoD,KAAK,CACb,mEAAmE,CACpE;MACH,MAAM+C,cAAc,GAClB,OAAO1C,UAAU,KAAK,QAAQ,GAAGA,UAAU,GAAGA,UAAU,CAAC,CAAC,CAAC;MAC7D,MAAM2C,iBAAiB,GACrB,OAAO3C,UAAU,KAAK,QAAQ,GAAG,EAAE,GAAG,CAAAvF,EAAA,GAAAuF,UAAU,CAAC,CAAC,CAAC,cAAAvF,EAAA,cAAAA,EAAA,GAAI,EAAE;MAC3D,MAAMmI,kCAAkC,GAAGxC,kBAAkB,GACzD,IAAA7I,MAAA,CAAA6H,+BAA+B,EAACgB,kBAAkB,CAAC,GACnDjB,yBAAyB;MAC7B,MAAM0D,cAAc,GAAGD,kCAAkC,CACvDF,cAAc,EACd,IAAI,CACL;MACD,MAAMI,iBAAiB,GAAG5L,OAAO,CAAC2L,cAAc,CAAC,CAC9C3E,MAA2B;MAC9B,OAAOsE,gBAAgB;MAEvB,SAASA,gBAAgBA,CACvBhH,eAAyC,EACzCuH,kBAAuC;QAEvC,OAAOD,iBAAiB,aAAjBA,iBAAiB,uBAAjBA,iBAAiB,CAAG;UACzB7E,OAAO,EAAE;YACPK,OAAO;YACPU,MAAM,EAAE;cACN,GAAGA,MAAM;cACTV,OAAO,EAAE9C;aACV;YACD2D;WACD;UACDyD,kCAAkC;UAClCG,kBAAkB;UAClB,GAAGJ;SACJ,CAAC;MACJ;;EAEJ;EAEA;;;;EAIA,IAAIK,qBAAqB,GAAG,KAAK;EACjC,SAASC,kCAAkCA,CAAA;IACzCD,qBAAqB,GAAG,IAAI;EAC9B;EAEA;EACAE,uBAAuB,EAAE;EACzB,SAASA,uBAAuBA,CAAA;IAC9B,MAAMC,gBAAgB,GACpBjM,OAAO,CAAC,+BAA+B,CAA6B;IACtEiM,gBAAgB,CAACC,OAAO,CAAC;MACvBC,WAAW,EAAE,MAAM;MACnBC,YAAYA,CAACC,SAAiB;;QAC5B,IAAIC,IAAI,GAAGD,SAAS;QACpB;QACA;QACA;QACA,IAAIP,qBAAqB,IAAIQ,IAAI,CAACC,UAAU,CAAC,SAAS,CAAC,EAAE;UACvD,IAAI;YACFD,IAAI,GAAG,IAAAnM,KAAA,CAAAqM,aAAa,EAACF,IAAI,CAAC;WAC3B,CAAC,OAAOG,CAAC,EAAE;YACV;UAAA;;QAGJH,IAAI,GAAG,IAAAjM,MAAA,CAAAqM,gBAAgB,EAACJ,IAAI,CAAC;QAC7B,OAAO,EAAA/I,EAAA,GAAAwG,WAAW,CAAC7I,GAAG,CAACoL,IAAI,CAAC,cAAA/I,EAAA,uBAAAA,EAAA,CAAEoJ,OAAO,KAAI,EAAE;MAC7C,CAAC;MACDC,0BAA0B,EAAE,IAAI;MAChCC,4BAA4BA,CAC1BC,OAAO,EACPC,MAAM,EACNC,MAAM,EACN5F,OAAO,EACP6F,iBAAiB;QAEjB,IAAAjM,OAAA,CAAAsB,KAAK,EACH,2GACGyK,MAAwB,CAACG,QAC5B,sCAAsCJ,OAAO,4BAA4BG,iBAAiB,IAAI,CAC/F;MACH;KACD,CAAC;EACJ;EAEA,MAAME,sBAAsB,GAC1B/F,OAAO,CAAClD,MAAM,KAAKtB,SAAS,GAAGtB,OAAO,CAAC8L,MAAM,CAACC,KAAK,GAAGjG,OAAO,CAAClD,MAAM;EAEtE,MAAMoJ,iBAAiB,GAAGH,sBAAsB,GAC5ChF,EAAE,CAACoF,oCAAoC,IAAIpF,EAAE,CAACmF,iBAAiB,GAC/DnF,EAAE,CAACmF,iBAAiB;EAExB,SAASE,aAAaA,CAACjH,WAA0C;IAC/D,MAAMF,cAAc,GAAGiH,iBAAiB,CAAC/G,WAAW,EAAEuE,cAAc,CAAC;IACrE,MAAMxE,eAAe,GAAGC,WAAW,CAACmD,GAAG,CAAEzG,CAAC,IAAKA,CAAC,CAACwK,IAAI,CAAC;IACtD,OAAO,IAAIvH,OAAO,CAACG,cAAc,EAAEC,eAAe,EAAEC,WAAW,CAAC;EAClE;EAEA,SAASmH,aAAaA,CAAC9D,oBAAsC;IAC3D,MAAM+D,KAAK,GAAGH,aAAa,CAAC5D,oBAAoB,CAAC;IACjD,IAAIxC,OAAO,CAACzB,QAAQ,EAAE;MACpB;MACAnD,OAAO,CAACmL,KAAK,CAAC,mBAAmB,EAAEA,KAAK,CAAC;KAC1C,MAAM;MACL;MACA,MAAMA,KAAK;;EAEf;EAEA;EACA,IAAI/D,oBAAoB,CAACgE,MAAM,EAAEF,aAAa,CAAC9D,oBAAoB,CAAC;EAEpE,MAAMiE,eAAe,GAAG/F,MAAM,CAACV,OAAO,CAAC0G,GAAG,KAAK3F,EAAE,CAAC4F,OAAO,CAACC,QAAQ;EAClE;;;;EAIA,SAASC,gBAAgBA,CAAC3B,IAAY;IACpC,MAAM4B,YAAY,GAAG5B,IAAI,CAAC6B,WAAW,CAAC,GAAG,CAAC;IAC1C,IAAID,YAAY,IAAI,CAAC,EAAE;MACrB,MAAME,GAAG,GAAG9B,IAAI,CAAC+B,KAAK,CAACH,YAAY,CAAC;MACpC,QAAQE,GAAG;QACT,KAAK,KAAK;QACV,KAAK,KAAK;UACR,OAAO,KAAK;QACd,KAAK,MAAM;QACX,KAAK,MAAM;UACT,OAAOP,eAAe,GAAG,MAAM,GAAG,KAAK;QACzC,KAAK,MAAM;QACX,KAAK,MAAM;UACT,OAAO,MAAM;QACf,KAAK,MAAM;QACX,KAAK,MAAM;UACT,OAAO,MAAM;;;IAGnB,OAAO,KAAK;EACd;EAGA;;;;EAIA,IAAIS,SAAwC;EAC5C,IAAIC,WAIS;EAEb,MAAMrD,oBAAoB,GACxB/C,EACD,CAACqG,0BAA0B,CAACrG,EAAE,CAACa,GAAG,CAACmC,yBAAyB,CAAC;EAE9D,MAAMsD,oBAAoB,GAAG,IAAAlO,wBAAA,CAAAmO,0BAA0B,EAAC;IACtDC,QAAQ,EAAE,CAAAC,EAAA,GAAAxH,OAAO,CAACY,eAAe,cAAA4G,EAAA,uBAAAA,EAAA,CAAEC,WAAW;IAC9CC,QAAQ,EAAE1H,OAAO,CAACyH;GACnB,CAAC;EAEF,MAAM3H,UAAU,GAAG,IAAAvG,iBAAA,CAAAoO,aAAa,EAACjH,MAAM,EAAEV,OAAO,EAAEe,EAAE,CAAC/E,OAAO,CAAC;EAE7D;EACA,IAAI,CAACiC,aAAa,EAAE;IAClB,MAAM2J,YAAY,GAAG,IAAIhF,GAAG,EAAkB;IAC9C,MAAMiF,aAAa,GAAG,IAAIC,GAAG,CAACpH,MAAM,CAACqH,SAAS,CAAC;IAC/C,MAAMC,cAAc,GAAG,IAAA/O,MAAA,CAAAgP,YAAY,EAACxM,OAAO,CAAC,UAAU,EAAEkG,QAAQ,CAAC,CAAC;IAElE;IACA,IAAI,CAAC3B,OAAO,CAAC3B,YAAY,EAAE;MACzB,IAAI6J,cAAc,GAAG,CAAC;MACtB,MAAMC,YAAY,GAAG,IAAIvF,GAAG,CAC1BwF,KAAK,CAACC,IAAI,CAACR,aAAa,CAAC,CAACvF,GAAG,CAAEa,QAAQ,IAAK,CAACA,QAAQ,EAAE,CAAC,CAAC,CAAC,CAC3D;MAED,MAAMmF,qBAAqB,GAAGA,CAAA,KAAK;QACjC,IAAI,OAAOtG,YAAY,KAAK,UAAU,EAAE;UACtC,MAAMuG,OAAO,GAAG5I,OAAO,CAAC6I,UAAU,EAAE;UACpC,OAAOD,OAAO,GAAGvG,YAAY,CAACuG,OAAO,CAAC,GAAG/M,SAAS;;QAGpD,OAAOwG,YAAY;MACrB,CAAC;MAED;MACA,MAAMyG,WAAW,GACsD;QACrEC,iBAAiB,EAAEA,CAAA,KAAMC,MAAM,CAACT,cAAc,CAAC;QAC/CU,kBAAkB,EAAEA,CAAA,KAAMR,KAAK,CAACC,IAAI,CAACR,aAAa,CAAC;QACnDgB,gBAAgB,EAAG1F,QAAgB,IAAI;UACrC,MAAMnH,OAAO,GAAGmM,YAAY,CAACrO,GAAG,CAACqJ,QAAQ,CAAC;UAC1C,OAAOnH,OAAO,GAAGA,OAAO,CAAC8M,QAAQ,EAAE,GAAG,EAAE;QAC1C,CAAC;QACDC,iBAAiBA,CAAC5F,QAAgB;UAChC;UACA,IAAI6F,QAAQ,GAAGpB,YAAY,CAAC9N,GAAG,CAACqJ,QAAQ,CAAC;UAEzC;UACA,IAAI6F,QAAQ,KAAKxN,SAAS,EAAE;YAC1BwN,QAAQ,GAAGhB,cAAc,CAAC7E,QAAQ,CAAC;YACnC,IAAI6F,QAAQ,KAAKxN,SAAS,EAAE;YAE5B2M,YAAY,CAACc,GAAG,CAAC9F,QAAQ,EAAE,CAAC,CAAC;YAC7ByE,YAAY,CAACqB,GAAG,CAAC9F,QAAQ,EAAE6F,QAAQ,CAAC;YACpCd,cAAc,EAAE;;UAGlB,OAAOnH,EAAE,CAACmI,cAAc,CAACC,UAAU,CAACH,QAAQ,CAAC;QAC/C,CAAC;QACDrH,QAAQ,EAAEqG,cAAc;QACxBoB,aAAa,EAAErI,EAAE,CAACa,GAAG,CAACwH,aAAa;QACnCC,cAAc,EAAE,IAAApQ,MAAA,CAAAgP,YAAY,EAC1BxM,OAAO,CAAC,gBAAgB,EAAEsF,EAAE,CAACa,GAAG,CAACyH,cAAc,CAAC,CACjD;QACDxH,UAAU,EAAE,IAAA5I,MAAA,CAAAgP,YAAY,EAACxM,OAAO,CAAC,YAAY,EAAEoG,UAAU,CAAC,CAAC;QAC3DyH,eAAe,EAAE,IAAArQ,MAAA,CAAAgP,YAAY,EAC3BxM,OAAO,CAAC,iBAAiB,EAAEsF,EAAE,CAACa,GAAG,CAAC0H,eAAe,CAAC,CACnD;QACDC,QAAQ,EAAExI,EAAE,CAACa,GAAG,CAAC2H,QAAQ,GACrB,IAAAtQ,MAAA,CAAAgP,YAAY,EAACxM,OAAO,CAAC,UAAU,EAAEsF,EAAE,CAACa,GAAG,CAAC2H,QAAQ,CAAC,CAAC,GAClD/N,SAAS;QACbmI,UAAU,EAAEA,CAAA,KAAM5C,EAAE,CAACa,GAAG,CAACgC,OAAO;QAChCG,yBAAyB,EAAEA,CAAA,KAAMhD,EAAE,CAACa,GAAG,CAACmC,yBAAyB;QACjEF,mBAAmB,EAAEA,CAAA,KAAM3H,GAAG;QAC9BsN,sBAAsB,EAAEA,CAAA,KAAM9I,MAAM,CAACV,OAAO;QAC5CyJ,qBAAqB,EAAEA,CAAA,KAAM1I,EAAE,CAAC2I,qBAAqB,CAAChJ,MAAM,CAACV,OAAO,CAAC;QACrEsI,qBAAqB,EAAEA,qBAAqB;QAC5CqB,KAAK,EAAE3J,OAAO,CAACpB;OAChB;MACD,MAAM;QACJgL,kBAAkB;QAClBC,mDAAmD;QACnDC,8BAA8B;QAC9BC,uBAAuB;QACvBC;MAA4B,CAC7B,GAAG,IAAA5Q,oBAAA,CAAA6Q,uBAAuB,EAAC;QAC1BC,IAAI,EAAEzB,WAAW;QACjB3E,oBAAoB;QACpB/C,EAAE;QACF7E,GAAG;QACHwE,MAAM;QACNG,yBAAyB;QACzBb,OAAO;QACPF;OACD,CAAC;MACF2I,WAAW,CAACmB,kBAAkB,GAAGA,kBAAkB;MACnDnB,WAAW,CAACoB,mDAAmD,GAC7DA,mDAAmD;MACrDpB,WAAW,CAACqB,8BAA8B,GACxCA,8BAA8B;MAEhC,MAAMK,QAAQ,GAAGpJ,EAAE,CAACqJ,sBAAsB,CACxCrJ,EAAE,CAACa,GAAG,CAACmC,yBAAyB,EAChC7H,GAAG,CACJ;MACD,MAAMyD,OAAO,GAAGoB,EAAE,CAACsJ,qBAAqB,CAAC5B,WAAW,EAAE0B,QAAQ,CAAC;MAE/D,MAAMG,iBAAiB,GAAGA,CAACtB,QAAgB,EAAE7F,QAAgB,KAAI;QAC/D;QACA;QACA,IACE,CAAC0E,aAAa,CAAC0C,GAAG,CAACpH,QAAQ,CAAC,IAC5B,CAAC4G,uBAAuB,CAAC5G,QAAQ,CAAC,EAClC;UACA6G,4BAA4B,CAAC7G,QAAQ,CAAC;UACtC0E,aAAa,CAAC2C,GAAG,CAACrH,QAAQ,CAAC;UAC3B;UACA+E,cAAc,EAAE;;QAGlB,MAAMuC,eAAe,GAAGtC,YAAY,CAACrO,GAAG,CAACqJ,QAAQ,CAAC,IAAI,CAAC;QACvD,MAAMuH,gBAAgB,GAAG9C,YAAY,CAAC9N,GAAG,CAACqJ,QAAQ,CAAC;QACnD;QACA,IAAI6F,QAAQ,KAAK0B,gBAAgB,EAAE;UACjCvC,YAAY,CAACc,GAAG,CAAC9F,QAAQ,EAAEsH,eAAe,GAAG,CAAC,CAAC;UAC/C7C,YAAY,CAACqB,GAAG,CAAC9F,QAAQ,EAAE6F,QAAQ,CAAC;UACpC;UACAd,cAAc,EAAE;;MAEpB,CAAC;MAED,IAAIyC,eAAe,GAA4BnP,SAAS;MAExD0L,SAAS,GAAGA,CAACb,IAAY,EAAElD,QAAgB,KAAI;QAC7CmH,iBAAiB,CAACjE,IAAI,EAAElD,QAAQ,CAAC;QAEjC,MAAMyH,aAAa,GAAGjL,OAAO,CAAC6I,UAAU,EAAE;QAC1C,IAAIoC,aAAa,KAAKD,eAAe,EAAE;UACrC,IAAA/Q,OAAA,CAAAsB,KAAK,EACH,6DAA6DiI,QAAQ,EAAE,CACxE;;QAGH,MAAM0H,MAAM,GAAGlL,OAAO,CAACmL,aAAa,CAAC3H,QAAQ,CAAC;QAE9C;QACA,MAAMhE,WAAW,GAAGQ,OAAO,CACxBoL,sBAAsB,CAAC5H,QAAQ,CAAC,CAChC6H,MAAM,CAACrL,OAAO,CAACsL,uBAAuB,CAAC9H,QAAQ,CAAC,CAAC;QAEpD,MAAM+H,YAAY,GAAGvL,OAAO,CAAC6I,UAAU,EAAE;QAEzC,IAAA5O,OAAA,CAAAsB,KAAK,EACH,6HAA6H,EAC7H0P,aAAa,KAAKM,YAAY,CAC/B;QAEDP,eAAe,GAAGO,YAAY;QAE9B,MAAMC,cAAc,GAAG1I,iBAAiB,CACtCtD,WAAW,EACX8C,iBAAiB,CAClB;QACD,IAAIkJ,cAAc,CAAC3E,MAAM,EAAEF,aAAa,CAAC6E,cAAc,CAAC;QAExD,IAAIN,MAAM,CAACO,WAAW,EAAE;UACtB,OAAO,CAAC5P,SAAS,EAAEA,SAAS,EAAE,IAAI,CAAC;;QAGrC;QACA,IAAIqP,MAAM,CAACQ,WAAW,CAAC7E,MAAM,KAAK,CAAC,EAAE;UACnC,MAAM,IAAIvC,SAAS,CACjB,2BAA2B,IAAAtL,MAAA,CAAAyK,QAAQ,EAAClH,GAAG,EAAEiH,QAAQ,CAAC,IAAI,GACpD,kEAAkE,GAClE,yEAAyE,GACzE,6CAA6C,CAChD;;QAGH,OAAO,CAAC0H,MAAM,CAACQ,WAAW,CAAC,CAAC,CAAC,CAACC,IAAI,EAAET,MAAM,CAACQ,WAAW,CAAC,CAAC,CAAC,CAACC,IAAI,EAAE,KAAK,CAAC;MACxE,CAAC;MAEDnE,WAAW,GAAGA,CAACd,IAAY,EAAElD,QAAgB,EAAEoI,QAAgB,KAAI;QACjE,MAAMC,kBAAkB,GAAG,IAAAvS,MAAA,CAAAqM,gBAAgB,EAACnC,QAAQ,CAAC;QACrDmH,iBAAiB,CAACjE,IAAI,EAAEmF,kBAAkB,CAAC;QAE3C,MAAMC,IAAI,GAAG9L,OAAO,CAAC+L,sBAAsB,CACzCF,kBAAkB,EAClBD,QAAQ,CACT;QACD,MAAMnM,IAAI,GAAG2B,EAAE,CAAC4K,oBAAoB,CAACF,IAAI,GAAGA,IAAI,CAACG,YAAY,GAAG,EAAE,CAAC;QACnE,MAAMC,OAAO,GAAG9K,EAAE,CAAC4K,oBAAoB,CAACF,IAAI,GAAGA,IAAI,CAACK,aAAa,GAAG,EAAE,CAAC;QAEvE,OAAO;UAAE1M,IAAI;UAAEyM;QAAO,CAAE;MAC1B,CAAC;KACF,MAAM;MACL,MAAMjK,GAAG,GAA2C;QAClD,GAAGb,EAAE,CAACa,GAAG;QACT,GAAG8B,cAAc;QACjB/B,QAAQ,EAAGwB,QAAgB,IAAI;UAC7B,MAAM4I,aAAa,GAAGnE,YAAY,CAAC9N,GAAG,CAACqJ,QAAQ,CAAC;UAChD,IAAI4I,aAAa,KAAKvQ,SAAS,EAAE,OAAOuQ,aAAa;UACrD,MAAM/C,QAAQ,GAAGhB,cAAc,CAAC7E,QAAQ,CAAC;UACzC,IAAI6F,QAAQ,EAAEpB,YAAY,CAACqB,GAAG,CAAC9F,QAAQ,EAAE6F,QAAQ,CAAC;UAClD,OAAOA,QAAQ;QACjB,CAAC;QACDI,aAAa,EAAErI,EAAE,CAACa,GAAG,CAACwH,aAAa;QACnCC,cAAc,EAAE,IAAApQ,MAAA,CAAAgP,YAAY,EAC1BxM,OAAO,CAAC,gBAAgB,EAAEsF,EAAE,CAACa,GAAG,CAACyH,cAAc,CAAC,CACjD;QACDxH,UAAU,EAAE,IAAA5I,MAAA,CAAAgP,YAAY,EAACxM,OAAO,CAAC,YAAY,EAAEoG,UAAU,CAAC,CAAC;QAC3DyH,eAAe,EAAE,IAAArQ,MAAA,CAAAgP,YAAY,EAC3BxM,OAAO,CAAC,iBAAiB,EAAEsF,EAAE,CAACa,GAAG,CAAC0H,eAAe,CAAC,CACnD;QACD0C,WAAW,EAAE,IAAA/S,MAAA,CAAAgP,YAAY,EAACxM,OAAO,CAAC,aAAa,EAAEsF,EAAE,CAACa,GAAG,CAACoK,WAAW,CAAC,CAAC;QACrEzC,QAAQ,EAAExI,EAAE,CAACa,GAAG,CAAC2H,QAAQ,GACrB,IAAAtQ,MAAA,CAAAgP,YAAY,EAACxM,OAAO,CAAC,UAAU,EAAEsF,EAAE,CAACa,GAAG,CAAC2H,QAAQ,CAAC,CAAC,GAClD/N;OACL;MAED,MAAM0O,IAAI,GAAqBnJ,EAAE,CAACkL,6BAA6B,GAC3DlL,EAAE,CAACkL,6BAA6B,CAACvL,MAAM,CAACV,OAAO,EAAE4B,GAAG,CAAC,GACrD;QACE,GAAGA,GAAG;QACNsK,aAAa,EAAEA,CAAC/I,QAAQ,EAAEgJ,eAAe,KAAI;UAC3C,MAAMnD,QAAQ,GAAGpH,GAAG,CAACD,QAAQ,CAACwB,QAAQ,CAAC;UACvC,IAAI6F,QAAQ,KAAKxN,SAAS,EAAE;UAC5B,OAAOuF,EAAE,CAACqL,gBAAgB,CAACjJ,QAAQ,EAAE6F,QAAQ,EAAEmD,eAAe,CAAC;QACjE,CAAC;QACDE,qBAAqB,EAAEA,CAAA,KAAM,IAAApT,MAAA,CAAAqM,gBAAgB,EAAC,IAAA3M,MAAA,CAAAmK,OAAO,EAAC9F,QAAQ,CAAC,CAAC;QAChEyM,qBAAqB,EAAEA,CAAA,KACrB,IAAAxQ,MAAA,CAAAqM,gBAAgB,EACd,IAAA3M,MAAA,CAAA2T,IAAI,EACF,IAAA3T,MAAA,CAAAmK,OAAO,EAAC9F,QAAQ,CAAC,EACjB+D,EAAE,CAAC0I,qBAAqB,CAAC/I,MAAM,CAACV,OAAO,CAAC,CACzC,CACF;QACH+D,yBAAyB,EAAEA,CAAA,KAAMnC,GAAG,CAACmC;OACtC;MACLmG,IAAI,CAACP,KAAK,GAAG3J,OAAO,CAACpB,OAAO;MAC5B,MAAM;QACJgL,kBAAkB;QAClBE,8BAA8B;QAC9BC,uBAAuB;QACvBC;MAA4B,CAC7B,GAAG,IAAA5Q,oBAAA,CAAA6Q,uBAAuB,EAAC;QAC1BC,IAAI;QACJhO,GAAG;QACHwE,MAAM;QACNK,EAAE;QACF+C,oBAAoB;QACpBjD,yBAAyB;QACzBb,OAAO;QACPF;OACD,CAAC;MACFoK,IAAI,CAACN,kBAAkB,GAAGA,kBAAkB;MAC5CM,IAAI,CAACJ,8BAA8B,GAAGA,8BAA8B;MAEpE;MACA,IAAIyC,cAAc,GAAGxL,EAAE,CAACyL,wBAAwB,GAC5CzL,EAAE,CAACyL,wBAAwB,CAAC;QAC1BC,SAAS,EAAErE,KAAK,CAACC,IAAI,CAACR,aAAa,CAAC;QACpC7H,OAAO,EAAEU,MAAM,CAACV,OAAO;QACvBkK,IAAI;QACJwC,4BAA4B,EAAEhM,MAAM,CAACgC,MAAM;QAC3CiK,iBAAiB,EAAEjM,MAAM,CAACiM;OAC3B,CAAC,GACF5L,EAAE,CAAC6L,8CAA8C,CAC/CxE,KAAK,CAACC,IAAI,CAACR,aAAa,CAAC,EACzBnH,MAAM,CAACV,OAAO,EACdkK,IAAI,EACJ1O,SAAS,EACTkF,MAAM,CAACgC,MAAM,EACbhC,MAAM,CAACiM,iBAAiB,CACzB;MAEL;MACA,MAAME,kBAAkB,GACtB,OAAO7K,YAAY,KAAK,UAAU,GAC9BA,YAAY,CAACuK,cAAc,CAAC/D,UAAU,EAAE,CAAC,GACzCxG,YAAY;MAElB;MACA,MAAMsI,iBAAiB,GAAGA,CAACtB,QAAgB,EAAE7F,QAAgB,KAAI;QAC/D,MAAMuH,gBAAgB,GAAG9C,YAAY,CAAC9N,GAAG,CAACqJ,QAAQ,CAAC;QACnD,MAAM2J,eAAe,GAAGpC,gBAAgB,KAAK1B,QAAQ;QACrD,IAAI8D,eAAe,EAAE;UACnBlF,YAAY,CAACqB,GAAG,CAAC9F,QAAQ,EAAE6F,QAAQ,CAAC;;QAGtC;QACA,IAAI+D,oBAAoB,GAAG,KAAK;QAChC,IACE,CAAClF,aAAa,CAAC0C,GAAG,CAACpH,QAAQ,CAAC,IAC5B,CAAC4G,uBAAuB,CAAC5G,QAAQ,CAAC,EAClC;UACA6G,4BAA4B,CAAC7G,QAAQ,CAAC;UACtC0E,aAAa,CAAC2C,GAAG,CAACrH,QAAQ,CAAC;UAC3B4J,oBAAoB,GAAG,IAAI;;QAG7B;QACA,IAAIA,oBAAoB,IAAID,eAAe,EAAE;UAC3CP,cAAc,GAAGxL,EAAE,CAAC6L,8CAA8C,CAChExE,KAAK,CAACC,IAAI,CAACR,aAAa,CAAC,EACzBnH,MAAM,CAACV,OAAO,EACdkK,IAAI,EACJqC,cAAc,EACd7L,MAAM,CAACgC,MAAM,EACbhC,MAAM,CAACiM,iBAAiB,CACzB;;MAEL,CAAC;MAEDzF,SAAS,GAAGA,CAACb,IAAY,EAAElD,QAAgB,KAAI;QAC7C,IAAI6J,OAAO,GAAG,EAAE;QAChB,IAAIC,MAAM,GAAG,EAAE;QAEf3C,iBAAiB,CAACjE,IAAI,EAAElD,QAAQ,CAAC;QAEjC,MAAM+J,UAAU,GAAGX,cAAc,CAACL,aAAa,CAAC/I,QAAQ,CAAC;QACzD,IAAI,CAAC+J,UAAU,EACb,MAAM,IAAIjJ,SAAS,CAAC,wBAAwBd,QAAQ,EAAE,CAAC;QAEzD,MAAMoF,OAAO,GAAGgE,cAAc,CAAC/D,UAAU,EAAE;QAC3C,MAAMrJ,WAAW,GAAG4B,EAAE,CAACoM,qBAAqB,CAAC5E,OAAO,EAAE2E,UAAU,CAAC;QACjE,MAAM/B,cAAc,GAAG1I,iBAAiB,CACtCtD,WAAW,EACX8C,iBAAiB,CAClB;QACD,IAAIkJ,cAAc,CAAC3E,MAAM,EAAEF,aAAa,CAAC6E,cAAc,CAAC;QAExD,MAAMiC,MAAM,GAAGb,cAAc,CAACjQ,IAAI,CAChC4Q,UAAU,EACV,CAAChI,IAAI,EAAEmI,IAAI,EAAEC,kBAAkB,KAAI;UACjC,IAAIpI,IAAI,CAACqI,QAAQ,CAAC,MAAM,CAAC,EAAE;YACzBN,MAAM,GAAGI,IAAI;WACd,MAAM;YACLL,OAAO,GAAGK,IAAI;;UAGhB,IAAIrN,OAAO,CAAC1D,IAAI,EAAEsF,GAAG,CAAC4L,SAAS,CAACtI,IAAI,EAAEmI,IAAI,EAAEC,kBAAkB,CAAC;QACjE,CAAC,EACD9R,SAAS,EACTA,SAAS,EACTqR,kBAAkB,CACnB;QAED,IAAIO,MAAM,CAAChC,WAAW,EAAE;UACtB,OAAO,CAAC5P,SAAS,EAAEA,SAAS,EAAE,IAAI,CAAC;;QAGrC;QACA,IAAIwR,OAAO,KAAK,EAAE,EAAE;UAClB,IAAIzE,OAAO,CAACkF,+BAA+B,CAACP,UAAU,CAAC,EAAE;YACvD,MAAM,IAAIjJ,SAAS,CACjB,iDAAiD,IAAAtL,MAAA,CAAAyK,QAAQ,EACvDlH,GAAG,EACHiH,QAAQ,CACT,EAAE,CACJ;;UAGH,MAAM,IAAIc,SAAS,CACjB,2BAA2B,IAAAtL,MAAA,CAAAyK,QAAQ,EAAClH,GAAG,EAAEiH,QAAQ,CAAC,IAAI,GACpD,kEAAkE,GAClE,yEAAyE,GACzE,6CAA6C,CAChD;;QAGH,OAAO,CAAC6J,OAAO,EAAEC,MAAM,EAAE,KAAK,CAAC;MACjC,CAAC;MAED9F,WAAW,GAAGA,CAACd,IAAY,EAAElD,QAAgB,EAAEoI,QAAgB,KAAI;QACjE,MAAMC,kBAAkB,GAAG,IAAAvS,MAAA,CAAAqM,gBAAgB,EAACnC,QAAQ,CAAC;QACrDmH,iBAAiB,CAACjE,IAAI,EAAEmF,kBAAkB,CAAC;QAE3C,MAAM0B,UAAU,GAAGX,cAAc,CAACL,aAAa,CAACV,kBAAkB,CAAC;QACnE,IAAI,CAAC0B,UAAU,EACb,MAAM,IAAIjJ,SAAS,CAAC,wBAAwBd,QAAQ,EAAE,CAAC;QAEzD,MAAM/I,IAAI,GAAGsT,kBAAkB,CAAC3M,EAAE,EAAEmM,UAAU,EAAE3B,QAAQ,CAAC;QACzD,MAAMoC,OAAO,GAAGpB,cAAc,CAAC/D,UAAU,EAAE,CAACoF,cAAc,EAAE;QAC5D,MAAMC,MAAM,GAAGF,OAAO,CAACG,mBAAmB,CAAC1T,IAAI,CAAC;QAEhD,IAAI,CAACyT,MAAM,EAAE,OAAO;UAAEzO,IAAI,EAAE,EAAE;UAAEyM,OAAO,EAAE;QAAE,CAAE;QAE7C,MAAMkC,IAAI,GAAGJ,OAAO,CAACK,yBAAyB,CAACH,MAAM,EAAEzT,IAAI,CAAC;QAC5D,MAAM6T,UAAU,GAAG,CACjB,GAAGF,IAAI,CAACG,sBAAsB,EAAE,EAChC,GAAGH,IAAI,CAACI,iBAAiB,EAAE,CAC5B;QAED,OAAO;UACL/O,IAAI,EAAE6O,UAAU,CAACzH,MAAM,GACnByH,UAAU,CAAC3L,GAAG,CAAEzG,CAAC,IAAK8R,OAAO,CAACS,iBAAiB,CAACvS,CAAC,CAAC,CAAC,CAACyQ,IAAI,CAAC,IAAI,CAAC,GAC9DqB,OAAO,CAACU,YAAY,CAACN,IAAI,CAAC;UAC9BlC,OAAO,EAAE9K,EAAE,CAAC4K,oBAAoB,CAC9BkC,MAAM,GAAGA,MAAM,CAACS,uBAAuB,CAACX,OAAO,CAAC,GAAG,EAAE;SAExD;MACH,CAAC;MAED;MACA,IAAI3N,OAAO,CAAC1D,IAAI,IAAIoE,MAAM,CAACV,OAAO,CAACuO,WAAW,EAAE;QAC9CrU,OAAO,CAACsU,EAAE,CAAC,MAAM,EAAE,MAAK;UACtB;UACCjC,cAAc,CAAC/D,UAAU,EAAU,CAACiG,aAAa,EAAE;QACtD,CAAC,CAAC;;;GAGP,MAAM;IACLtH,WAAW,GAAGA,CAAA,KAAK;MACjB,MAAM,IAAIlD,SAAS,CACjB,uDAAuD,CACxD;IACH,CAAC;;EAGH,SAASyK,oCAAoCA,CAC3CC,kBAAmC,EACnClK,kBAAuC;IAEvC,MAAMvH,eAAe,GAAG;MAAE,GAAGwD,MAAM,CAACV;IAAO,CAAE;IAC7C,IAAI2O,kBAAkB,KAAKnT,SAAS,EAClC0B,eAAe,CAAC0R,MAAM,GAAGD,kBAAkB;IAC7C,IAAIE,gBAAgB,GAAG3K,gBAAgB,aAAhBA,gBAAgB,uBAAhBA,gBAAgB,CACrChH,eAAe,EACfuH,kBAAkB,CACnB;IACD,IAAIqK,iBAAiB,GAAG,IAAA7V,MAAA,CAAAsI,YAAY,EAACR,EAAE,CAAC/E,OAAO,EAAE,OAAO,CAAC,GACrD,IAAAxC,qBAAA,CAAAuV,uBAAuB,EAAChO,EAAE,EAAE;MAC1B7D,eAAe;MACf8R,iBAAiB,EAAE,IAAI;MACvBhN,YAAY,EAAEA;KACf,CAAC,GACFxG,SAAS;IACb,OAAO,CAAC6K,IAAY,EAAElD,QAAgB,KAAkB;MACtD,IAAIiK,MAA2B;MAC/B,IAAIyB,gBAAgB,EAAE;QACpBzB,MAAM,GAAGyB,gBAAgB,CAACI,SAAS,CAAC5I,IAAI,EAAE;UACxClD;SACD,CAAC;OACH,MAAM,IAAI2L,iBAAiB,EAAE;QAC5B1B,MAAM,GAAG0B,iBAAiB,CACxBzI,IAAI,EACJ;UACElD;SACD,EACDsB,kBAAkB,KAAK,SAAS,GAAG,QAAQ,GAAG,UAAU,CACzD;OACF,MAAM;QACL2I,MAAM,GAAGrM,EAAE,CAACmO,eAAe,CAAC7I,IAAI,EAAE;UAChClD,QAAQ;UACRjG,eAAe;UACf8R,iBAAiB,EAAE,IAAI;UACvBhN,YAAY,EAAEA;SACf,CAAC;;MAGJ,MAAMmJ,cAAc,GAAG1I,iBAAiB,CACtC2K,MAAM,CAACjO,WAAW,IAAI,EAAE,EACxB8C,iBAAiB,CAClB;MACD,IAAIkJ,cAAc,CAAC3E,MAAM,EAAEF,aAAa,CAAC6E,cAAc,CAAC;MAExD,OAAO,CAACiC,MAAM,CAAC+B,UAAU,EAAE/B,MAAM,CAACgC,aAAuB,EAAE,KAAK,CAAC;IACnE,CAAC;EACH;EAEA;EACA;EACA,MAAMC,sCAAsC,GAC1C3O,MAAM,CAACV,OAAO,CAAC4O,MAAM,KAAK7N,EAAE,CAACuO,UAAU,CAACC,QAAQ;EAClD;EACA,MAAMC,iCAAiC,GAAG,EACxC9O,MAAM,CAACV,OAAO,CAAC4O,MAAM,KAAK7N,EAAE,CAACuO,UAAU,CAACG,MAAM,IAC7C1O,EAAE,CAACuO,UAAU,CAACI,MAAM,IAAIhP,MAAM,CAACV,OAAO,CAAC4O,MAAM,KAAK7N,EAAE,CAACuO,UAAU,CAACI,MAAO,IACvE3O,EAAE,CAACuO,UAAU,CAACK,MAAM,IAAIjP,MAAM,CAACV,OAAO,CAAC4O,MAAM,KAAK7N,EAAE,CAACuO,UAAU,CAACK,MAAO,IACxEjP,MAAM,CAACV,OAAO,CAAC4O,MAAM,KAAK7N,EAAE,CAACuO,UAAU,CAACM,MAAM,CAC/C;EACD;;;;EAIA,MAAMC,gBAAgB,GACnB9O,EAAE,CAACuO,UAAU,CAACQ,MAAM,IAAIpP,MAAM,CAACV,OAAO,CAAC4O,MAAM,KAAK7N,EAAE,CAACuO,UAAU,CAACQ,MAAM,IACtE/O,EAAE,CAACuO,UAAU,CAACS,QAAQ,IACrBrP,MAAM,CAACV,OAAO,CAAC4O,MAAM,KAAK7N,EAAE,CAACuO,UAAU,CAACS,QAAS;EACrD,MAAMC,sBAAsB,GAAGtB,oCAAoC,CACjE3N,EAAE,CAACuO,UAAU,CAACC,QAAQ,CACvB;EACD,MAAMU,0BAA0B,GAAGvB,oCAAoC,CACrE3N,EAAE,CAACuO,UAAU,CAACS,QAAQ,EACtB,SAAS,CACV;EACD,MAAMG,qBAAqB,GAAGxB,oCAAoC,CAChE3N,EAAE,CAACuO,UAAU,CAACS,QAAQ,EACtB,SAAS,CACV;EACD;EACA,MAAMI,iBAAiB,GAAGzB,oCAAoC,CAC5D3N,EAAE,CAACuO,UAAU,CAACK,MAAM,IAAI5O,EAAE,CAACuO,UAAU,CAACI,MAAM,IAAI3O,EAAE,CAACuO,UAAU,CAACG,MAAM,CACrE;EACD,MAAMW,sBAAsB,GAAG1B,oCAAoC,EAAE;EAErE;EACA,SAAS2B,OAAOA,CAAChK,IAAY,EAAElD,QAAgB,EAAEmN,UAAU,GAAG,CAAC;IAC7D,MAAM9E,kBAAkB,GAAG,IAAAvS,MAAA,CAAAqM,gBAAgB,EAACnC,QAAQ,CAAC;IACrD,MAAMoN,cAAc,GAClBlJ,oBAAoB,CAACmJ,mCAAmC,CACtDhF,kBAAkB,CACnB;IACH,IAAIjM,KAAK,GAAuB,EAAE;IAClC,IAAIkR,SAAS,GAAuB,EAAE;IACtC,IAAIrF,WAAW,GAAG,IAAI;IACtB,IAAIlE,SAAS,EAAE;MACb;MACA,CAAC3H,KAAK,EAAEkR,SAAS,EAAErF,WAAW,CAAC,GAAGlE,SAAS,CAACb,IAAI,EAAEmF,kBAAkB,CAAC;;IAEvE;IACA,IACE+E,cAAc,CAACG,UAAU,KAAK,KAAK,KAClCrB,sCAAsC,IAAIjE,WAAW,CAAC,EACvD;MACA,CAAC7L,KAAK,EAAEkR,SAAS,CAAC,GAAGT,sBAAsB,CAAC3J,IAAI,EAAEmF,kBAAkB,CAAC;KACtE,MAAM,IACL+E,cAAc,CAACG,UAAU,KAAK,KAAK,KAClClB,iCAAiC,IAAIpE,WAAW,CAAC,EAClD;MACA,CAAC7L,KAAK,EAAEkR,SAAS,CAAC,GAAGN,iBAAiB,CAAC9J,IAAI,EAAEmF,kBAAkB,CAAC;KACjE,MAAM,IAAIJ,WAAW,EAAE;MACtB;MACA,MAAMmF,cAAc,GAAG,IAAAjX,6BAAA,CAAAqX,cAAc,EAACxN,QAAQ,EAAE0M,gBAAgB,CAAC;MACjE,CAACtQ,KAAK,EAAEkR,SAAS,CAAC,GAChBF,cAAc,KAAK,SAAS,GACxBN,0BAA0B,CAAC5J,IAAI,EAAEmF,kBAAkB,CAAC,GACpD+E,cAAc,KAAK,SAAS,GAC5BL,qBAAqB,CAAC7J,IAAI,EAAEmF,kBAAkB,CAAC,GAC/C+E,cAAc,KAAK,KAAK,GACxBP,sBAAsB,CAAC3J,IAAI,EAAEmF,kBAAkB,CAAC,GAChD+E,cAAc,KAAK,KAAK,GACxBJ,iBAAiB,CAAC9J,IAAI,EAAEmF,kBAAkB,CAAC,GAC3C4E,sBAAsB,CAAC/J,IAAI,EAAEmF,kBAAkB,CAAC;;IAExD,MAAMX,MAAM,GAAG+F,YAAY,CACzBrR,KAAM,EACNiM,kBAAkB,EAClBiF,SAAU,EACV5J,gBAAgB,CACjB;IACDlE,WAAW,CAACsG,GAAG,CAACuC,kBAAkB,EAAE;MAAEjG,OAAO,EAAEsF;IAAM,CAAE,CAAC;IACxD,OAAOA,MAAM;EACf;EAEA,IAAIgG,MAAM,GAAG,IAAI;EACjB,MAAMC,OAAO,GAAIA,OAAiB,IAChCA,OAAO,KAAKtV,SAAS,GAAGqV,MAAM,GAAIA,MAAM,GAAG,CAAC,CAACC,OAAQ;EACvD,MAAMC,OAAO,GAAI5N,QAAgB,IAAI;IACnC,IAAI,CAAC0N,MAAM,EAAE,OAAO,IAAI;IACxB,MAAM7J,GAAG,GAAG,IAAArO,MAAA,CAAAqY,OAAO,EAAC7N,QAAQ,CAAC;IAC7B,IAAIrD,UAAU,CAACG,QAAQ,CAACgR,QAAQ,CAACjK,GAAG,CAAC,EAAE;MACrC,OAAO,CAAC9D,QAAQ,CAACC,QAAQ,CAAC,IAAIG,YAAY,CAACH,QAAQ,CAAC;;IAEtD,OAAO,IAAI;EACb,CAAC;EAED,SAAS+N,mBAAmBA,CAACC,MAAwB;IACnDlP,iBAAiB,CAACmP,IAAI,CAAC;MACrB,GAAGD,MAAM;MACThP,iBAAiB,EAAEgP,MAAM,CAAChP,iBAAiB,CAACG,GAAG,CAAE+O,CAAC,IAChD,IAAApY,MAAA,CAAAqM,gBAAgB,EAAC+L,CAAC,CAAC;KAEtB,CAAC;EACJ;EAEA,MAAMC,kBAAkB,GAAG,IAAArY,MAAA,CAAAsY,IAAI,EAAC,MAE5B3Y,OAAO,CAAC,+CAA+C,CACxD,CAAC4Y,aAAa,CAAC;IACd1R,UAAU;IACVjC,YAAY,EAAEmC,OAAO,CAACnC,YAAY;IAClC4T,qCAAqC,EACnCzR,OAAO,CAAC0R;GACX,CAAC,CACH;EACD,MAAMC,mBAAmB,GAAG,IAAA1Y,MAAA,CAAAsY,IAAI,EAAC,MAE7B3Y,OAAO,CAAC,kDAAkD,CAC3D,CAACgZ,eAAe,CACf5R,OAAO,CAAC0R,+BAA+B,EACvCJ,kBAAkB,EAAE,CACrB,CACF;EACD,MAAMO,gBAAgB,GAAG,IAAA5Y,MAAA,CAAAsY,IAAI,EAAC,MAE1B3Y,OAAO,CAAC,8CAA8C,CACvD,CAACkZ,eAAe,CAAC;IAChBhS,UAAU;IACVjC,YAAY,EAAEmC,OAAO,CAACnC,YAAY;IAClCkU,eAAe,EAAET,kBAAkB;GACpC,CAAC,CACH;EAED,OAAO;IACL,CAAC9R,qBAAqB,GAAG,IAAI;IAC7BuB,EAAE;IACFiR,YAAY,EAAEhV,QAAQ;IACtB0D,MAAM;IACN2P,OAAO;IACPlJ,WAAW;IACX4J,OAAO;IACPD,OAAO;IACP9Q,OAAO;IACPS,cAAc;IACd4G,oBAAoB;IACpB7F,eAAe;IACf0P,mBAAmB;IACnBtM,uBAAuB;IACvBD,kCAAkC;IAClC1G,aAAa;IACb4C,yBAAyB;IACzByQ,kBAAkB;IAClBK,mBAAmB;IACnBE,gBAAgB;IAChB/R;GACD;AACH;AAl5BAlG,OAAA,CAAA4G,yBAAA,GAAAA,yBAAA;AAo5BA;;;AAGA,SAAS+C,YAAYA,CAACN,aAAqB,EAAE5F,MAAgB;EAC3D,OAAQ8F,QAAgB,IAAI;IAC1B,MAAM8O,OAAO,GAAG,IAAAtZ,MAAA,CAAAyK,QAAQ,EAACH,aAAa,EAAEE,QAAQ,CAAC;IACjD,MAAM+B,IAAI,GAAG,IAAAjM,MAAA,CAAAqM,gBAAgB,EAAC2M,OAAO,CAAC;IAEtC,OAAO5U,MAAM,CAAC6U,IAAI,CAAErW,CAAC,IAAKA,CAAC,CAACsW,IAAI,CAACjN,IAAI,CAAC,CAAC;EACzC,CAAC;AACH;AAEA;;;AAGA,SAASnF,kBAAkBA,CACzBlC,YAAwC,EACxCiC,UAAoB,EACpBH,OAAgB,EAChBE,iBAA2D;EAE3D,MAAMuS,IAAI,GAAG,IAAItK,GAAG,CAAChI,UAAU,CAAC;EAChC;EACA;EACA;EACA,KAAK,MAAMuS,SAAS,IAAI,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,CAAC,EAAE;IACxD,IAAID,IAAI,CAAC7H,GAAG,CAAC8H,SAAS,CAAC,IAAI,CAAC,IAAApZ,MAAA,CAAAqZ,cAAc,EAAC1Z,OAAO,CAACkH,UAAU,EAAEuS,SAAS,CAAC,EAAE;MACzE;MACAD,IAAI,CAAC5H,GAAG,CAAC,KAAK,CAAC;MACf4H,IAAI,CAACG,MAAM,CAACF,SAAS,CAAC;;;EAI1B;EACA,KAAK,MAAMrL,GAAG,IAAIoL,IAAI,EAAE;IACtBI,iBAAiB,CAACxL,GAAG,EAAErH,OAAO,EAAEE,iBAAiB,CAAC;;EAGpD,IAAIhC,YAAY,EAAE;IAChB,MAAM4U,mBAAmB,GAAG,IAAI3K,GAAG,CAAC,CAClC,GAAGsK,IAAI,EACP,GAAG1Y,MAAM,CAACgZ,IAAI,CAAC9Z,OAAO,CAACkH,UAAU,CAAC,CACnC,CAAC;IAEF;IACA,KAAK,MAAMkH,GAAG,IAAIyL,mBAAmB,EAAE;MACrC,MAAME,GAAG,GAAGjZ,MAAM,CAACkZ,wBAAwB,CAACha,OAAO,CAACkH,UAAU,EAAEkH,GAAG,CAAC;MACpE,OAAOpO,OAAO,CAACkH,UAAU,CAACkH,GAAG,CAAC;MAC9BtN,MAAM,CAACC,cAAc,CAACf,OAAO,CAACkH,UAAU,EAAEkH,GAAG,EAAE2L,GAAI,CAAC;;;AAG1D;AAEA;;;AAGA,SAASH,iBAAiBA,CACxBxL,GAAW,EACXrH,OAAgB,EAChBkT,eAAyD;EAEzD,MAAMF,GAAG,GAAG/Z,OAAO,CAACkH,UAAU,CAACkH,GAAG,CAAC,IAAI6L,eAAe;EAEtDja,OAAO,CAACkH,UAAU,CAACkH,GAAG,CAAC,GAAG,UAAU8L,CAAM,EAAEhN,QAAQ;IAClD,IAAInG,OAAO,CAACoR,OAAO,CAACjL,QAAQ,CAAC,EAAE,OAAO6M,GAAG,CAACG,CAAC,EAAEhN,QAAQ,CAAC;IAEtDxL,wBAAwB,CAACqF,OAAO,EAAEmT,CAAC,EAAEhN,QAAQ,CAAC;IAE9C,MAAMiN,QAAQ,GAAGD,CAAC,CAACC,QAAQ;IAE3BD,CAAC,CAACC,QAAQ,GAAG,UAAU1M,IAAY,EAAElD,QAAgB;MACnD,IAAAvJ,OAAA,CAAAsB,KAAK,EAAC,iBAAiB,EAAEiI,QAAQ,CAAC;MAElC,MAAMiK,MAAM,GAAGzN,OAAO,CAAC0Q,OAAO,CAAChK,IAAI,EAAElD,QAAQ,CAAC;MAC9C,OAAO4P,QAAQ,CAACC,IAAI,CAAC,IAAI,EAAE5F,MAAM,EAAEjK,QAAQ,CAAC;IAC9C,CAAC;IAED,OAAOwP,GAAG,CAACG,CAAC,EAAEhN,QAAQ,CAAC;EACzB,CAAC;AACH;AAOA;;;AAGA,SAAS8K,YAAYA,CACnBzB,UAAkB,EAClBhM,QAAgB,EAChBsN,SAAiB,EACjB5J,gBAA8C;EAE9C,MAAMoM,SAAS,GAAGC,MAAM,CAAC7K,IAAI,CAC3B8K,eAAe,CAAC1C,SAAS,EAAEtN,QAAQ,CAAC,EACpC,MAAM,CACP,CAAC2F,QAAQ,CAAC,QAAQ,CAAC;EACpB,MAAMsK,gBAAgB,GAAG,mEAAmEH,SAAS,EAAE;EACvG;EACA;EACA,MAAMI,MAAM,GAAG,uBAAuB;EACtC,MAAMC,YAAY,GAAGD,MAAM,CAAC7M,MAAM;EAClC,MAAM+M,QAAQ,GAAG,WAAY,IAAA5a,MAAA,CAAA6a,QAAQ,EAACrQ,QAAQ,CAAC;EAC/C,MAAMsQ,OAAO,GAAG,QAAS,IAAA9a,MAAA,CAAAqY,OAAO,EAAC7N,QAAQ,CAAC;EAC1C,MAAMuQ,SAAS,GAAG,OAAQ7M,gBAAgB,CAAC1D,QAAQ,CAAC;EACpD,MAAMwQ,iBAAiB,GACrBJ,QAAQ,CAACtM,KAAK,CAAC,CAAC,EAAE,CAACwM,OAAO,CAACjN,MAAM,CAAC,GAAGkN,SAAS,GAAG,MAAM;EACzD,MAAME,qCAAqC,GACzCN,YAAY,GAAGK,iBAAiB,CAACnN,MAAM;EACzC;;;;;;EAMA,IACE2I,UAAU,CAAC0E,MAAM,CAAC,CAACD,qCAAqC,EAAEN,YAAY,CAAC,KACvED,MAAM,EACN;IACA,OACElE,UAAU,CAAClI,KAAK,CAAC,CAAC,EAAE,CAAC2M,qCAAqC,CAAC,GAC3DR,gBAAgB;;EAGpB;EACA,MAAMU,kCAAkC,GACtCR,YAAY,GAAGS,SAAS,CAACJ,iBAAiB,CAAC,CAACnN,MAAM;EACpD,IACE2I,UAAU,CAAC0E,MAAM,CAAC,CAACC,kCAAkC,EAAER,YAAY,CAAC,KACpED,MAAM,EACN;IACA,OACElE,UAAU,CAAClI,KAAK,CAAC,CAAC,EAAE,CAAC6M,kCAAkC,CAAC,GACxDV,gBAAgB;;EAIpB,OAAO,GAAGjE,UAAU,KAAKiE,gBAAgB,EAAE;AAC7C;AAEA;;;AAGA,SAASD,eAAeA,CAAC/D,aAAqB,EAAEjM,QAAgB;EAC9D,MAAMsN,SAAS,GAAGuD,IAAI,CAAC7W,KAAK,CAACiS,aAAa,CAAC;EAC3CqB,SAAS,CAACpD,IAAI,GAAGlK,QAAQ;EACzBsN,SAAS,CAACwD,OAAO,GAAG,CAAC9Q,QAAQ,CAAC;EAC9B,OAAOsN,SAAS,CAACyD,UAAU;EAC3B,OAAOF,IAAI,CAACG,SAAS,CAAC1D,SAAS,CAAC;AAClC;AAEA;;;AAGA,SAAShO,iBAAiBA,CACxBtD,WAAsC,EACtCiV,OAA2B;EAE3B,OAAOjV,WAAW,CAACgS,MAAM,CAAEkD,CAAC,IAC1BD,OAAO,CAACE,KAAK,CACVjD,CAAC,IAAI;;IACJ,OAAC,CAACA,CAAC,CAACnP,iBAAiB,IACnBmP,CAAC,CAAClP,iBAAiB,CAACoS,OAAO,CAAC,CAAApY,EAAA,GAAAkY,CAAC,CAAChH,IAAI,cAAAlR,EAAA,uBAAAA,EAAA,CAAEgH,QAAS,CAAC,KAAK,CAAC,CAAC,IACvDkO,CAAC,CAACjP,kBAAkB,CAACmS,OAAO,CAACF,CAAC,CAAChO,IAAI,CAAC,KAAK,CAAC,CAAC;GAAA,CAC9C,CACF;AACH;AAEA;;;;;AAKA,SAASqH,kBAAkBA,CACzB3M,EAAY,EACZmM,UAA0B,EAC1B3B,QAAgB;EAEhB,IAAIiJ,OAAO,GAAatH,UAAU;EAElCuH,KAAK,EAAE,OAAO,IAAI,EAAE;IAClB,KAAK,MAAMC,KAAK,IAAIF,OAAO,CAACG,WAAW,CAACzH,UAAU,CAAC,EAAE;MACnD,MAAM0H,KAAK,GAAGF,KAAK,CAACG,YAAY,EAAE;MAClC,IAAID,KAAK,GAAGrJ,QAAQ,EAAE;MAEtB,MAAMuJ,GAAG,GAAGJ,KAAK,CAACK,MAAM,EAAE;MAC1B,IAAIxJ,QAAQ,IAAIuJ,GAAG,EAAE;QACnBN,OAAO,GAAGE,KAAK;QACf,SAASD,KAAK;;;IAIlB,OAAOD,OAAO;;AAElB;AAEA;;;;;;;;;;;;AAYO,MAAMQ,cAAc,GACzBC,aAAsB,IAClBrc,OAAO,CAAC,OAAO,CAA4B,CAACoc,cAAc,CAACC,aAAa,CAAC;AAFlErb,OAAA,CAAAob,cAAc,GAAAA,cAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}