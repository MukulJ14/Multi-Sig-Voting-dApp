{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CompilerDownloader = exports.CompilerPlatform = void 0;\nconst path_1 = __importDefault(require(\"path\"));\nconst fs_extra_1 = __importDefault(require(\"fs-extra\"));\nconst debug_1 = __importDefault(require(\"debug\"));\nconst os_1 = __importDefault(require(\"os\"));\nconst child_process_1 = require(\"child_process\");\nconst util_1 = require(\"util\");\nconst download_1 = require(\"../../util/download\");\nconst errors_1 = require(\"../../core/errors\");\nconst errors_list_1 = require(\"../../core/errors-list\");\nconst await_semaphore_1 = require(\"../../vendor/await-semaphore\");\nconst log = (0, debug_1.default)(\"hardhat:core:solidity:downloader\");\nconst COMPILER_REPOSITORY_URL = \"https://binaries.soliditylang.org\";\nvar CompilerPlatform;\n(function (CompilerPlatform) {\n  CompilerPlatform[\"LINUX\"] = \"linux-amd64\";\n  CompilerPlatform[\"WINDOWS\"] = \"windows-amd64\";\n  CompilerPlatform[\"MACOS\"] = \"macosx-amd64\";\n  CompilerPlatform[\"WASM\"] = \"wasm\";\n})(CompilerPlatform = exports.CompilerPlatform || (exports.CompilerPlatform = {}));\n/**\n * Default implementation of ICompilerDownloader.\n *\n * Important things to note:\n *   1. If a compiler version is not found, this downloader may fail.\n *    1.1. It only re-downloads the list of compilers once every X time.\n *      1.1.1 If a user tries to download a new compiler before X amount of time\n *      has passed since its release, they may need to clean the cache, as\n *      indicated in the error messages.\n */\nclass CompilerDownloader {\n  static getCompilerPlatform() {\n    // TODO: This check is seriously wrong. It doesn't take into account\n    //  the architecture nor the toolchain. This should check the triplet of\n    //  system instead (see: https://wiki.osdev.org/Target_Triplet).\n    //\n    //  The only reason this downloader works is that it validates if the\n    //  binaries actually run.\n    switch (os_1.default.platform()) {\n      case \"win32\":\n        return CompilerPlatform.WINDOWS;\n      case \"linux\":\n        return CompilerPlatform.LINUX;\n      case \"darwin\":\n        return CompilerPlatform.MACOS;\n      default:\n        return CompilerPlatform.WASM;\n    }\n  }\n  static getConcurrencySafeDownloader(platform, compilersDir) {\n    const key = platform + compilersDir;\n    if (!this._downloaderPerPlatform.has(key)) {\n      this._downloaderPerPlatform.set(key, new CompilerDownloader(platform, compilersDir));\n    }\n    return this._downloaderPerPlatform.get(key);\n  }\n  /**\n   * Use CompilerDownloader.getConcurrencySafeDownloader instead\n   */\n  constructor(_platform, _compilersDir, _compilerListCachePeriodMs = CompilerDownloader.defaultCompilerListCachePeriod, _downloadFunction = download_1.download) {\n    this._platform = _platform;\n    this._compilersDir = _compilersDir;\n    this._compilerListCachePeriodMs = _compilerListCachePeriodMs;\n    this._downloadFunction = _downloadFunction;\n    this._mutex = new await_semaphore_1.Mutex();\n  }\n  async isCompilerDownloaded(version) {\n    const build = await this._getCompilerBuild(version);\n    if (build === undefined) {\n      return false;\n    }\n    const downloadPath = this._getCompilerBinaryPathFromBuild(build);\n    return fs_extra_1.default.pathExists(downloadPath);\n  }\n  async downloadCompiler(version) {\n    await this._mutex.use(async () => {\n      let build = await this._getCompilerBuild(version);\n      if (build === undefined && (await this._shouldDownloadCompilerList())) {\n        try {\n          await this._downloadCompilerList();\n        } catch (e) {\n          throw new errors_1.HardhatError(errors_list_1.ERRORS.SOLC.VERSION_LIST_DOWNLOAD_FAILED, {}, e);\n        }\n        build = await this._getCompilerBuild(version);\n      }\n      if (build === undefined) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.SOLC.INVALID_VERSION, {\n          version\n        });\n      }\n      let downloadPath;\n      try {\n        downloadPath = await this._downloadCompiler(build);\n      } catch (e) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.SOLC.DOWNLOAD_FAILED, {\n          remoteVersion: build.longVersion\n        }, e);\n      }\n      const verified = await this._verifyCompilerDownload(build, downloadPath);\n      if (!verified) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.SOLC.INVALID_DOWNLOAD, {\n          remoteVersion: build.longVersion\n        });\n      }\n      await this._postProcessCompilerDownload(build, downloadPath);\n    });\n  }\n  async getCompiler(version) {\n    const build = await this._getCompilerBuild(version);\n    (0, errors_1.assertHardhatInvariant)(build !== undefined, \"Trying to get a compiler before it was downloaded\");\n    const compilerPath = this._getCompilerBinaryPathFromBuild(build);\n    (0, errors_1.assertHardhatInvariant)(await fs_extra_1.default.pathExists(compilerPath), \"Trying to get a compiler before it was downloaded\");\n    if (await fs_extra_1.default.pathExists(this._getCompilerDoesntWorkFile(build))) {\n      return undefined;\n    }\n    return {\n      version,\n      longVersion: build.longVersion,\n      compilerPath,\n      isSolcJs: this._platform === CompilerPlatform.WASM\n    };\n  }\n  async _getCompilerBuild(version) {\n    const listPath = this._getCompilerListPath();\n    if (!(await fs_extra_1.default.pathExists(listPath))) {\n      return undefined;\n    }\n    const list = await this._readCompilerList(listPath);\n    return list.builds.find(b => b.version === version);\n  }\n  _getCompilerListPath() {\n    return path_1.default.join(this._compilersDir, this._platform, \"list.json\");\n  }\n  async _readCompilerList(listPath) {\n    return fs_extra_1.default.readJSON(listPath);\n  }\n  _getCompilerDownloadPathFromBuild(build) {\n    return path_1.default.join(this._compilersDir, this._platform, build.path);\n  }\n  _getCompilerBinaryPathFromBuild(build) {\n    const downloadPath = this._getCompilerDownloadPathFromBuild(build);\n    if (this._platform !== CompilerPlatform.WINDOWS || !downloadPath.endsWith(\".zip\")) {\n      return downloadPath;\n    }\n    return path_1.default.join(this._compilersDir, build.version, \"solc.exe\");\n  }\n  _getCompilerDoesntWorkFile(build) {\n    return `${this._getCompilerBinaryPathFromBuild(build)}.does.not.work`;\n  }\n  async _shouldDownloadCompilerList() {\n    const listPath = this._getCompilerListPath();\n    if (!(await fs_extra_1.default.pathExists(listPath))) {\n      return true;\n    }\n    const stats = await fs_extra_1.default.stat(listPath);\n    const age = new Date().valueOf() - stats.ctimeMs;\n    return age > this._compilerListCachePeriodMs;\n  }\n  async _downloadCompilerList() {\n    log(`Downloading compiler list for platform ${this._platform}`);\n    const url = `${COMPILER_REPOSITORY_URL}/${this._platform}/list.json`;\n    const downloadPath = this._getCompilerListPath();\n    await this._downloadFunction(url, downloadPath);\n  }\n  async _downloadCompiler(build) {\n    log(`Downloading compiler ${build.longVersion}`);\n    const url = `${COMPILER_REPOSITORY_URL}/${this._platform}/${build.path}`;\n    const downloadPath = this._getCompilerDownloadPathFromBuild(build);\n    await this._downloadFunction(url, downloadPath);\n    return downloadPath;\n  }\n  async _verifyCompilerDownload(build, downloadPath) {\n    const ethereumjsUtil = require(\"@nomicfoundation/ethereumjs-util\");\n    const {\n      keccak256\n    } = await Promise.resolve().then(() => __importStar(require(\"../../util/keccak\")));\n    const expectedKeccak256 = build.keccak256;\n    const compiler = await fs_extra_1.default.readFile(downloadPath);\n    const compilerKeccak256 = ethereumjsUtil.bufferToHex(keccak256(compiler));\n    if (expectedKeccak256 !== compilerKeccak256) {\n      await fs_extra_1.default.unlink(downloadPath);\n      return false;\n    }\n    return true;\n  }\n  async _postProcessCompilerDownload(build, downloadPath) {\n    if (this._platform === CompilerPlatform.WASM) {\n      return;\n    }\n    if (this._platform === CompilerPlatform.LINUX || this._platform === CompilerPlatform.MACOS) {\n      fs_extra_1.default.chmodSync(downloadPath, 0o755);\n    } else if (this._platform === CompilerPlatform.WINDOWS && downloadPath.endsWith(\".zip\")) {\n      // some window builds are zipped, some are not\n      const AdmZip = require(\"adm-zip\");\n      const solcFolder = path_1.default.join(this._compilersDir, build.version);\n      await fs_extra_1.default.ensureDir(solcFolder);\n      const zip = new AdmZip(downloadPath);\n      zip.extractAllTo(solcFolder);\n    }\n    log(\"Checking native solc binary\");\n    const nativeSolcWorks = await this._checkNativeSolc(build);\n    if (nativeSolcWorks) {\n      return;\n    }\n    await fs_extra_1.default.createFile(this._getCompilerDoesntWorkFile(build));\n  }\n  async _checkNativeSolc(build) {\n    const solcPath = this._getCompilerBinaryPathFromBuild(build);\n    const execFileP = (0, util_1.promisify)(child_process_1.execFile);\n    try {\n      await execFileP(solcPath, [\"--version\"]);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n}\nCompilerDownloader._downloaderPerPlatform = new Map();\nCompilerDownloader.defaultCompilerListCachePeriod = 360000;\nexports.CompilerDownloader = CompilerDownloader;","map":{"version":3,"names":["path_1","__importDefault","require","fs_extra_1","debug_1","os_1","child_process_1","util_1","download_1","errors_1","errors_list_1","await_semaphore_1","log","default","COMPILER_REPOSITORY_URL","CompilerPlatform","exports","CompilerDownloader","getCompilerPlatform","platform","WINDOWS","LINUX","MACOS","WASM","getConcurrencySafeDownloader","compilersDir","key","_downloaderPerPlatform","has","set","get","constructor","_platform","_compilersDir","_compilerListCachePeriodMs","defaultCompilerListCachePeriod","_downloadFunction","download","_mutex","Mutex","isCompilerDownloaded","version","build","_getCompilerBuild","undefined","downloadPath","_getCompilerBinaryPathFromBuild","pathExists","downloadCompiler","use","_shouldDownloadCompilerList","_downloadCompilerList","e","HardhatError","ERRORS","SOLC","VERSION_LIST_DOWNLOAD_FAILED","INVALID_VERSION","_downloadCompiler","DOWNLOAD_FAILED","remoteVersion","longVersion","verified","_verifyCompilerDownload","INVALID_DOWNLOAD","_postProcessCompilerDownload","getCompiler","assertHardhatInvariant","compilerPath","_getCompilerDoesntWorkFile","isSolcJs","listPath","_getCompilerListPath","list","_readCompilerList","builds","find","b","join","readJSON","_getCompilerDownloadPathFromBuild","path","endsWith","stats","stat","age","Date","valueOf","ctimeMs","url","ethereumjsUtil","keccak256","Promise","resolve","then","__importStar","expectedKeccak256","compiler","readFile","compilerKeccak256","bufferToHex","unlink","chmodSync","AdmZip","solcFolder","ensureDir","zip","extractAllTo","nativeSolcWorks","_checkNativeSolc","createFile","solcPath","execFileP","promisify","execFile","Map"],"sources":["/Users/mukuljindal/Local/projects/fuckingwork/node_modules/hardhat/src/internal/solidity/compiler/downloader.ts"],"sourcesContent":["import path from \"path\";\nimport fsExtra from \"fs-extra\";\nimport debug from \"debug\";\nimport os from \"os\";\nimport { execFile } from \"child_process\";\nimport { promisify } from \"util\";\n\nimport { download } from \"../../util/download\";\nimport { assertHardhatInvariant, HardhatError } from \"../../core/errors\";\nimport { ERRORS } from \"../../core/errors-list\";\nimport { Mutex } from \"../../vendor/await-semaphore\";\n\nconst log = debug(\"hardhat:core:solidity:downloader\");\n\nconst COMPILER_REPOSITORY_URL = \"https://binaries.soliditylang.org\";\n\nexport enum CompilerPlatform {\n  LINUX = \"linux-amd64\",\n  WINDOWS = \"windows-amd64\",\n  MACOS = \"macosx-amd64\",\n  WASM = \"wasm\",\n}\n\nexport interface Compiler {\n  version: string;\n  longVersion: string;\n  compilerPath: string;\n  isSolcJs: boolean;\n}\n\ninterface CompilerBuild {\n  path: string;\n  version: string;\n  build: string;\n  longVersion: string;\n  keccak256: string;\n  urls: string[];\n  platform: CompilerPlatform;\n}\n\ninterface CompilerList {\n  builds: CompilerBuild[];\n  releases: { [version: string]: string };\n  latestRelease: string;\n}\n\n/**\n * A compiler downloader which must be specialized per-platform. It can't and\n * shouldn't support multiple platforms at the same time.\n */\nexport interface ICompilerDownloader {\n  /**\n   * Returns true if the compiler has been downloaded.\n   *\n   * This function access the filesystem, but doesn't modify it.\n   */\n  isCompilerDownloaded(version: string): Promise<boolean>;\n\n  /**\n   * Downloads the compiler for a given version, which can later be obtained\n   * with getCompiler.\n   */\n  downloadCompiler(version: string): Promise<void>;\n\n  /**\n   * Returns the compiler, which MUST be downloaded before calling this function.\n   *\n   * Returns undefined if the compiler has been downloaded but can't be run.\n   *\n   * This function access the filesystem, but doesn't modify it.\n   */\n  getCompiler(version: string): Promise<Compiler | undefined>;\n}\n\n/**\n * Default implementation of ICompilerDownloader.\n *\n * Important things to note:\n *   1. If a compiler version is not found, this downloader may fail.\n *    1.1. It only re-downloads the list of compilers once every X time.\n *      1.1.1 If a user tries to download a new compiler before X amount of time\n *      has passed since its release, they may need to clean the cache, as\n *      indicated in the error messages.\n */\nexport class CompilerDownloader implements ICompilerDownloader {\n  public static getCompilerPlatform(): CompilerPlatform {\n    // TODO: This check is seriously wrong. It doesn't take into account\n    //  the architecture nor the toolchain. This should check the triplet of\n    //  system instead (see: https://wiki.osdev.org/Target_Triplet).\n    //\n    //  The only reason this downloader works is that it validates if the\n    //  binaries actually run.\n    switch (os.platform()) {\n      case \"win32\":\n        return CompilerPlatform.WINDOWS;\n      case \"linux\":\n        return CompilerPlatform.LINUX;\n      case \"darwin\":\n        return CompilerPlatform.MACOS;\n      default:\n        return CompilerPlatform.WASM;\n    }\n  }\n\n  private static _downloaderPerPlatform: Map<string, CompilerDownloader> =\n    new Map();\n\n  public static getConcurrencySafeDownloader(\n    platform: CompilerPlatform,\n    compilersDir: string\n  ) {\n    const key = platform + compilersDir;\n\n    if (!this._downloaderPerPlatform.has(key)) {\n      this._downloaderPerPlatform.set(\n        key,\n        new CompilerDownloader(platform, compilersDir)\n      );\n    }\n\n    return this._downloaderPerPlatform.get(key)!;\n  }\n\n  public static defaultCompilerListCachePeriod = 3_600_00;\n  private readonly _mutex = new Mutex();\n\n  /**\n   * Use CompilerDownloader.getConcurrencySafeDownloader instead\n   */\n  constructor(\n    private readonly _platform: CompilerPlatform,\n    private readonly _compilersDir: string,\n    private readonly _compilerListCachePeriodMs = CompilerDownloader.defaultCompilerListCachePeriod,\n    private readonly _downloadFunction: typeof download = download\n  ) {}\n\n  public async isCompilerDownloaded(version: string): Promise<boolean> {\n    const build = await this._getCompilerBuild(version);\n\n    if (build === undefined) {\n      return false;\n    }\n\n    const downloadPath = this._getCompilerBinaryPathFromBuild(build);\n\n    return fsExtra.pathExists(downloadPath);\n  }\n\n  public async downloadCompiler(version: string): Promise<void> {\n    await this._mutex.use(async () => {\n      let build = await this._getCompilerBuild(version);\n\n      if (build === undefined && (await this._shouldDownloadCompilerList())) {\n        try {\n          await this._downloadCompilerList();\n        } catch (e: any) {\n          throw new HardhatError(\n            ERRORS.SOLC.VERSION_LIST_DOWNLOAD_FAILED,\n            {},\n            e\n          );\n        }\n\n        build = await this._getCompilerBuild(version);\n      }\n\n      if (build === undefined) {\n        throw new HardhatError(ERRORS.SOLC.INVALID_VERSION, { version });\n      }\n\n      let downloadPath: string;\n      try {\n        downloadPath = await this._downloadCompiler(build);\n      } catch (e: any) {\n        throw new HardhatError(\n          ERRORS.SOLC.DOWNLOAD_FAILED,\n          {\n            remoteVersion: build.longVersion,\n          },\n          e\n        );\n      }\n\n      const verified = await this._verifyCompilerDownload(build, downloadPath);\n      if (!verified) {\n        throw new HardhatError(ERRORS.SOLC.INVALID_DOWNLOAD, {\n          remoteVersion: build.longVersion,\n        });\n      }\n\n      await this._postProcessCompilerDownload(build, downloadPath);\n    });\n  }\n\n  public async getCompiler(version: string): Promise<Compiler | undefined> {\n    const build = await this._getCompilerBuild(version);\n\n    assertHardhatInvariant(\n      build !== undefined,\n      \"Trying to get a compiler before it was downloaded\"\n    );\n\n    const compilerPath = this._getCompilerBinaryPathFromBuild(build);\n\n    assertHardhatInvariant(\n      await fsExtra.pathExists(compilerPath),\n      \"Trying to get a compiler before it was downloaded\"\n    );\n\n    if (await fsExtra.pathExists(this._getCompilerDoesntWorkFile(build))) {\n      return undefined;\n    }\n\n    return {\n      version,\n      longVersion: build.longVersion,\n      compilerPath,\n      isSolcJs: this._platform === CompilerPlatform.WASM,\n    };\n  }\n\n  private async _getCompilerBuild(\n    version: string\n  ): Promise<CompilerBuild | undefined> {\n    const listPath = this._getCompilerListPath();\n    if (!(await fsExtra.pathExists(listPath))) {\n      return undefined;\n    }\n\n    const list = await this._readCompilerList(listPath);\n    return list.builds.find((b) => b.version === version);\n  }\n\n  private _getCompilerListPath(): string {\n    return path.join(this._compilersDir, this._platform, \"list.json\");\n  }\n\n  private async _readCompilerList(listPath: string): Promise<CompilerList> {\n    return fsExtra.readJSON(listPath);\n  }\n\n  private _getCompilerDownloadPathFromBuild(build: CompilerBuild): string {\n    return path.join(this._compilersDir, this._platform, build.path);\n  }\n\n  private _getCompilerBinaryPathFromBuild(build: CompilerBuild): string {\n    const downloadPath = this._getCompilerDownloadPathFromBuild(build);\n\n    if (\n      this._platform !== CompilerPlatform.WINDOWS ||\n      !downloadPath.endsWith(\".zip\")\n    ) {\n      return downloadPath;\n    }\n\n    return path.join(this._compilersDir, build.version, \"solc.exe\");\n  }\n\n  private _getCompilerDoesntWorkFile(build: CompilerBuild): string {\n    return `${this._getCompilerBinaryPathFromBuild(build)}.does.not.work`;\n  }\n\n  private async _shouldDownloadCompilerList(): Promise<boolean> {\n    const listPath = this._getCompilerListPath();\n    if (!(await fsExtra.pathExists(listPath))) {\n      return true;\n    }\n\n    const stats = await fsExtra.stat(listPath);\n    const age = new Date().valueOf() - stats.ctimeMs;\n\n    return age > this._compilerListCachePeriodMs;\n  }\n\n  private async _downloadCompilerList(): Promise<void> {\n    log(`Downloading compiler list for platform ${this._platform}`);\n    const url = `${COMPILER_REPOSITORY_URL}/${this._platform}/list.json`;\n    const downloadPath = this._getCompilerListPath();\n\n    await this._downloadFunction(url, downloadPath);\n  }\n\n  private async _downloadCompiler(build: CompilerBuild): Promise<string> {\n    log(`Downloading compiler ${build.longVersion}`);\n    const url = `${COMPILER_REPOSITORY_URL}/${this._platform}/${build.path}`;\n    const downloadPath = this._getCompilerDownloadPathFromBuild(build);\n\n    await this._downloadFunction(url, downloadPath);\n\n    return downloadPath;\n  }\n\n  private async _verifyCompilerDownload(\n    build: CompilerBuild,\n    downloadPath: string\n  ): Promise<boolean> {\n    const ethereumjsUtil = require(\"@nomicfoundation/ethereumjs-util\");\n    const { keccak256 } = await import(\"../../util/keccak\");\n\n    const expectedKeccak256 = build.keccak256;\n    const compiler = await fsExtra.readFile(downloadPath);\n\n    const compilerKeccak256 = ethereumjsUtil.bufferToHex(keccak256(compiler));\n\n    if (expectedKeccak256 !== compilerKeccak256) {\n      await fsExtra.unlink(downloadPath);\n      return false;\n    }\n\n    return true;\n  }\n\n  private async _postProcessCompilerDownload(\n    build: CompilerBuild,\n    downloadPath: string\n  ): Promise<void> {\n    if (this._platform === CompilerPlatform.WASM) {\n      return;\n    }\n\n    if (\n      this._platform === CompilerPlatform.LINUX ||\n      this._platform === CompilerPlatform.MACOS\n    ) {\n      fsExtra.chmodSync(downloadPath, 0o755);\n    } else if (\n      this._platform === CompilerPlatform.WINDOWS &&\n      downloadPath.endsWith(\".zip\")\n    ) {\n      // some window builds are zipped, some are not\n      const AdmZip = require(\"adm-zip\");\n\n      const solcFolder = path.join(this._compilersDir, build.version);\n      await fsExtra.ensureDir(solcFolder);\n\n      const zip = new AdmZip(downloadPath);\n      zip.extractAllTo(solcFolder);\n    }\n\n    log(\"Checking native solc binary\");\n    const nativeSolcWorks = await this._checkNativeSolc(build);\n\n    if (nativeSolcWorks) {\n      return;\n    }\n\n    await fsExtra.createFile(this._getCompilerDoesntWorkFile(build));\n  }\n\n  private async _checkNativeSolc(build: CompilerBuild): Promise<boolean> {\n    const solcPath = this._getCompilerBinaryPathFromBuild(build);\n    const execFileP = promisify(execFile);\n\n    try {\n      await execFileP(solcPath, [\"--version\"]);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}